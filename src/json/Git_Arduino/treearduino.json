{"interestingcomments": [{"Unnamed: 0": 2074, "autor": 34, "date": null, "content": "ESP8266Audio - supports ESP8266 & ESP32 & Raspberry Pi RP2040\nArduino library for parsing and decoding MOD, WAV, MP3, FLAC, MIDI, AAC, and RTTL files and playing them on an I2S DAC or even using a software-simulated delta-sigma DAC with dynamic 32x-128x oversampling.\nESP8266 is fully supported and most mature, but ESP32 is also mostly there with built-in DAC as well as external ones.\nFor real-time, autonomous speech synthesis, check out ESP8266SAM, a library which uses this one and a port of an ancient format-based synthesis program to allow your ESP8266 to talk with low memory and no network required.\nDisclaimer\nAll this code is released under the GPL, and all of it is to be used at your own risk. If you find any bugs, please let me know via the GitHub issue tracker or drop me an email. The MOD and MP3 routines were taken from StellaPlayer and libMAD respectively. The software I2S delta-sigma 32x oversampling DAC was my own creation, and sounds quite good if I do say so myself.\nThe AAC decode code is from the Helix project and licensed under RealNetwork's RSPL license. For commercial use you're still going to need the usual AAC licensing from Via Licensing.\nOn the ESP32, AAC-SBR is supported (many webradio stations use this to reduce bandwidth even further). The ESP8266, however, does not support it due to a lack of onboard RAM.\nMIDI decoding comes from a highly ported MIDITONES combined with a massively memory-optimized TinySoundFont, see the respective source files for more information.\nOpus, OGG, and OpusFile are from Xiph.org with the Xiph license and patent described in src/{opusfile,libggg,libopus}/COPYING.. NOTE Opus decoding currently only works on the ESP32 due to the large memory requirements of opusfile. PRs to rewrite it to be less memory intensive would be much appreciated.\nNeat Things People Have Done With ESP8266Audio\nIf you have a neat use for this library, I'd love to hear about it!\nMy personal use of the ESP8266Audio library is only to drive a 3D-printed, network-time-setting alarm clock for my kids which can play an MP3 instead of a bell to wake them up, called Psychoclock.\nHarald Sattler has built a neat German word clock with MP3 alarm. Detailed discussion on the process and models are included.\nErich Heinemann has developed a Stomper (instrument for playing samples in real-time during a live stage performance) that you can find more info about here.\nDagnall53 has integrated this into a really neat MQTT based model train controller to add sounds to his set. More info is available here, including STL files for 3D printed components!\nJohannesMTC has built a similar project especially for model trains: https://github.com/JohannesMTC/ESP32_MAS\nA neat MQTT-driven ESP8266 light-and-sound device (alarm? toy? who can say!) was built by @CosmicMac, available at https://github.com/CosmicMac/ESParkle\nA very interesting \"linear clock\" with a stepper motor, NTP time keeping, and configurable recorded chimes with schematics, 3D printer plans, and source code, is now available https://janderogee.com/projects/linear_clock/linear_clock.htm\nPrerequisites\nFirst, make sure you are running the 2.6.3/later or GIT head version of the Arduino libraries for ESP8266, or the latest ESP32 SDK from Espressif.\nYou can use GIT to pull right from GitHub: see this README for detailed instructions.\nInstallation\nInstall the library in your ~/Arduino/libraries\nmkdir -p ~/Arduino/libraries\ncd ~/Arduino/libraries\ngit clone https://github.com/earlephilhower/ESP8266Audio\nWhen in the IDE please select the following options on the ESP8266:\nTools->lwIP Variant->v1.4 Open Source, or V2 Higher Bandwidth\nTools->CPU Frequency->160MHz\nUsage\nCreate an AudioInputXXX source pointing to your input file, an AudioOutputXXX sink as either an I2S, I2S-sw-DAC, or as a \"SerialWAV\" which simply writes a WAV file to the Serial port which can be dumped to a file on your development system, and an AudioGeneratorXXX to actually take that input and decode it and send to the output.\nAfter creation, you need to call the AudioGeneratorXXX::loop() routine from inside your own main loop() one or more times. This will automatically read as much of the file as needed and fill up the I2S buffers and immediately return. Since this is not interrupt driven, if you have large delay()s in your code, you may end up with hiccups in playback. Either break large delays into very small ones with calls to AudioGenerator::loop(), or reduce the sampling rate to require fewer samples per second.\nExample\nSee the examples directory for some simple examples, but the following snippet can play an MP3 file over the simulated I2S DAC:\n#include <Arduino.h>\n#include \"AudioFileSourceSPIFFS.h\"\n#include \"AudioGeneratorMP3.h\"\n#include \"AudioOutputI2SNoDAC.h\"\nAudioGeneratorMP3 *mp3;\nAudioFileSourceSPIFFS *file;\nAudioOutputI2SNoDAC *out;\nvoid setup()\n{\nSerial.begin(115200);\ndelay(1000);\nSPIFFS.begin();\nfile = new AudioFileSourceSPIFFS(\"/jamonit.mp3\");\nout = new AudioOutputI2SNoDAC();\nmp3 = new AudioGeneratorMP3();\nmp3->begin(file, out);\n}\nvoid loop()\n{\nif (mp3->isRunning()) {\nif (!mp3->loop()) mp3->stop();\n} else {\nSerial.printf(\"MP3 done\\n\");\ndelay(1000);\n}\n}\nAudioFileSource classes\nAudioFileSource: Base class which implements a very simple read-only \"file\" interface. Required because it seems everyone has invented their own filesystem on the Arduino with their own unique twist. Using this wrapper lets that be abstracted and makes the AudioGenerator simpler as it only calls these simple functions.\nAudioFileSourceSPIFFS: Reads a file from the SPIFFS filesystem\nAudioFileSourcePROGMEM: Reads a file from a PROGMEM array. Under UNIX you can use \"xxd -i file.mp3 > file.h\" to get the basic format, then add \"const\" and \"PROGMEM\" to the generated array and include it in your sketch. See the example .h files for a concrete example.\nAudioFileSourceHTTPStream: Simple implementation of a streaming HTTP reader for ShoutCast-type MP3 streaming. Not yet resilient, and at 44.1khz 128bit stutters due to CPU limitations, but it works more or less.\nAudioFileSourceBuffer - Double buffering, useful for HTTP streams\nAudioFileSourceBuffer is an input source that simply adds an additional RAM buffer of the output of any other AudioFileSource. This is particularly useful for web streaming where you need to have 1-2 packets in memory to ensure hiccup-free playback.\nCreate your standard input file source, create the buffer with the original source as its input, and pass this buffer object to the generator.\n...\nAudioGeneratorMP3 *mp3;\nAudioFileSourceHTTPStream *file;\nAudioFileSourceBuffer *buff;\nAudioOutputI2SNoDAC *out;\n...\n// Create the HTTP stream normally\nfile = new AudioFileSourceHTTPStream(\"http://your.url.here/mp3\");\n// Create a buffer using that stream\nbuff = new AudioFileSourceBuffer(file, 2048);\nout = new AudioOutputI2SNoDAC();\nmp3 = new AudioGeneratorMP3();\n// Pass in the *buffer*, not the *http stream* to enable buffering\nmp3->begin(buff, out);\n...\nAudioFileSourceID3 - ID3 stream parser filter with a user-specified callback\nThis class, which takes as input any other AudioFileSource and outputs an AudioFileSource suitable for any decoder, automatically parses out ID3 tags from MP3 files. You need to specify a callback function, which will be called as tags are decoded and allow you to update your UI state with this information. See the PlayMP3FromSPIFFS example for more information.\nAudioGenerator classes\nAudioGenerator: Base class for all file decoders. Takes a AudioFileSource and an AudioOutput object to get the data from and to write decoded samples to. Call its loop() function as often as you can to ensure the buffers are always kept full and your music won't skip.\nAudioGeneratorWAV: Reads and plays Microsoft WAVE (.WAV) format files of 8 or 16 bits.\nAudioGeneratorMOD: Reads and plays Amiga ModTracker files (.MOD). Use a 160MHz clock as this requires tons of SPIFFS reads (which are painfully slow) to get raw instrument sample data for every output sample. See https://modarchive.org for many free MOD files.\nAudioGeneratorMP3: Reads and plays MP3 format files (.MP3) using a ported libMAD library. Use a 160MHz clock to ensure enough compute power to decode 128KBit 44.1KHz without hiccups. For complete porting history with the gory details, look at https://github.com/earlephilhower/libmad-8266\nAudioGeneratorFLAC: Plays FLAC files via ported libflac-1.3.2. On the order of 30KB heap and minimal stack required as-is.\nAudioGeneratorMIDI: Plays a MIDI file using a wavetable synthesizer and a SoundFont2 wavetable input. Theoretically up to 16 simultaneous notes available, but depending on the memory needed for the SF2 structures you may not be able to get that many before hitting OOM.\nAudioGeneratorAAC: Requires about 30KB of heap and plays a mono or stereo AAC file using the Helix fixed-point AAC decoder.\nAudioGeneratorRTTTL: Enjoy the pleasures of monophonic, 4-octave ringtones on your ESP8266. Very low memory and CPU requirements for simple tunes.\nAudioOutput classes\nAudioOutput: Base class for all output drivers. Takes a sample at a time and returns true/false if there is buffer space for it. If it returns false, it is the calling object's (AudioGenerator's) job to keep the data that didn't fit and try again later.\nAudioOutputI2S: Interface for any I2S 16-bit DAC. Sends stereo or mono signals out at whatever frequency set. Tested with Adafruit's I2SDAC and a Beyond9032 DAC from eBay. Tested up to 44.1KHz. To use the internal DAC on ESP32, instantiate this class as AudioOutputI2S(0,1), see example PlayMODFromPROGMEMToDAC and code in AudioOutputI2S.cpp for details.\nAudioOutputI2SNoDAC: Abuses the I2S interface to play music without a DAC. Turns it into a 32x (or higher) oversampling delta-sigma DAC. Use the schematic below to drive a speaker or headphone from the I2STx pin (i.e. Rx). Note that with this interface, depending on the transistor used, you may need to disconnect the Rx pin from the driver to perform serial uploads. Mono-only output, of course.\nAudioOutputSPDIF (experimental): Another way to abuse the I2S peripheral to send out BMC encoded S/PDIF bitstream. To interface with S/PDIF receiver it needs optical or coaxial transceiver, for which some examples can be found at https://www.epanorama.net/documents/audio/spdif.html. It should work even with the simplest form with red LED and current limiting resistor, fed into TOSLINK cable. Minimum sample rate supported by is 32KHz. Due to BMC coding, actual symbol rate on the pin is 4x normal I2S data rate, which drains DMA buffers quickly. See more details inside AudioOutputSPDIF.cpp\nAudioOutputSerialWAV: Writes a binary WAV format with headers to the Serial port. If you capture the serial output to a file you can play it back on your development system.\nAudioOutputSPIFFSWAV: Writes a binary WAV format with headers to a SPIFFS filesystem. Ensure the FS is mounted and SPIFFS is started before calling. USe the SetFilename() call to pick the output file before starting.\nAudioOutputNull: Just dumps samples to /dev/null. Used for speed testing as it doesn't artificially limit the AudioGenerator output speed since there are no buffers to fill/drain.\nI2S DACs\nI've used both the Adafruit I2S +3W amp DAC and a generic PCM5102 based DAC with success. The biggest problems I've seen from users involve pinouts from the ESP8266 for GPIO and hooking up all necessary pins on the DAC board. The essential pins are:\nI2S pin Common label* ESP8266 pin\nLRC D4 GPIO2\nBCLK D8 GPIO15\nDIN RX GPIO3\n* The \"common label\" column applies to common NodeMCU and D1 Mini development boards. Unfortunately some manufacturers use different mappings so the labels listed here might not apply to your particular model.\nAdafruit I2S DAC\nThis is quite simple and only needs the GND, VIN, LRC, BCLK< and DIN pins to be wired. Be sure to use +5V on the VIN to get the loudest sound. See the Adafruit example page for more info.\nPCM5102 DAC\nI've used several versions of PCM5102 DAC boards purchased from eBay. They've all had the same pinout, no matter the form factor. There are several input configuration pins beyond the I2S interface itself that need to be wired:\n3.3V from ESP8266 -> VCC, 33V, XMT\nGND from ESP8266 -> GND, FLT, DMP, FMT, SCL\n(Standard I2S interface) BCLK->BCK, I2SO->DIN, and LRCLK(WS)->LCK\nOthers\nThere are many other variants out there, and they should all work reasonably well with this code and the ESP8266. Please be certain you've read the datasheet and are applying proper input voltages, and be sure to tie off any unused inputs to GND or VCC as appropriate. LEaving an input pin floating on any integrated circuit can cause unstable operation as it may pick up noise from the environment (very low input capacitance) and cause havoc with internal IC settings.\nSoftware I2S Delta-Sigma DAC (i.e. playing music with a single transistor and speaker)\nFor the best fidelity, and stereo to boot, spend the money on a real I2S DAC. Adafruit makes a great mono one with amplifier, and you can find stereo unamplified ones on eBay or elsewhere quite cheaply. However, thanks to the software delta-sigma DAC with 32x oversampling (up to 128x if the audio rate is low enough) you can still have pretty good sound!\nUse the AudioOutputI2S*No*DAC object instead of the AudioOutputI2S in your code, and the following schematic to drive a 2-3W speaker using a single $0.05 NPN 2N3904 transistor and ~1K resistor:\n2N3904 (NPN)\n+---------+\n| | +-|\n| E B C | / S|\n+-|--|--|-+ | P|\n| | +------+ E|\n| | | A|\nESP8266-GND ------------------+ | +------+ K|\n| | | E|\nESP8266-I2SOUT (Rx) -----/\\/\\/\\--+ | \\ R|\n| +-|\nUSB 5V -----------------------------+\nYou may also want to add a 220uF cap from USB5V to GND just to help filter out any voltage droop during high volume playback.\nIf you don't have a 5V source available on your ESP model, you can use the 5V from your USB serial adapter, or even the 3V from the ESP8266 (but it'll be lower volume). Don't try and drive the speaker without the transistor, the ESP8266 pins can't give enough current to drive even a headphone well and you may end up damaging your device.\nConnections are as a follows:\nESP8266-RX(I2S tx) -- Resistor (~1K ohm, not critical) -- 2N3904 Base\nESP8266-GND -- 2N3904 Emitter\nUSB-5V -- Speaker + Terminal\n2N3904-Collector -- Speaker - Terminal\nNOTE: A prior version of this schematic had a direct connection from the ESP8266 to the base of the transistor. While this does provide the maximum amplitude, it also can draw more current from the 8266 than is safe, and can also cause the transistor to overheat.\nAs of the latest ESP8266Audio release, with the software delta-sigma DAC the LRCLK and BCLK pins can be used by an application. Simply use normal pinMode and dicitalWrite or digitalRead as desired.\nHigh pitched buzzing with the 1-T circuit\nThe 1-T amp can NOT drive any sort of amplified speaker. If there is a power or USB input to the speaker, or it has lights or Bluetooth or a battery, it can NOT be used with this circuit.\nThe 1T output is a binary signal at 0 or 5V, with nothing in between. When you connect to a 8ohm paper physical speaker directly, the speaker cone itself has inertia and acts as a low pass filter and averages the density of pulses in order to give a nice, analog output.\nWhen you feed the 1T output to an amp you are alternatively grounding and overdriving the op-amp's input at a high frequency. That causes ringing and the opamp has a frequency response high enough to amplify the high frequency noise and you get that buzzing.\nThe same problem may happen with piezo speakers. They have a very high frequency response, normally, and have (almost) no inertia. So you hear the buzzing at high frequency.\nYou could attach the 1T output to a low pass and feed that into an amplifier. But at that point it is easier to just get an I2S DAC and avoid the whole thing (plus get stereo and true 16-bit output).\nDebugging the 1-T amp circuit, compliments of @msmcmickey\nIf you've built the amp but are not getting any sound, @msmcmickey wrote up a very good debugging sequence to check:\nPlease double-check the wiring. GPIO pins and board pins are not always the same and vary immensely between brands of ESP8266 carrier boards.\nIs the transistor connected properly? Check the datasheet for this package style and make sure you have the leads connected properly. This package has three leads, and the lead that is by itself in the middle of the one side is the collector, not the base as you might expect it to be.\nIf connected properly, do you have ~5 volts between the collector and emitter?\nWas the transistor possibly damaged/overheated during soldering, or by connecting it improperly? Out-of-circuit diode check voltage drop test using a multimeter from base->emitter and base->collector should be between .5 and .7 volts. If it's shorted or open or conducting in both directions, then replace it and make sure it's connected properly.\nSPDIF optical output\nThe proper way would be using optical TOSLINK transmitter (i.e. TOTXxxx). For testing, you can try with ~660nm red LED and resistor. Same as your basic Blink project with external LED, just that the LED will blink a bit faster.\n____\nESP Pin -------|____|--------+\n|\n---\nV LED\n---\n|\nGround ---------------------+\nFor ESP8266 with red LED (~1.9Vf drop) you need minimum 150Ohm resistor (12mA max per pin), and output pin is fixed (GPIO3/RX0).On ESP32 it is confgurable with AudioOutputSPDIF(gpio_num).\nUsing external SPI RAM to increase buffer\nA class allows you to use a 23lc1024 SPI RAM from Microchip as input buffer. This chip connects to ESP8266 HSPI port and provides a large buffer to help avoid hiccus in playback of web streams.\nThe current version allows for using the standard hardware CS (GPIO15) or any other pin via software at slightly less performance. The following schematic shows one example:\nNotes for using SD cards and ESP8266Audio on Wemos shields\nI've been told the Wemos SD card shield uses GPIO15 as the SD chip select. This needs to be changed because GPIO15 == I2SBCLK, and is driven even if you're using the NoDAC option. Once you move the CS to another pin and update your program it should work fine.\nPorting to other microcontrollers\nThere's no ESP8266-specific code in the AudioGenerator routines, so porting to other controllers should be relatively easy assuming they have the same endianness as the Xtensa core used. Drop me a line if you're doing this, I may be able to help point you in the right direction.\nThanks\nThanks to the authors of StellaPlayer and libMAD for releasing their code freely, and to the maintainers and contributors to the ESP8266 Arduino port.\nAlso, big thanks to @tueddy for getting the initial ESP32 porting into the tree!\n-Earle F. Philhower, III earlephilhower@yahoo.com", "link": "https://github.com/earlephilhower/ESP8266Audio", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "esp8266audio - supports esp8266 & esp32 & raspberry pi rp2040\narduino library for parsing and decoding mod, wav, mp3, flac, midi, aac, and rttl files and playing them on an i2s dac or even using a software-simulated delta-sigma dac with dynamic 32x-128x oversampling.\nesp8266 is fully supported and most mature, but esp32 is also mostly there with built-in dac as well as external ones.\nfor real-time, autonomous speech synthesis, check out esp8266sam, a library which uses this one and a port of an ancient format-based synthesis program to allow your esp8266 to talk with low memory and no network required.\ndisclaimer\nall this code is released under the gpl, and all of it is to be used at your own risk. if you find any bugs, please let me know via the github issue tracker or drop me an email. the mod and mp3 routines were taken from stellaplayer and libmad respectively. the software i2s delta-sigma 32x oversampling dac was my own creation, and sounds quite good if i do say so myself.\nthe aac decode code is from the helix project and licensed under realnetwork's rspl license. for commercial use you're still going to need the usual aac licensing from via licensing.\non the esp32, aac-sbr is supported (many webradio stations use this to reduce bandwidth even further). the esp8266, however, does not support it due to a lack of onboard ram.\nmidi decoding comes from a highly ported miditones combined with a massively memory-optimized tinysoundfont, see the respective source files for more information.\nopus, ogg, and opusfile are from xiph.org with the xiph license and patent described in src/{opusfile,libggg,libopus}/copying.. note opus decoding currently only works on the esp32 due to the large memory requirements of opusfile. prs to rewrite it to be less memory intensive would be much appreciated.\nneat things people have done with esp8266audio\nif you have a neat use for this library, i'd love to hear about it!\nmy personal use of the esp8266audio library is only to drive a 3d-printed, network-time-setting alarm clock for my kids which can play an mp3 instead of a bell to wake them up, called psychoclock.\nharald sattler has built a neat german word clock with mp3 alarm. detailed discussion on the process and models are included.\nerich heinemann has developed a stomper (instrument for playing samples in real-time during a live stage performance) that you can find more info about here.\ndagnall53 has integrated this into a really neat mqtt based model train controller to add sounds to his set. more info is available here, including stl files for 3d printed components!\njohannesmtc has built a similar project especially for model trains: https://github.com/johannesmtc/esp32_mas\na neat mqtt-driven esp8266 light-and-sound device (alarm? toy? who can say!) was built by @cosmicmac, available at https://github.com/cosmicmac/esparkle\na very interesting \"linear clock\" with a stepper motor, ntp time keeping, and configurable recorded chimes with schematics, 3d printer plans, and source code, is now available https://janderogee.com/projects/linear_clock/linear_clock.htm\nprerequisites\nfirst, make sure you are running the 2.6.3/later or git head version of the arduino libraries for esp8266, or the latest esp32 sdk from espressif.\nyou can use git to pull right from github: see this readme for detailed instructions.\ninstallation\ninstall the library in your ~/arduino/libraries\nmkdir -p ~/arduino/libraries\ncd ~/arduino/libraries\ngit clone https://github.com/earlephilhower/esp8266audio\nwhen in the ide please select the following options on the esp8266:\ntools->lwip variant->v1.4 open source, or v2 higher bandwidth\ntools->cpu frequency->160mhz\nusage\ncreate an audioinputxxx source pointing to your input file, an audiooutputxxx sink as either an i2s, i2s-sw-dac, or as a \"serialwav\" which simply writes a wav file to the serial port which can be dumped to a file on your development system, and an audiogeneratorxxx to actually take that input and decode it and send to the output.\nafter creation, you need to call the audiogeneratorxxx::loop() routine from inside your own main loop() one or more times. this will automatically read as much of the file as needed and fill up the i2s buffers and immediately return. since this is not interrupt driven, if you have large delay()s in your code, you may end up with hiccups in playback. either break large delays into very small ones with calls to audiogenerator::loop(), or reduce the sampling rate to require fewer samples per second.\nexample\nsee the examples directory for some simple examples, but the following snippet can play an mp3 file over the simulated i2s dac:\n#include <arduino.h>\n#include \"audiofilesourcespiffs.h\"\n#include \"audiogeneratormp3.h\"\n#include \"audiooutputi2snodac.h\"\naudiogeneratormp3 *mp3;\naudiofilesourcespiffs *file;\naudiooutputi2snodac *out;\nvoid setup()\n{\nserial.begin(115200);\ndelay(1000);\nspiffs.begin();\nfile = new audiofilesourcespiffs(\"/jamonit.mp3\");\nout = new audiooutputi2snodac();\nmp3 = new audiogeneratormp3();\nmp3->begin(file, out);\n}\nvoid loop()\n{\nif (mp3->isrunning()) {\nif (!mp3->loop()) mp3->stop();\n} else {\nserial.printf(\"mp3 done\\n\");\ndelay(1000);\n}\n}\naudiofilesource classes\naudiofilesource: base class which implements a very simple read-only \"file\" interface. required because it seems everyone has invented their own filesystem on the arduino with their own unique twist. using this wrapper lets that be abstracted and makes the audiogenerator simpler as it only calls these simple functions.\naudiofilesourcespiffs: reads a file from the spiffs filesystem\naudiofilesourceprogmem: reads a file from a progmem array. under unix you can use \"xxd -i file.mp3 > file.h\" to get the basic format, then add \"const\" and \"progmem\" to the generated array and include it in your sketch. see the example .h files for a concrete example.\naudiofilesourcehttpstream: simple implementation of a streaming http reader for shoutcast-type mp3 streaming. not yet resilient, and at 44.1khz 128bit stutters due to cpu limitations, but it works more or less.\naudiofilesourcebuffer - double buffering, useful for http streams\naudiofilesourcebuffer is an input source that simply adds an additional ram buffer of the output of any other audiofilesource. this is particularly useful for web streaming where you need to have 1-2 packets in memory to ensure hiccup-free playback.\ncreate your standard input file source, create the buffer with the original source as its input, and pass this buffer object to the generator.\n...\naudiogeneratormp3 *mp3;\naudiofilesourcehttpstream *file;\naudiofilesourcebuffer *buff;\naudiooutputi2snodac *out;\n...\n// create the http stream normally\nfile = new audiofilesourcehttpstream(\"http://your.url.here/mp3\");\n// create a buffer using that stream\nbuff = new audiofilesourcebuffer(file, 2048);\nout = new audiooutputi2snodac();\nmp3 = new audiogeneratormp3();\n// pass in the *buffer*, not the *http stream* to enable buffering\nmp3->begin(buff, out);\n...\naudiofilesourceid3 - id3 stream parser filter with a user-specified callback\nthis class, which takes as input any other audiofilesource and outputs an audiofilesource suitable for any decoder, automatically parses out id3 tags from mp3 files. you need to specify a callback function, which will be called as tags are decoded and allow you to update your ui state with this information. see the playmp3fromspiffs example for more information.\naudiogenerator classes\naudiogenerator: base class for all file decoders. takes a audiofilesource and an audiooutput object to get the data from and to write decoded samples to. call its loop() function as often as you can to ensure the buffers are always kept full and your music won't skip.\naudiogeneratorwav: reads and plays microsoft wave (.wav) format files of 8 or 16 bits.\naudiogeneratormod: reads and plays amiga modtracker files (.mod). use a 160mhz clock as this requires tons of spiffs reads (which are painfully slow) to get raw instrument sample data for every output sample. see https://modarchive.org for many free mod files.\naudiogeneratormp3: reads and plays mp3 format files (.mp3) using a ported libmad library. use a 160mhz clock to ensure enough compute power to decode 128kbit 44.1khz without hiccups. for complete porting history with the gory details, look at https://github.com/earlephilhower/libmad-8266\naudiogeneratorflac: plays flac files via ported libflac-1.3.2. on the order of 30kb heap and minimal stack required as-is.\naudiogeneratormidi: plays a midi file using a wavetable synthesizer and a soundfont2 wavetable input. theoretically up to 16 simultaneous notes available, but depending on the memory needed for the sf2 structures you may not be able to get that many before hitting oom.\naudiogeneratoraac: requires about 30kb of heap and plays a mono or stereo aac file using the helix fixed-point aac decoder.\naudiogeneratorrtttl: enjoy the pleasures of monophonic, 4-octave ringtones on your esp8266. very low memory and cpu requirements for simple tunes.\naudiooutput classes\naudiooutput: base class for all output drivers. takes a sample at a time and returns true/false if there is buffer space for it. if it returns false, it is the calling object's (audiogenerator's) job to keep the data that didn't fit and try again later.\naudiooutputi2s: interface for any i2s 16-bit dac. sends stereo or mono signals out at whatever frequency set. tested with adafruit's i2sdac and a beyond9032 dac from ebay. tested up to 44.1khz. to use the internal dac on esp32, instantiate this class as audiooutputi2s(0,1), see example playmodfromprogmemtodac and code in audiooutputi2s.cpp for details.\naudiooutputi2snodac: abuses the i2s interface to play music without a dac. turns it into a 32x (or higher) oversampling delta-sigma dac. use the schematic below to drive a speaker or headphone from the i2stx pin (i.e. rx). note that with this interface, depending on the transistor used, you may need to disconnect the rx pin from the driver to perform serial uploads. mono-only output, of course.\naudiooutputspdif (experimental): another way to abuse the i2s peripheral to send out bmc encoded s/pdif bitstream. to interface with s/pdif receiver it needs optical or coaxial transceiver, for which some examples can be found at https://www.epanorama.net/documents/audio/spdif.html. it should work even with the simplest form with red led and current limiting resistor, fed into toslink cable. minimum sample rate supported by is 32khz. due to bmc coding, actual symbol rate on the pin is 4x normal i2s data rate, which drains dma buffers quickly. see more details inside audiooutputspdif.cpp\naudiooutputserialwav: writes a binary wav format with headers to the serial port. if you capture the serial output to a file you can play it back on your development system.\naudiooutputspiffswav: writes a binary wav format with headers to a spiffs filesystem. ensure the fs is mounted and spiffs is started before calling. use the setfilename() call to pick the output file before starting.\naudiooutputnull: just dumps samples to /dev/null. used for speed testing as it doesn't artificially limit the audiogenerator output speed since there are no buffers to fill/drain.\ni2s dacs\ni've used both the adafruit i2s +3w amp dac and a generic pcm5102 based dac with success. the biggest problems i've seen from users involve pinouts from the esp8266 for gpio and hooking up all necessary pins on the dac board. the essential pins are:\ni2s pin common label* esp8266 pin\nlrc d4 gpio2\nbclk d8 gpio15\ndin rx gpio3\n* the \"common label\" column applies to common nodemcu and d1 mini development boards. unfortunately some manufacturers use different mappings so the labels listed here might not apply to your particular model.\nadafruit i2s dac\nthis is quite simple and only needs the gnd, vin, lrc, bclk< and din pins to be wired. be sure to use +5v on the vin to get the loudest sound. see the adafruit example page for more info.\npcm5102 dac\ni've used several versions of pcm5102 dac boards purchased from ebay. they've all had the same pinout, no matter the form factor. there are several input configuration pins beyond the i2s interface itself that need to be wired:\n3.3v from esp8266 -> vcc, 33v, xmt\ngnd from esp8266 -> gnd, flt, dmp, fmt, scl\n(standard i2s interface) bclk->bck, i2so->din, and lrclk(ws)->lck\nothers\nthere are many other variants out there, and they should all work reasonably well with this code and the esp8266. please be certain you've read the datasheet and are applying proper input voltages, and be sure to tie off any unused inputs to gnd or vcc as appropriate. leaving an input pin floating on any integrated circuit can cause unstable operation as it may pick up noise from the environment (very low input capacitance) and cause havoc with internal ic settings.\nsoftware i2s delta-sigma dac (i.e. playing music with a single transistor and speaker)\nfor the best fidelity, and stereo to boot, spend the money on a real i2s dac. adafruit makes a great mono one with amplifier, and you can find stereo unamplified ones on ebay or elsewhere quite cheaply. however, thanks to the software delta-sigma dac with 32x oversampling (up to 128x if the audio rate is low enough) you can still have pretty good sound!\nuse the audiooutputi2s*no*dac object instead of the audiooutputi2s in your code, and the following schematic to drive a 2-3w speaker using a single $0.05 npn 2n3904 transistor and ~1k resistor:\n2n3904 (npn)\n+---------+\n| | +-|\n| e b c | / s|\n+-|--|--|-+ | p|\n| | +------+ e|\n| | | a|\nesp8266-gnd ------------------+ | +------+ k|\n| | | e|\nesp8266-i2sout (rx) -----/\\/\\/\\--+ | \\ r|\n| +-|\nusb 5v -----------------------------+\nyou may also want to add a 220uf cap from usb5v to gnd just to help filter out any voltage droop during high volume playback.\nif you don't have a 5v source available on your esp model, you can use the 5v from your usb serial adapter, or even the 3v from the esp8266 (but it'll be lower volume). don't try and drive the speaker without the transistor, the esp8266 pins can't give enough current to drive even a headphone well and you may end up damaging your device.\nconnections are as a follows:\nesp8266-rx(i2s tx) -- resistor (~1k ohm, not critical) -- 2n3904 base\nesp8266-gnd -- 2n3904 emitter\nusb-5v -- speaker + terminal\n2n3904-collector -- speaker - terminal\nnote: a prior version of this schematic had a direct connection from the esp8266 to the base of the transistor. while this does provide the maximum amplitude, it also can draw more current from the 8266 than is safe, and can also cause the transistor to overheat.\nas of the latest esp8266audio release, with the software delta-sigma dac the lrclk and bclk pins can be used by an application. simply use normal pinmode and dicitalwrite or digitalread as desired.\nhigh pitched buzzing with the 1-t circuit\nthe 1-t amp can not drive any sort of amplified speaker. if there is a power or usb input to the speaker, or it has lights or bluetooth or a battery, it can not be used with this circuit.\nthe 1t output is a binary signal at 0 or 5v, with nothing in between. when you connect to a 8ohm paper physical speaker directly, the speaker cone itself has inertia and acts as a low pass filter and averages the density of pulses in order to give a nice, analog output.\nwhen you feed the 1t output to an amp you are alternatively grounding and overdriving the op-amp's input at a high frequency. that causes ringing and the opamp has a frequency response high enough to amplify the high frequency noise and you get that buzzing.\nthe same problem may happen with piezo speakers. they have a very high frequency response, normally, and have (almost) no inertia. so you hear the buzzing at high frequency.\nyou could attach the 1t output to a low pass and feed that into an amplifier. but at that point it is easier to just get an i2s dac and avoid the whole thing (plus get stereo and true 16-bit output).\ndebugging the 1-t amp circuit, compliments of @msmcmickey\nif you've built the amp but are not getting any sound, @msmcmickey wrote up a very good debugging sequence to check:\nplease double-check the wiring. gpio pins and board pins are not always the same and vary immensely between brands of esp8266 carrier boards.\nis the transistor connected properly? check the datasheet for this package style and make sure you have the leads connected properly. this package has three leads, and the lead that is by itself in the middle of the one side is the collector, not the base as you might expect it to be.\nif connected properly, do you have ~5 volts between the collector and emitter?\nwas the transistor possibly damaged/overheated during soldering, or by connecting it improperly? out-of-circuit diode check voltage drop test using a multimeter from base->emitter and base->collector should be between .5 and .7 volts. if it's shorted or open or conducting in both directions, then replace it and make sure it's connected properly.\nspdif optical output\nthe proper way would be using optical toslink transmitter (i.e. totxxxx). for testing, you can try with ~660nm red led and resistor. same as your basic blink project with external led, just that the led will blink a bit faster.\n____\nesp pin -------|____|--------+\n|\n---\nv led\n---\n|\nground ---------------------+\nfor esp8266 with red led (~1.9vf drop) you need minimum 150ohm resistor (12ma max per pin), and output pin is fixed (gpio3/rx0).on esp32 it is confgurable with audiooutputspdif(gpio_num).\nusing external spi ram to increase buffer\na class allows you to use a 23lc1024 spi ram from microchip as input buffer. this chip connects to esp8266 hspi port and provides a large buffer to help avoid hiccus in playback of web streams.\nthe current version allows for using the standard hardware cs (gpio15) or any other pin via software at slightly less performance. the following schematic shows one example:\nnotes for using sd cards and esp8266audio on wemos shields\ni've been told the wemos sd card shield uses gpio15 as the sd chip select. this needs to be changed because gpio15 == i2sbclk, and is driven even if you're using the nodac option. once you move the cs to another pin and update your program it should work fine.\nporting to other microcontrollers\nthere's no esp8266-specific code in the audiogenerator routines, so porting to other controllers should be relatively easy assuming they have the same endianness as the xtensa core used. drop me a line if you're doing this, i may be able to help point you in the right direction.\nthanks\nthanks to the authors of stellaplayer and libmad for releasing their code freely, and to the maintainers and contributors to the esp8266 arduino port.\nalso, big thanks to @tueddy for getting the initial esp32 porting into the -----> tree !!! !\n-earle f. philhower, iii earlephilhower@yahoo.com", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000034, "year": null}, {"Unnamed: 0": 2128, "autor": 88, "date": null, "content": "Bare Arduino Project\n\u26a0\ufe0f For mbed projects, see Bare mbed Project.\nTable of Contents generated with DocToc\nAbout\nWhat you get\nHow to install and use\nBugs\nText editors\nSublime Text - SublimeClang\nVim - YouCompleteMe\nBonus - .editorconfig\nContributing\nCopyright and License\nAbout\nEver wanted to start a new Arduino project and...\nnot use the terrible Arduino IDE?\nuse your favorite text editor instead?\nhave decent code completion and syntax checking?\norganize your directory tree as you like?\nlibraries in lib\nsources in src\ntests in test\nbinaries in bin\netc.\nuse a newer version of avr-gcc such as 9.x.x?\nuse an awesome Makefile to compile and upload your code from the cli?\nIf you answered yes to one of the above, this Bare Arduino Project is just what you're looking for! :)\nWhat you get\nBased on what we've learned from our Moti project, this repo will allow you to:\nmove away from the Arduino IDE and use your favorite text editor such as Vim or SublimeText\nget up and running in less time\nuse the latest version of avr-gcc 9.x.x to compile your code\nuse C++17 for your standard coding\nuse make to compile, make upload to upload, thanks to Sudar's incredible project Arduino-Makefile\nTo put it in a nutshell, it allows you to write Arduino code the way you've always wanted!\nHow to install and use\nThe full procedure is detailed in INSTALL.md.\nBugs\n\u26a0\ufe0f If you encounter some issues while using the Bare-Arduino-Project, please first report the issue here in this repo issue tracker and not in Arduino-Makefile.\nIt will allow us to investigate first and not overflow the Arduino-Makefile issue tracker.\nText editors\nBecause we are so awesome, we also provide your with 2 famous text editors configurations!\nSublime Text - SublimeClang\n\u26a0\ufe0f Note: I haven't used SublimeText for developping in C/C++ for years, so the following might not work as expected.\nTo code in C/C++, we highly recommend using SublimeClang, even if the plugin is not maintained anymore (this fork seems to be up-to-date). As far as we can tell, it works beautifully well and will save you a lot of time! :)\nAs quarnster puts it:\nClang plugin for Sublime Text 2 providing auto complete suggestions for C/C++/ObjC/ObjC++. It'll also optionally parse the code as it's typed and show errors and warnings.\nThe bare-arduino.sublime-project contains all you need to be up and running. Feel free to customize it to your needs with different flags for example.\nVim - YouCompleteMe\nVim is our default text editor and we use the incredible vim plugin YouCompleteMe for syntax checking and code completion.\nAs Valloric puts it:\nYouCompleteMe is a fast, as-you-type, fuzzy-search code completion engine for Vim. It has several completion engines: an identifier-based engine that works with every programming language, a semantic, Clang-based engine that provides native semantic code completion for C/C++/Objective-C/Objective-C++ (from now on referred to as \"the C-family languages\"), a Jedi-based completion engine for Python, an OmniSharp-based completion engine for C# and an omnifunc-based completer that uses data from Vim's omnicomplete system to provide semantic completions for many other languages (Ruby, PHP etc.).\nThe .ycm_extra_conf.py file contains everything you need. It should work right out of the box on macOS and need very little modification on Linux!\nBonus - .editorconfig\nTo make sure everything is always formatted as you like, you can customize the .editorconfig file to suit your needs.\nPlease refer to the official Editorconfig documentation for more details and to download the plugins needed.\nContributing\nHelp is always more than welcome. If you want to take part in this project, please, make sure you read our Contributing guidelines.\nCopyright and License\nThe MIT License (MIT)\nCopyright (c) 2014 Ladislas de Toldi - ladislas at leka dot io\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", "link": "https://github.com/ladislas/Bare-Arduino-Project", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "bare arduino project\n\u26a0\ufe0f for mbed projects, see bare mbed project.\ntable of contents generated with doctoc\nabout\nwhat you get\nhow to install and use\nbugs\ntext editors\nsublime text - sublimeclang\nvim - youcompleteme\nbonus - .editorconfig\ncontributing\ncopyright and license\nabout\never wanted to start a new arduino project and...\nnot use the terrible arduino ide?\nuse your favorite text editor instead?\nhave decent code completion and syntax checking?\norganize your directory -----> tree !!!  as you like?\nlibraries in lib\nsources in src\ntests in test\nbinaries in bin\netc.\nuse a newer version of avr-gcc such as 9.x.x?\nuse an awesome makefile to compile and upload your code from the cli?\nif you answered yes to one of the above, this bare arduino project is just what you're looking for! :)\nwhat you get\nbased on what we've learned from our moti project, this repo will allow you to:\nmove away from the arduino ide and use your favorite text editor such as vim or sublimetext\nget up and running in less time\nuse the latest version of avr-gcc 9.x.x to compile your code\nuse c++17 for your standard coding\nuse make to compile, make upload to upload, thanks to sudar's incredible project arduino-makefile\nto put it in a nutshell, it allows you to write arduino code the way you've always wanted!\nhow to install and use\nthe full procedure is detailed in install.md.\nbugs\n\u26a0\ufe0f if you encounter some issues while using the bare-arduino-project, please first report the issue here in this repo issue tracker and not in arduino-makefile.\nit will allow us to investigate first and not overflow the arduino-makefile issue tracker.\ntext editors\nbecause we are so awesome, we also provide your with 2 famous text editors configurations!\nsublime text - sublimeclang\n\u26a0\ufe0f note: i haven't used sublimetext for developping in c/c++ for years, so the following might not work as expected.\nto code in c/c++, we highly recommend using sublimeclang, even if the plugin is not maintained anymore (this fork seems to be up-to-date). as far as we can tell, it works beautifully well and will save you a lot of time! :)\nas quarnster puts it:\nclang plugin for sublime text 2 providing auto complete suggestions for c/c++/objc/objc++. it'll also optionally parse the code as it's typed and show errors and warnings.\nthe bare-arduino.sublime-project contains all you need to be up and running. feel free to customize it to your needs with different flags for example.\nvim - youcompleteme\nvim is our default text editor and we use the incredible vim plugin youcompleteme for syntax checking and code completion.\nas valloric puts it:\nyoucompleteme is a fast, as-you-type, fuzzy-search code completion engine for vim. it has several completion engines: an identifier-based engine that works with every programming language, a semantic, clang-based engine that provides native semantic code completion for c/c++/objective-c/objective-c++ (from now on referred to as \"the c-family languages\"), a jedi-based completion engine for python, an omnisharp-based completion engine for c# and an omnifunc-based completer that uses data from vim's omnicomplete system to provide semantic completions for many other languages (ruby, php etc.).\nthe .ycm_extra_conf.py file contains everything you need. it should work right out of the box on macos and need very little modification on linux!\nbonus - .editorconfig\nto make sure everything is always formatted as you like, you can customize the .editorconfig file to suit your needs.\nplease refer to the official editorconfig documentation for more details and to download the plugins needed.\ncontributing\nhelp is always more than welcome. if you want to take part in this project, please, make sure you read our contributing guidelines.\ncopyright and license\nthe mit license (mit)\ncopyright (c) 2014 ladislas de toldi - ladislas at leka dot io\npermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"software\"), to deal\nin the software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the software, and to permit persons to whom the software is\nfurnished to do so, subject to the following conditions:\nthe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the software.\nthe software is provided \"as is\", without warranty of any kind, express or\nimplied, including but not limited to the warranties of merchantability,\nfitness for a particular purpose and noninfringement. in no event shall the\nauthors or copyright holders be liable for any claim, damages or other\nliability, whether in an action of contract, tort or otherwise, arising from,\nout of or in connection with the software or the use or other dealings in the\nsoftware.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000088, "year": null}, {"Unnamed: 0": 2244, "autor": 204, "date": null, "content": "OneWireHub\nThe OneWireHub is a sleek Arduino compatible (and many more platforms) library to emulate OneWire-Slaves with support for various devices. The motivation is to offer a shared code base for all OneWire-Slaves. With a small overhead one \u00b5C can emulate up to 32 ICs simultaneously. The main goal is to use modern sensors (mainly I2C or SPI interface) and transfer their measurements into one or more emulated ds2438 which have 4x16bit registers for values. This feature removes the limitations of modern house-automation-systems. Add humidity, light and other sensors easy to your home automation environment.\nImplemented Slaves:\nBAE0910 (0xFC) multi purpose device (ADC, Clock, GPIO, PWM, EEPROM)\nDS1822 (0x22) Digital Thermometer, 12bit -> use DS18B20 with different family code\nDS18B20 (0x28) Digital Thermometer, 12bit (also known as DS1820)\nDS18S20 (0x10) Digital Thermometer, 9bit (also known as DS1920, use DS18B20 with different family code)\nDS1990 (0x01) iButton (DS2401 with same family code)\nDS1990A (0x81) iButton (DS2401 with different family code)\nDS2401 (0x01) Serial Number\nDS2405 (0x05) Single address switch\nDS2408 (0x29) 8-Channel Addressable Switch, GPIO Port-expander\nDS2411 (0x01) Serial Number -> use DS2401 with same family code\nDS2413 (0x3A) Dual channel addressable switch with input-sensing\nDS2423 (0x1D) 4kbit RAM with Counter\nDS2431 (0x2D) 1kbit protected EEPROM (also known as DS1972 or DS28E07, same FC)\nDS2432 (0x33) 1kbit protected EEPROM (basically a ds2431 with extra sha-engine)\nDS2433 (0x23) 4Kbit EEPROM (also known as DS1973)\nDS2438 (0x26) Smart Battery Monitor, measures temperature, 2x voltage and current, 10bit\nDS2450 (0x20) 4 channel A/D\nDS2501 (0x11, 0x91) 512bit EEPROM -> use DS2502 with different family code\nDS2502 (0x09, 0x89) 1kbit EEPROM, Add Only Memory (also known as DS1982, same FC)\nDS2503 (0x13) 4kbit EEPROM, Add Only Memory (also known as DS1983, same FC) -> use DS2506 with different family code\nDS2505 (0x0B) 16kbit EEPROM, Add Only Memory (also known as DS1985, same FC) -> use DS2506 with different family code\nDS2506 (0x0F) 64kbit EEPROM, Add Only Memory (also known as DS1986, same FC)\nDS2890 (0x2C) Single channel digital potentiometer - extended to 1-4 CH\nDellAC (0x28) Dell Power Supply (use DS2502 with different family code)\nNote: Bold printed devices are feature-complete and were mostly tested with a DS9490 (look into the regarding example-file for more information) and a loxone system (when supported).\nFeatures:\nsupports up to 32 slaves simultaneously (8 is standard setting), adjust HUB_SLAVE_LIMIT in src/OneWireHub_config.h to safe RAM & program space\nimplementation-overhead for the hub is minimal and even saves resources for >1 emulated device\nhot-plug: add and remove slaves as needed during operation\nsupport for most onewire-features: MATCH ROM (0x55), SKIP ROM (0xCC), READ ROM (0x0F,0x33), RESUME COMMAND (0xA5)\nOVERDRIVE-Mode: Master can issue OD SKIP ROM (0x13) or OD MATCH ROM (0x69) and slave stays in this mode till it sees a long reset -> OD-feature must be activated in config\nALARM SEARCH (0xEC) is NOT implemented yet!\ncleaner, faster code with c++11 features (requires arduino sw 1.6.x or higher, >=1.6.10 recommended)\nuse of constexpr instead of #define for better compiler-messages and cleaner code\nuse static-assertions for plausibility checks\nuser defined literals convert constants into needed format / unit\nhardware-dependencies are combined in \"platform.h\", synced with Onewire-Lib\nsupported: arduino zero, teensy, pic32, ATtiny, esp8266, esp32, raspberry (...)\ntested architectures: atmega328 @ 16 MHz / arduino Uno, teensy3.2\nfor portability and tests the hub can be compiled on a PC with the supplied mock-up functions in platform.h\nat the moment the lib relies sole on loop-counting for timing, no direct access to interrupt or timers, NOTE: if you use an uncalibrated architecture the compilation-process will fail with an error, look at ./examples/debug/calibrate_by_bus_timing for an explanation\nhub and slaves are unit tested and run for each supported architecture through travis CI\nSerial-Debug output can be enabled in src/OneWireHub_config.h: set USE_SERIAL_DEBUG to 1 (be aware! it may produce heisenbugs, timing is critical)\nGPIO-Debug output - shows status by issuing high-states (activate in src/OneWireHub_config.h, is a better alternative to serial debug)\nduring presence detection (after reset),\nafter receiving / sending a whole byte (not during SEARCH ROM)\nwhen duty()-subroutines of an attached slave get called\nduring hub-startup it issues a 1ms long high-state (you can check the instruction-per-loop-value for your architecture with this)\nprovide documentation, numerous examples, easy interface for hub and sensors\nSupported and tested Hardware\nembedded real life test\nsetup: run test-example, use ds9490-master, arduino 1.8.3, Windows 10 and the board-library named in the brackets\nArduino Uno (Arduino AVR Boards)\nTeensy 3.2 (teensyduino)\nWemos D1 Mini ESP32S (esp32)\nWemos Wifi & BT ESP32 (esp32)\nWemos D1 R2 (esp8266)\nnodeMCU 1.0 ESP-12E (esp8266)\nATtiny 84, 88 (attiny)\nTravis CI (automated Continuous Integration) for different platforms\nArduino Uno (Arduino AVR Boards)\nTeensy 3.0, 3.1, 3.2, LC, 3.5, 3.6 (teensyduino)\ngeneric ESP8266 (esp8266)\nnodeMCU V2 (esp8266)\nespduino (esp8266)\nESP32 dev module (esp32)\nDigispark tiny (DigistumpArduino)\nfailing platforms\nreason: current tick-counting implementation is not compatible with variable clock-speed\nArduino Due (Arduino SAMD Boards (32-bits ARM Cortex-M3))\nArduino MKRZero (Arduino SAMD Boards (32-bits ARM Cortex-M0+))\nreason: gcc 4.8.3 is artificially limited to c++98\nArduino Primo (Arduino nRF52 Boards)\nRedBear nRF51\nreason: value_ipl is unknown for this hardware\nArduino 101 (Intel Curie Boards)\nHow does the Hub work\nthis layered description gives you a basic idea of how the functions inside the hub work together\nthis will not tell you how the onewire protocol works - read a device datasheet or the link for that\nLow Level - hardware access\nmacros like DIRECT_READ() and DIRECT_WRITE() handle bus-access (platform.h)\ncheckReset() and showPresence() are used to react to a beginning OW-Message\nsendBit(), recvBit() manage the information inside each timeslot issued by the master\nMid Level - onewire protocol logic\nsend() and recv() can process data between device and master on byte-level (and do a CRC if needed)\nrecvAndProcessCmd() handles basic commands of the master like: search-rom, match-rom, skip-rom, read-rom\nHigh Level - user interaction\nattach() adds an instance of a ow-device to the hub so the master can find it on the bus. there is a lot to do here. the device ID must be integrated into the tree-structure so that the hub knows how to react during a search-rom-command\ndetach() takes the selected emulated device offline and restructures the search-tree\npoll() lets the hub listen to the bus. If there is a reset within a given time-frame it will continue to handle the message (show presence and receive commands), otherwise it will exit and you can do other stuff. the user should call this function as often as possible to intercept every message and therefore stay visible on the bus\nSlave Level:\nslave.duty() gets automatically called when the master sends special commands (for example match-rom). now it is possible to handle device specific commands like \"read memory\" or \"do temperature measurement\". These commands deviate for each device.\nslave.setTemperature() and slave.writeMemory() for example are individual functions that handle core-functionality of the device and can be called by the user\nfor further details try reading the header-files or check the examples\nHELP - What to do if things don't work as expected?\ncheck if your arduino software up to date (>v1.8.0)\nupdate this lib to the latest release (v2.2.0)\nif you use an uncalibrated architecture the compilation-process will fail with an error, look at ./examples/debug/calibrate_by_bus_timing for an explanation\ncheck if clock-speed of the \u00b5C is set correctly (if possible) - test with simple blink example, 1sec ON should really need 1sec. timing is critical\nbegin with a simple example like the ds18b20 (if possible). the ds18b20 doesn't support overdrive, so the master won't switch to higher data rates\ncheck if your setup is right: you need at least external power for your \u00b5C and a data line with ground line to your onewire-master (see section below)\nis there more than one master on the bus? It won't work!\nhas any other sensor (real or emulated) ever worked with this master? -> the simplest device would be a ds2401\nif communication works, but is unstable please check with logic analyzer\nmaybe your master is slow and just needs a higher ONEWIRE_TIME_MSG_HIGH_TIMEOUT-value (see OneWireHub_config.h line 37)\nmake sure that serial- and gpio-debugging is disabled (see src/OneWireHub_config.h), especially when using overdrive (be aware! it may produce heisenbugs, timing is critical)\non a slow arduino it can be helpful to disable the serial port completely to get reliable results -> at least comment out serial.begin()\nif you can provide a recording via logic-analyzer (logic 8 or similar) there should be chance we can help you\nadditional gpio-debug output can be enabled in src/OneWireHub_config.h: set USE_GPIO_DEBUG to 1 (it helps tracking state changes of the hub)\nif you checked all these points feel free to open an issue at Github and describe your troubleshooting process\nplease provide the following basic info: which \u00b5C and master do you use, software versions, what device do you try to emulate, what works, what doesn't\nRecent development (latest at the top):\ntravis CI and unittests\nmore explicit coding, a lot of bugfixes with the help of unit tests (mainly esp8266, bea910, ds18b20)\ninterface of hub and slave-devices has changed, check header-file or examples for more info\nrework / clean handling of timing-constants with user defined literals.\nextend const-correctness to all onewire-slaves and unify naming of functions across similar devices\ninclude tests into each device-example and add a lot of get()/set() for internal device-states\nfull support for ds2423, ds2450 and ds2503/5/6\nfix and enhance ds2431, ds2433, ds2502, ds2890, probably every slave got a rework / optimization\noverdrive-support! must be enabled in config file - works with atmega328@16MHz\nrework send() and recv(), much more efficient -> less time without interupts (no missing time with millis())! AND code is more compact (ds2433.cpp shrinks from 176 to 90 LOC)\nrework Error-Handling-System (reduced a lot of overhead)\nno return value for hub.searchIDTree() or item.duty() needed anymore\nreturns 1 if error occured in the following functions: recv(buf[]), send(), awaitTimeslot(), sendBit(), checkReset(), showPresence(), recvAndProzessCmd()\nsupport for ds2408 (thanks to vytautassurvila) and ds2450\noffline calibration by watching the bus (examples/debug/calibrate_by_bus_timing)\nbranch for online calibration was abandoned because it took to much resources (DS18B20-Sketch compiled to 8434 // 482 bytes instead of 7026 // 426 bytes now)\ncleaned up timing-fn (no guessing, no micros(), no delayMicroseconds())\ndebug-pin shows state by issuing high-states - see explanation in \"features\"\nteensy3.2 tested: cleaned warnings, fixed port access, cleaned examples\nadded or extended the ds2431, ds2431, ds2501, ds2502 (also tested)\nadded ds2431 (thanks to j-langlois) and BAE910 (thanks to Giermann), Dell Power Supply (thanks to Kondi)\nprepare new timing-method which will replace the old one in the next couple of weeks (a 6\u00b5s millis() call at 8MHz is not suitable for OW)\nsupport for skipROM-cmd if only one slave is present (thanks to Giermann)\nspeed up atmel-crc-functions\nrework of error system, switch to enum, slaves can raise errors now & and Serial interferes less with OW-timings\nraise the maximal slave limit from 8 to 32, code adapts via variable dataTypes\nper-bit-CRC16 with sendAndCRC16() and sendAndCRC16() for load-balancing, 900ns/bit instead of 7\u00b5s/byte on Atmega328@16MHz\nfaster CRC16 (ds2450 and ds2408 and ds2423), takes 5-7\u00b5s/byte instead of 10\u00b5s\nreplace searchIDTree() algorithm, safes a lot of ram (debug-codeSize-4slaves.ino needs 3986 & 155 byte instead of 3928 & 891 byte) and allows >4 devices\nPlans for the future:\nalarm / conditional search\nswitch to delay() for fast enough controllers (instead of tick-counting)\ndebug tool to determine timings of exotic masters\nbetter interrupt-handling (save the state before disabling)\nirq-handled hub on supported ports, split lib into onewire() and onewireIRQ()\ntest each example with real onewire-masters, for now it's tested with the onewire-lib and a loxone-system (ds18b20 passed)\nList of all Family-Codes\nList of Maxim Sensors (at the bottom)\nConnecting the HUB with the Network:\nread more\nParasite Power with two wires\nNote: this will certainly not work with an emulated device. Powering a \u00b5Controller via GPIO is sometimes possible, but needs preparation and tests.\nread more\nAncestors of this Lib:\noriginal pieces seem to be adopted from OneWireSlave\nfurther development was done in OneWireSlave from MarkusLange and OneWire\nfirst implementation of the OneWireHub by Shagrat2\nthe current code has just the concepts in common, but the codebase is a total rewrite", "link": "https://github.com/orgua/OneWireHub", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "onewirehub\nthe onewirehub is a sleek arduino compatible (and many more platforms) library to emulate onewire-slaves with support for various devices. the motivation is to offer a shared code base for all onewire-slaves. with a small overhead one \u00b5c can emulate up to 32 ics simultaneously. the main goal is to use modern sensors (mainly i2c or spi interface) and transfer their measurements into one or more emulated ds2438 which have 4x16bit registers for values. this feature removes the limitations of modern house-automation-systems. add humidity, light and other sensors easy to your home automation environment.\nimplemented slaves:\nbae0910 (0xfc) multi purpose device (adc, clock, gpio, pwm, eeprom)\nds1822 (0x22) digital thermometer, 12bit -> use ds18b20 with different family code\nds18b20 (0x28) digital thermometer, 12bit (also known as ds1820)\nds18s20 (0x10) digital thermometer, 9bit (also known as ds1920, use ds18b20 with different family code)\nds1990 (0x01) ibutton (ds2401 with same family code)\nds1990a (0x81) ibutton (ds2401 with different family code)\nds2401 (0x01) serial number\nds2405 (0x05) single address switch\nds2408 (0x29) 8-channel addressable switch, gpio port-expander\nds2411 (0x01) serial number -> use ds2401 with same family code\nds2413 (0x3a) dual channel addressable switch with input-sensing\nds2423 (0x1d) 4kbit ram with counter\nds2431 (0x2d) 1kbit protected eeprom (also known as ds1972 or ds28e07, same fc)\nds2432 (0x33) 1kbit protected eeprom (basically a ds2431 with extra sha-engine)\nds2433 (0x23) 4kbit eeprom (also known as ds1973)\nds2438 (0x26) smart battery monitor, measures temperature, 2x voltage and current, 10bit\nds2450 (0x20) 4 channel a/d\nds2501 (0x11, 0x91) 512bit eeprom -> use ds2502 with different family code\nds2502 (0x09, 0x89) 1kbit eeprom, add only memory (also known as ds1982, same fc)\nds2503 (0x13) 4kbit eeprom, add only memory (also known as ds1983, same fc) -> use ds2506 with different family code\nds2505 (0x0b) 16kbit eeprom, add only memory (also known as ds1985, same fc) -> use ds2506 with different family code\nds2506 (0x0f) 64kbit eeprom, add only memory (also known as ds1986, same fc)\nds2890 (0x2c) single channel digital potentiometer - extended to 1-4 ch\ndellac (0x28) dell power supply (use ds2502 with different family code)\nnote: bold printed devices are feature-complete and were mostly tested with a ds9490 (look into the regarding example-file for more information) and a loxone system (when supported).\nfeatures:\nsupports up to 32 slaves simultaneously (8 is standard setting), adjust hub_slave_limit in src/onewirehub_config.h to safe ram & program space\nimplementation-overhead for the hub is minimal and even saves resources for >1 emulated device\nhot-plug: add and remove slaves as needed during operation\nsupport for most onewire-features: match rom (0x55), skip rom (0xcc), read rom (0x0f,0x33), resume command (0xa5)\noverdrive-mode: master can issue od skip rom (0x13) or od match rom (0x69) and slave stays in this mode till it sees a long reset -> od-feature must be activated in config\nalarm search (0xec) is not implemented yet!\ncleaner, faster code with c++11 features (requires arduino sw 1.6.x or higher, >=1.6.10 recommended)\nuse of constexpr instead of #define for better compiler-messages and cleaner code\nuse static-assertions for plausibility checks\nuser defined literals convert constants into needed format / unit\nhardware-dependencies are combined in \"platform.h\", synced with onewire-lib\nsupported: arduino zero, teensy, pic32, attiny, esp8266, esp32, raspberry (...)\ntested architectures: atmega328 @ 16 mhz / arduino uno, teensy3.2\nfor portability and tests the hub can be compiled on a pc with the supplied mock-up functions in platform.h\nat the moment the lib relies sole on loop-counting for timing, no direct access to interrupt or timers, note: if you use an uncalibrated architecture the compilation-process will fail with an error, look at ./examples/debug/calibrate_by_bus_timing for an explanation\nhub and slaves are unit tested and run for each supported architecture through travis ci\nserial-debug output can be enabled in src/onewirehub_config.h: set use_serial_debug to 1 (be aware! it may produce heisenbugs, timing is critical)\ngpio-debug output - shows status by issuing high-states (activate in src/onewirehub_config.h, is a better alternative to serial debug)\nduring presence detection (after reset),\nafter receiving / sending a whole byte (not during search rom)\nwhen duty()-subroutines of an attached slave get called\nduring hub-startup it issues a 1ms long high-state (you can check the instruction-per-loop-value for your architecture with this)\nprovide documentation, numerous examples, easy interface for hub and sensors\nsupported and tested hardware\nembedded real life test\nsetup: run test-example, use ds9490-master, arduino 1.8.3, windows 10 and the board-library named in the brackets\narduino uno (arduino avr boards)\nteensy 3.2 (teensyduino)\nwemos d1 mini esp32s (esp32)\nwemos wifi & bt esp32 (esp32)\nwemos d1 r2 (esp8266)\nnodemcu 1.0 esp-12e (esp8266)\nattiny 84, 88 (attiny)\ntravis ci (automated continuous integration) for different platforms\narduino uno (arduino avr boards)\nteensy 3.0, 3.1, 3.2, lc, 3.5, 3.6 (teensyduino)\ngeneric esp8266 (esp8266)\nnodemcu v2 (esp8266)\nespduino (esp8266)\nesp32 dev module (esp32)\ndigispark tiny (digistumparduino)\nfailing platforms\nreason: current tick-counting implementation is not compatible with variable clock-speed\narduino due (arduino samd boards (32-bits arm cortex-m3))\narduino mkrzero (arduino samd boards (32-bits arm cortex-m0+))\nreason: gcc 4.8.3 is artificially limited to c++98\narduino primo (arduino nrf52 boards)\nredbear nrf51\nreason: value_ipl is unknown for this hardware\narduino 101 (intel curie boards)\nhow does the hub work\nthis layered description gives you a basic idea of how the functions inside the hub work together\nthis will not tell you how the onewire protocol works - read a device datasheet or the link for that\nlow level - hardware access\nmacros like direct_read() and direct_write() handle bus-access (platform.h)\ncheckreset() and showpresence() are used to react to a beginning ow-message\nsendbit(), recvbit() manage the information inside each timeslot issued by the master\nmid level - onewire protocol logic\nsend() and recv() can process data between device and master on byte-level (and do a crc if needed)\nrecvandprocesscmd() handles basic commands of the master like: search-rom, match-rom, skip-rom, read-rom\nhigh level - user interaction\nattach() adds an instance of a ow-device to the hub so the master can find it on the bus. there is a lot to do here. the device id must be integrated into the -----> tree !!! -structure so that the hub knows how to react during a search-rom-command\ndetach() takes the selected emulated device offline and restructures the search------> tree !!! \npoll() lets the hub listen to the bus. if there is a reset within a given time-frame it will continue to handle the message (show presence and receive commands), otherwise it will exit and you can do other stuff. the user should call this function as often as possible to intercept every message and therefore stay visible on the bus\nslave level:\nslave.duty() gets automatically called when the master sends special commands (for example match-rom). now it is possible to handle device specific commands like \"read memory\" or \"do temperature measurement\". these commands deviate for each device.\nslave.settemperature() and slave.writememory() for example are individual functions that handle core-functionality of the device and can be called by the user\nfor further details try reading the header-files or check the examples\nhelp - what to do if things don't work as expected?\ncheck if your arduino software up to date (>v1.8.0)\nupdate this lib to the latest release (v2.2.0)\nif you use an uncalibrated architecture the compilation-process will fail with an error, look at ./examples/debug/calibrate_by_bus_timing for an explanation\ncheck if clock-speed of the \u00b5c is set correctly (if possible) - test with simple blink example, 1sec on should really need 1sec. timing is critical\nbegin with a simple example like the ds18b20 (if possible). the ds18b20 doesn't support overdrive, so the master won't switch to higher data rates\ncheck if your setup is right: you need at least external power for your \u00b5c and a data line with ground line to your onewire-master (see section below)\nis there more than one master on the bus? it won't work!\nhas any other sensor (real or emulated) ever worked with this master? -> the simplest device would be a ds2401\nif communication works, but is unstable please check with logic analyzer\nmaybe your master is slow and just needs a higher onewire_time_msg_high_timeout-value (see onewirehub_config.h line 37)\nmake sure that serial- and gpio-debugging is disabled (see src/onewirehub_config.h), especially when using overdrive (be aware! it may produce heisenbugs, timing is critical)\non a slow arduino it can be helpful to disable the serial port completely to get reliable results -> at least comment out serial.begin()\nif you can provide a recording via logic-analyzer (logic 8 or similar) there should be chance we can help you\nadditional gpio-debug output can be enabled in src/onewirehub_config.h: set use_gpio_debug to 1 (it helps tracking state changes of the hub)\nif you checked all these points feel free to open an issue at github and describe your troubleshooting process\nplease provide the following basic info: which \u00b5c and master do you use, software versions, what device do you try to emulate, what works, what doesn't\nrecent development (latest at the top):\ntravis ci and unittests\nmore explicit coding, a lot of bugfixes with the help of unit tests (mainly esp8266, bea910, ds18b20)\ninterface of hub and slave-devices has changed, check header-file or examples for more info\nrework / clean handling of timing-constants with user defined literals.\nextend const-correctness to all onewire-slaves and unify naming of functions across similar devices\ninclude tests into each device-example and add a lot of get()/set() for internal device-states\nfull support for ds2423, ds2450 and ds2503/5/6\nfix and enhance ds2431, ds2433, ds2502, ds2890, probably every slave got a rework / optimization\noverdrive-support! must be enabled in config file - works with atmega328@16mhz\nrework send() and recv(), much more efficient -> less time without interupts (no missing time with millis())! and code is more compact (ds2433.cpp shrinks from 176 to 90 loc)\nrework error-handling-system (reduced a lot of overhead)\nno return value for hub.searchidtree() or item.duty() needed anymore\nreturns 1 if error occured in the following functions: recv(buf[]), send(), awaittimeslot(), sendbit(), checkreset(), showpresence(), recvandprozesscmd()\nsupport for ds2408 (thanks to vytautassurvila) and ds2450\noffline calibration by watching the bus (examples/debug/calibrate_by_bus_timing)\nbranch for online calibration was abandoned because it took to much resources (ds18b20-sketch compiled to 8434 // 482 bytes instead of 7026 // 426 bytes now)\ncleaned up timing-fn (no guessing, no micros(), no delaymicroseconds())\ndebug-pin shows state by issuing high-states - see explanation in \"features\"\nteensy3.2 tested: cleaned warnings, fixed port access, cleaned examples\nadded or extended the ds2431, ds2431, ds2501, ds2502 (also tested)\nadded ds2431 (thanks to j-langlois) and bae910 (thanks to giermann), dell power supply (thanks to kondi)\nprepare new timing-method which will replace the old one in the next couple of weeks (a 6\u00b5s millis() call at 8mhz is not suitable for ow)\nsupport for skiprom-cmd if only one slave is present (thanks to giermann)\nspeed up atmel-crc-functions\nrework of error system, switch to enum, slaves can raise errors now & and serial interferes less with ow-timings\nraise the maximal slave limit from 8 to 32, code adapts via variable datatypes\nper-bit-crc16 with sendandcrc16() and sendandcrc16() for load-balancing, 900ns/bit instead of 7\u00b5s/byte on atmega328@16mhz\nfaster crc16 (ds2450 and ds2408 and ds2423), takes 5-7\u00b5s/byte instead of 10\u00b5s\nreplace searchidtree() algorithm, safes a lot of ram (debug-codesize-4slaves.ino needs 3986 & 155 byte instead of 3928 & 891 byte) and allows >4 devices\nplans for the future:\nalarm / conditional search\nswitch to delay() for fast enough controllers (instead of tick-counting)\ndebug tool to determine timings of exotic masters\nbetter interrupt-handling (save the state before disabling)\nirq-handled hub on supported ports, split lib into onewire() and onewireirq()\ntest each example with real onewire-masters, for now it's tested with the onewire-lib and a loxone-system (ds18b20 passed)\nlist of all family-codes\nlist of maxim sensors (at the bottom)\nconnecting the hub with the network:\nread more\nparasite power with two wires\nnote: this will certainly not work with an emulated device. powering a \u00b5controller via gpio is sometimes possible, but needs preparation and tests.\nread more\nancestors of this lib:\noriginal pieces seem to be adopted from onewireslave\nfurther development was done in onewireslave from markuslange and onewire\nfirst implementation of the onewirehub by shagrat2\nthe current code has just the concepts in common, but the codebase is a total rewrite", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000204, "year": null}, {"Unnamed: 0": 2252, "autor": 212, "date": null, "content": "MicroFlo: Live dataflow programming for microcontrollers\nUnlike most other dataflow runtimes for constrained devices, MicroFlo run standalone on the microcontroller, can be introspected and reconfigured at runtime, and has built-in support for automated testing.\nOne can program with MicroFlo either:\nVisually, using Flowhub\nTextually, using the declarative .fbp DSL or .json definition\nProgramatically, by embedding it and building a graph using the C++ API\nMicroFlo is very portable, written in C++03 without exceptions and stdlib. It comes with support for multiple platforms,including Arduino and Embedded Linux. It has been used on many different devices, from Atmel AVR8 to ARM Cortex M0/M1/M3/M4 devices (LPC mbed, TI Tiva/Stellaris), ESP8266 and Raspberry PI.\nMicroFlo is designed to integrate with other data-driven programming tools, including msgflo for easy building of distributed systems (IoT).\nUsing\nFor visual programming your Arduino, follow the microflo-example-arduino.\nSupport\nMicroFlo is a part of Flowhub, a platform for building robust IoT systems and web services.\nWe offer an Integrated Development Environment and consulting services.\nStatus\nMinimally useful.\nWorks fine for simple programs\nComponents exists for standard I/O on Arduino devices\nLive programming supported for most changes\nBasic support for automated testing\nMicroFlo in the wild:\nJon's fridge thermostat has been running uninterrupted since September 2013.\nThe Ingress table at c-base station, Berlin uses MicroFlo to control the lights. One major upgrade/bugfix since March 2014.\nThe lights on the CNC-milled Christmas tree at Bitraf, Oslo ran for 4 weeks during Christmas 2013.\nContact\nWhen you find issues: file bugs and/or submit pull requests!\nChangelog\nPast milestones\nExtending\nFor porting MicroFlo to other microcontrollers, see how-microflo-works and target bringup.\nLicense\nMicroFlo is released under the MIT license.\nNote that the platform MicroFlo runs on (like Arduino), and MicroFlo components may be under other licenses!", "link": "https://github.com/microflo/microflo", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "microflo: live dataflow programming for microcontrollers\nunlike most other dataflow runtimes for constrained devices, microflo run standalone on the microcontroller, can be introspected and reconfigured at runtime, and has built-in support for automated testing.\none can program with microflo either:\nvisually, using flowhub\ntextually, using the declarative .fbp dsl or .json definition\nprogramatically, by embedding it and building a graph using the c++ api\nmicroflo is very portable, written in c++03 without exceptions and stdlib. it comes with support for multiple platforms,including arduino and embedded linux. it has been used on many different devices, from atmel avr8 to arm cortex m0/m1/m3/m4 devices (lpc mbed, ti tiva/stellaris), esp8266 and raspberry pi.\nmicroflo is designed to integrate with other data-driven programming tools, including msgflo for easy building of distributed systems (iot).\nusing\nfor visual programming your arduino, follow the microflo-example-arduino.\nsupport\nmicroflo is a part of flowhub, a platform for building robust iot systems and web services.\nwe offer an integrated development environment and consulting services.\nstatus\nminimally useful.\nworks fine for simple programs\ncomponents exists for standard i/o on arduino devices\nlive programming supported for most changes\nbasic support for automated testing\nmicroflo in the wild:\njon's fridge thermostat has been running uninterrupted since september 2013.\nthe ingress table at c-base station, berlin uses microflo to control the lights. one major upgrade/bugfix since march 2014.\nthe lights on the cnc-milled christmas -----> tree !!!  at bitraf, oslo ran for 4 weeks during christmas 2013.\ncontact\nwhen you find issues: file bugs and/or submit pull requests!\nchangelog\npast milestones\nextending\nfor porting microflo to other microcontrollers, see how-microflo-works and target bringup.\nlicense\nmicroflo is released under the mit license.\nnote that the platform microflo runs on (like arduino), and microflo components may be under other licenses!", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000212, "year": null}, {"Unnamed: 0": 2445, "autor": 405, "date": null, "content": "Reference-en\nReference-en is the repo for the Language Reference documentation of the Arduino syntax in English. All the Reference terms files are in AsciiDoc format.\nThank you for taking the time to contribute to Arduino content, this is really helpful to the whole Arduino Community. If you want to learn more about how to contribute to this project, please check this step by step tutorial.\nContent Creation and Editing\nIf you want to contribute new content, create a new file (with any text or code editor) and save it as .adoc. Do not use parenthesis or any special character in the file name. In reference-en/AsciiDoc_sample/AsciiDoc_Dictionary you will find an overview of the AsciiDoc syntax. This includes Titles, Text, Links, Images, Tables, Code and various embeds (video, slideshow, audio, and code). You can see it rendered here.\nIf you want to contribute to the Language Reference or edit existing content, you can find two templates in reference-en/AsciiDoc_sample/Reference_Terms:\nUse AsciiDoc_Template-Single_Entity.adoc (rendered here) for terms such as analogWrite.\nUse AsciiDoc_Template-Parent_Of_Entities.adoc (rendered here) for groups of functions such as Serial.\nPlease note that every Reference file should include at least a Description, some Example Code, and links to other relevant info (See Also section).\nIf you need to add images to the Asciidoc please create a folder called attachments in the same directory as the Asciidoc file. Images can be saved in SVG and PNG format, max size 200KB.\nContribute Content on Github\nIf you are not familiar with Git you can contribute content directly on Github via their online interface. We put together a short Tutorial to show you how - CHECK IT OUT!\nYou can also follow this guide (written by the Github team) to learn how to edit an .adoc file and propose a file change to the Arduino team. When suggesting a change, please follow the guidelines described in the Reference template files.\nSubmitting a pull request\nWe are glad you want to contribute to the Arduino Reference: that\u2019s the best way to help the community.\nYour contribution is adding or modifying existing code or full descriptions, please always refer to an existing issue or open a new one before contributing.\nFolder Structure\nreference-en\n\u251c\u2500 AsciiDoc_sample\n\u2502 \u251c\u2500\u2500 AsciiDoc_Dictionary\n\u2502 \u2502 \u251c\u2500\u2500 AsciiDoc_Template-Dictionary.adoc\n\u2502 \u2502 \u2514\u2500\u2500 attachments\n\u2502 \u2514\u2500\u2500 Reference_Terms\n\u2502 \u251c\u2500\u2500 AsciiDoc_Template-Parent_Of_Entities.adoc\n\u2502 \u251c\u2500\u2500 AsciiDoc_Template-Single_Entity.adoc\n\u2502 \u2514\u2500\u2500 attachments\n\u251c\u2500\u2500 Language\n\u2502 \u251c\u2500\u2500 Functions\n\u2502 \u251c\u2500\u2500 Structure\n\u2502 \u2514\u2500\u2500 Variables\n\u251c\u2500\u2500 LICENCE.md\n\u2514\u2500\u2500 README.adoc\nWithin the Language folder, the file tree follows the same structure as in the Arduino Reference webpage\nLicense\nPlease note that your contribution to the Arduino Reference is licensed under a Creative Commons Attribution-Share Alike 3.0 License. see https://creativecommons.org/licenses/by-sa/3.0/\nThis work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.", "link": "https://github.com/arduino/reference-en", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "reference-en\nreference-en is the repo for the language reference documentation of the arduino syntax in english. all the reference terms files are in asciidoc format.\nthank you for taking the time to contribute to arduino content, this is really helpful to the whole arduino community. if you want to learn more about how to contribute to this project, please check this step by step tutorial.\ncontent creation and editing\nif you want to contribute new content, create a new file (with any text or code editor) and save it as .adoc. do not use parenthesis or any special character in the file name. in reference-en/asciidoc_sample/asciidoc_dictionary you will find an overview of the asciidoc syntax. this includes titles, text, links, images, tables, code and various embeds (video, slideshow, audio, and code). you can see it rendered here.\nif you want to contribute to the language reference or edit existing content, you can find two templates in reference-en/asciidoc_sample/reference_terms:\nuse asciidoc_template-single_entity.adoc (rendered here) for terms such as analogwrite.\nuse asciidoc_template-parent_of_entities.adoc (rendered here) for groups of functions such as serial.\nplease note that every reference file should include at least a description, some example code, and links to other relevant info (see also section).\nif you need to add images to the asciidoc please create a folder called attachments in the same directory as the asciidoc file. images can be saved in svg and png format, max size 200kb.\ncontribute content on github\nif you are not familiar with git you can contribute content directly on github via their online interface. we put together a short tutorial to show you how - check it out!\nyou can also follow this guide (written by the github team) to learn how to edit an .adoc file and propose a file change to the arduino team. when suggesting a change, please follow the guidelines described in the reference template files.\nsubmitting a pull request\nwe are glad you want to contribute to the arduino reference: that\u2019s the best way to help the community.\nyour contribution is adding or modifying existing code or full descriptions, please always refer to an existing issue or open a new one before contributing.\nfolder structure\nreference-en\n\u251c\u2500 asciidoc_sample\n\u2502 \u251c\u2500\u2500 asciidoc_dictionary\n\u2502 \u2502 \u251c\u2500\u2500 asciidoc_template-dictionary.adoc\n\u2502 \u2502 \u2514\u2500\u2500 attachments\n\u2502 \u2514\u2500\u2500 reference_terms\n\u2502 \u251c\u2500\u2500 asciidoc_template-parent_of_entities.adoc\n\u2502 \u251c\u2500\u2500 asciidoc_template-single_entity.adoc\n\u2502 \u2514\u2500\u2500 attachments\n\u251c\u2500\u2500 language\n\u2502 \u251c\u2500\u2500 functions\n\u2502 \u251c\u2500\u2500 structure\n\u2502 \u2514\u2500\u2500 variables\n\u251c\u2500\u2500 licence.md\n\u2514\u2500\u2500 readme.adoc\nwithin the language folder, the file -----> tree !!!  follows the same structure as in the arduino reference webpage\nlicense\nplease note that your contribution to the arduino reference is licensed under a creative commons attribution-share alike 3.0 license. see https://creativecommons.org/licenses/by-sa/3.0/\nthis work is licensed under a creative commons attribution-sharealike 3.0 unported license.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000405, "year": null}, {"Unnamed: 0": 2517, "autor": 477, "date": null, "content": "Arduino CMake Toolchain\nArduino CMake toolchain is a CMake toolchain for cross-compiling CMake based projects for all Arduino compatible boards (AVR, ESP32 etc.). Of course, this means all the benefits of CMake for Arduino compilation, like using your favourite IDE, configuration checks (e.g. try_compile, CheckTypeSize), etc. This also brings the Arduino compilation to professional users, who are limited by the Arduino IDE compilation.\nProject Roots\nArduino-CMake-NG is a great project, which could have prevented me from writing yet another Arduino CMake toolchain. However, as claimed by the project, Arduino-CMake-NG could not be easily utilized/modified for other Arduino compatible boards other than AVR, like ESP32, due to the fact that it does not fully work the way Arduino IDE works and has lot of AVR specific stuff. An other important limitation is related to portability. Arduino-CMake-NG provides Arduino specific CMake interface, requiring CMake scripts to be written/modified specifically for Arduino, rather than just passing -D CMAKE_TOOLCHAIN_FILE=/path/to/Arduino-toolchain.cmake to a generic CMake project.\nMy initial expectation was to contribute to Arduino-CMake-NG to fix the above limitations, but had to redo a lot of core logic making it very incompatible (including the usage). Also, the project Arduino-CMake-NG seems to be no longer maintained. I would like to acknowledge the authors who contributed directly/indirectly to Arduino-CMake-NG, and thus indirectly contributed to this project.\nFeatures\nCMake Arduino toolchain (passed to CMake using -D CMAKE_TOOLCHAIN_FILE=/path/to/Arduino-toolchain.cmake)\nSupport for all Arduino compatible platforms (such as AVR, ESP32 etc.)\nGeneric CMake scripting interface without requiring Arduino specific functions\nArduino IDE compatible build (e.g. use of build rules and flags in board.local.txt, pre/postbuild hooks etc.)\nSelection of board and board-specific menu options as in Arduino IDE tools menu (See ARDUINO_BOARD_OPTIONS_FILE)\nGenerate Arduino HEX binaries and upload to Arduino boards (See target_enable_arduino_upload)\nUpload using serial port\nRemote provisioning through network\nUpload using programmer\nBurn bootloader\nSupport linking with Arduino libraries (see target_link_arduino_libraries)\nArduino native libraries (e.g. Ethernet, Wire)\nUser installed 3rd Party Arduino libraries (e.g. IRremote)\nProject specific Arduino libraries (those present in <CMAKE_SOURCE_DIR>/libraries)\nSupport for automatic dependency resolution (Arduino IDE like, but unprofessional)\nSerial port monitoring\nSupport for .ino and '.pde' sketch files (Arduino IDE like, but unprofessional)\nBoard and Libraries Management without requiring installation of Arduino IDE\nUsage\nThe provided toolchain file (Arduino-toolchain.cmake) is passed to cmake as folows\ncmake -D CMAKE_TOOLCHAIN_FILE=/path/to/Arduino-toolchain.cmake <CMAKE_SOURCE_DIR>\nNote: As this is cross compilation, use any cross compilation compatible generator, like makefile generators (e.g. -G \"NMake Makefiles\" or -G \"MinGW Makefiles\" on Windows command prompt or -G \"Unix Makefiles\" on UNIX compatible prompts etc.).\nThe above command generates a file BoardOptions.cmake in the build directory, that enumerates all the installed Arduino boards (installed through Arduino IDE or any other board manager) and their menu options. Select the Arduino board and any non-default options for the board from the BoardOptions.cmake (Or from cmake-gui), and then reinvoke the same command above.\nIf you already have a customized BoardOptions.cmake file for the Arduino Board, you can use that instead, without waiting for the generation of BoardOptions.cmake, as given below.\ncmake -D CMAKE_TOOLCHAIN_FILE=/path/to/Arduino-toolchain.cmake -D ARDUINO_BOARD_OPTIONS_FILE=/path/to/any/BoardOptions.cmake <CMAKE_SOURCE_DIR>\nNote:\nAfter the cmake generation is successful, changing the menu options in BoardOptions.cmake may work, but changing the board itself may not be allowed by CMake because the compiler, ABI, features determination and any cache dependencies may not be retriggered again.\nCMake does not support build for multiple architectures in the same build tree. If a project requires to build applications for more than one type of Arduino boards, refer to CMake documentation for multiple architecture build.\nWhen this toolchain is used, executables (added with add_executable) have the entry points setup()/loop() and not main(). Need to include \"Arduino.h\" for these entry points.\nIf your source files are compiled for both Arduino and other platforms like linux, then the CMake flag ARDUINO and the compiler flag ARDUINO can be used for script/code portability. Other Arduino board/architecture specific standard flags can also be used.\nLinking with Arduino code/libraries (target_link_arduino_libraries)\n<CMAKE_SOURCE_DIR>/CMakeLists.txt and any other dependent CMake scripts of the project contain the standard CMake scripting using add_library, add_executable etc. without Arduino specific changes. Refer to CMake documentation for the same. However when the project source code depends on the Arduino code or libraries (i.e. if the corresponding header files are included), then appropriate linking is required, as expected. This is done using target_link_arduino_libraries as explained below.\nIf Arduino.h is included in your source files, then the target must be linked against the 'core' Arduino library as follows.\nadd_library(my_library my_library.c) # my_library.c includes Arduino.h\ntarget_link_arduino_libraries(my_library PRIVATE core)\nIf any other native or 3rd party libraries are used, then those libraries must be linked similarly as follows.\nadd_executable(my_app my_app.c) # my_app.c includes Wire.h, Arduino.h\ntarget_link_arduino_libraries(my_app PRIVATE Wire core)\nLike Arduino IDE, if the required Arduino libraries are to be automatically identified and linked, then it can be done as follows.\nadd_executable(my_app my_app.c) # my_app.c includes Wire.h, Arduino.h\n# Link Wire and core automatically (PUBLIC linking in this example)\ntarget_link_arduino_libraries(my_app AUTO_PUBLIC)\nNote:\nWire and core in the above examples are not CMake targets. They are just Arduino library names (case-sensitive).\nIt is required only to specify the direct dependencies. Any deeper dependencies are automatically identified and linked. For example, if SD.h is included, it is sufficient to link with SD, even if SD depends on other Arduino libraries, like SPI.\nThese examples illustrates simple usage, but powerful enough for most use cases. However more advanced control and customization of Arduino libraries should be possible. Please refer to the Examples folder, as well as the API documentation of target_link_arduino_libraries (Currently documented as comments in BoardBuildTargets.cmake).\nUploading to the target board (target_enable_arduino_upload)\nIf support for generating HEX binary and uploading it to the board is required, then a call to target_enable_arduino_upload is required for each executable target, as shown below.\nadd_executable(my_executable my_executable.c)\ntarget_link_arduino_libraries(my_executable PRIVATE core) # Assuming my_executable.c includes Arduino.h\ntarget_enable_arduino_upload(my_executable) # This adds a target upload-my_executable\nUpload the executable (from the above example) to the board on COM3 serial port as follows\n<make-command> upload-my_executable SERIAL_PORT=COM3\nUpload the executable to the board through remote provisioning as follows\n<make-command> upload-my_executable NETWORK_PORT=<IP>[:<port>]\nFor using a programmer, select the programmer in board options or the CMake GUI, and then execute the following\n<make-command> program-my_executable CONFIRM=1\nUsing the programmer, bootloader can be flashed as below\n<make-command> burn-bootloader CONFIRM=1\nSerial port monitoring\nCurrently there is no support available for this within this toolchain. However any external serial port monitor can be used (e.g. Putty). External serial monitor may need to be closed before upload and reopened after upload, because both use the same serial port.\nKnown issues\nMany of the issues in the master branch have been fixed in release-1.1-dev branch. Although not tested to be fully stable, release-1.1-dev is stable enough to try out and report any futher issues before it gets merged into master.\nBelow are the list of known issues in the master branch.\n1. Uploaded application does not work on some boards\nCaused by build linking issue that does not link some object files related to platform variant sources contained in the core library. Affects any Arduino platform that has variant source files in addition to the variant header files.\nResolution: Please try with release-1.1-dev branch or otherwise, temporary fixes are available in the branches fix/variant_link_alt1 and fix/variant_link_alt2.\nCompromises when using the fix/variant_link_alt1 fix: (1) CMake version must be above 3.13, (2) Application needs to link with core directly, like in Examples/01_hello_world, and not like in Examples/03_portable_app which links transitively.\nCompromises when using the fix/variant_link_alt2 fix: Need to retrigger cmake and do rebuild, after the first successful build, if transitive linking of core is used in the project. May get \"source some_file.o not found error\" in CMake during the first invocation of CMake that can be ignored.\n2. Build/link issue on some 3rd party platforms\nResolution: Please try with release-1.1-dev branch.\n3. Some libraries are not detected by target_link_arduino_libraries\nCurrently, target_link_arduino_libraries takes only include names (i.e. the name of the header file without extension). If the include name does not match with the library name (as mentioned in library.properties of the library), the detection of the library fails (Refer issue #19).\nWorkaround: Rename the library folder to the include name and use include name in target_link_arduino_libraries.\nResolution: Please try with release-1.1-dev branch.\nHow it works\nThis toolchain follows the build process described in Arduino Build Process, and processes the JSON, platform.txt and boards.txt files correponding to the Arduino platform as specified in the documentation Arduino IDE 1.5 3rd party Hardware specification.\nLicense\nMIT \u00a9 2020 Arduino-CMake-Toolchain", "link": "https://github.com/a9183756-gh/Arduino-CMake-Toolchain", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "arduino cmake toolchain\narduino cmake toolchain is a cmake toolchain for cross-compiling cmake based projects for all arduino compatible boards (avr, esp32 etc.). of course, this means all the benefits of cmake for arduino compilation, like using your favourite ide, configuration checks (e.g. try_compile, checktypesize), etc. this also brings the arduino compilation to professional users, who are limited by the arduino ide compilation.\nproject roots\narduino-cmake-ng is a great project, which could have prevented me from writing yet another arduino cmake toolchain. however, as claimed by the project, arduino-cmake-ng could not be easily utilized/modified for other arduino compatible boards other than avr, like esp32, due to the fact that it does not fully work the way arduino ide works and has lot of avr specific stuff. an other important limitation is related to portability. arduino-cmake-ng provides arduino specific cmake interface, requiring cmake scripts to be written/modified specifically for arduino, rather than just passing -d cmake_toolchain_file=/path/to/arduino-toolchain.cmake to a generic cmake project.\nmy initial expectation was to contribute to arduino-cmake-ng to fix the above limitations, but had to redo a lot of core logic making it very incompatible (including the usage). also, the project arduino-cmake-ng seems to be no longer maintained. i would like to acknowledge the authors who contributed directly/indirectly to arduino-cmake-ng, and thus indirectly contributed to this project.\nfeatures\ncmake arduino toolchain (passed to cmake using -d cmake_toolchain_file=/path/to/arduino-toolchain.cmake)\nsupport for all arduino compatible platforms (such as avr, esp32 etc.)\ngeneric cmake scripting interface without requiring arduino specific functions\narduino ide compatible build (e.g. use of build rules and flags in board.local.txt, pre/postbuild hooks etc.)\nselection of board and board-specific menu options as in arduino ide tools menu (see arduino_board_options_file)\ngenerate arduino hex binaries and upload to arduino boards (see target_enable_arduino_upload)\nupload using serial port\nremote provisioning through network\nupload using programmer\nburn bootloader\nsupport linking with arduino libraries (see target_link_arduino_libraries)\narduino native libraries (e.g. ethernet, wire)\nuser installed 3rd party arduino libraries (e.g. irremote)\nproject specific arduino libraries (those present in <cmake_source_dir>/libraries)\nsupport for automatic dependency resolution (arduino ide like, but unprofessional)\nserial port monitoring\nsupport for .ino and '.pde' sketch files (arduino ide like, but unprofessional)\nboard and libraries management without requiring installation of arduino ide\nusage\nthe provided toolchain file (arduino-toolchain.cmake) is passed to cmake as folows\ncmake -d cmake_toolchain_file=/path/to/arduino-toolchain.cmake <cmake_source_dir>\nnote: as this is cross compilation, use any cross compilation compatible generator, like makefile generators (e.g. -g \"nmake makefiles\" or -g \"mingw makefiles\" on windows command prompt or -g \"unix makefiles\" on unix compatible prompts etc.).\nthe above command generates a file boardoptions.cmake in the build directory, that enumerates all the installed arduino boards (installed through arduino ide or any other board manager) and their menu options. select the arduino board and any non-default options for the board from the boardoptions.cmake (or from cmake-gui), and then reinvoke the same command above.\nif you already have a customized boardoptions.cmake file for the arduino board, you can use that instead, without waiting for the generation of boardoptions.cmake, as given below.\ncmake -d cmake_toolchain_file=/path/to/arduino-toolchain.cmake -d arduino_board_options_file=/path/to/any/boardoptions.cmake <cmake_source_dir>\nnote:\nafter the cmake generation is successful, changing the menu options in boardoptions.cmake may work, but changing the board itself may not be allowed by cmake because the compiler, abi, features determination and any cache dependencies may not be retriggered again.\ncmake does not support build for multiple architectures in the same build -----> tree !!! . if a project requires to build applications for more than one type of arduino boards, refer to cmake documentation for multiple architecture build.\nwhen this toolchain is used, executables (added with add_executable) have the entry points setup()/loop() and not main(). need to include \"arduino.h\" for these entry points.\nif your source files are compiled for both arduino and other platforms like linux, then the cmake flag arduino and the compiler flag arduino can be used for script/code portability. other arduino board/architecture specific standard flags can also be used.\nlinking with arduino code/libraries (target_link_arduino_libraries)\n<cmake_source_dir>/cmakelists.txt and any other dependent cmake scripts of the project contain the standard cmake scripting using add_library, add_executable etc. without arduino specific changes. refer to cmake documentation for the same. however when the project source code depends on the arduino code or libraries (i.e. if the corresponding header files are included), then appropriate linking is required, as expected. this is done using target_link_arduino_libraries as explained below.\nif arduino.h is included in your source files, then the target must be linked against the 'core' arduino library as follows.\nadd_library(my_library my_library.c) # my_library.c includes arduino.h\ntarget_link_arduino_libraries(my_library private core)\nif any other native or 3rd party libraries are used, then those libraries must be linked similarly as follows.\nadd_executable(my_app my_app.c) # my_app.c includes wire.h, arduino.h\ntarget_link_arduino_libraries(my_app private wire core)\nlike arduino ide, if the required arduino libraries are to be automatically identified and linked, then it can be done as follows.\nadd_executable(my_app my_app.c) # my_app.c includes wire.h, arduino.h\n# link wire and core automatically (public linking in this example)\ntarget_link_arduino_libraries(my_app auto_public)\nnote:\nwire and core in the above examples are not cmake targets. they are just arduino library names (case-sensitive).\nit is required only to specify the direct dependencies. any deeper dependencies are automatically identified and linked. for example, if sd.h is included, it is sufficient to link with sd, even if sd depends on other arduino libraries, like spi.\nthese examples illustrates simple usage, but powerful enough for most use cases. however more advanced control and customization of arduino libraries should be possible. please refer to the examples folder, as well as the api documentation of target_link_arduino_libraries (currently documented as comments in boardbuildtargets.cmake).\nuploading to the target board (target_enable_arduino_upload)\nif support for generating hex binary and uploading it to the board is required, then a call to target_enable_arduino_upload is required for each executable target, as shown below.\nadd_executable(my_executable my_executable.c)\ntarget_link_arduino_libraries(my_executable private core) # assuming my_executable.c includes arduino.h\ntarget_enable_arduino_upload(my_executable) # this adds a target upload-my_executable\nupload the executable (from the above example) to the board on com3 serial port as follows\n<make-command> upload-my_executable serial_port=com3\nupload the executable to the board through remote provisioning as follows\n<make-command> upload-my_executable network_port=<ip>[:<port>]\nfor using a programmer, select the programmer in board options or the cmake gui, and then execute the following\n<make-command> program-my_executable confirm=1\nusing the programmer, bootloader can be flashed as below\n<make-command> burn-bootloader confirm=1\nserial port monitoring\ncurrently there is no support available for this within this toolchain. however any external serial port monitor can be used (e.g. putty). external serial monitor may need to be closed before upload and reopened after upload, because both use the same serial port.\nknown issues\nmany of the issues in the master branch have been fixed in release-1.1-dev branch. although not tested to be fully stable, release-1.1-dev is stable enough to try out and report any futher issues before it gets merged into master.\nbelow are the list of known issues in the master branch.\n1. uploaded application does not work on some boards\ncaused by build linking issue that does not link some object files related to platform variant sources contained in the core library. affects any arduino platform that has variant source files in addition to the variant header files.\nresolution: please try with release-1.1-dev branch or otherwise, temporary fixes are available in the branches fix/variant_link_alt1 and fix/variant_link_alt2.\ncompromises when using the fix/variant_link_alt1 fix: (1) cmake version must be above 3.13, (2) application needs to link with core directly, like in examples/01_hello_world, and not like in examples/03_portable_app which links transitively.\ncompromises when using the fix/variant_link_alt2 fix: need to retrigger cmake and do rebuild, after the first successful build, if transitive linking of core is used in the project. may get \"source some_file.o not found error\" in cmake during the first invocation of cmake that can be ignored.\n2. build/link issue on some 3rd party platforms\nresolution: please try with release-1.1-dev branch.\n3. some libraries are not detected by target_link_arduino_libraries\ncurrently, target_link_arduino_libraries takes only include names (i.e. the name of the header file without extension). if the include name does not match with the library name (as mentioned in library.properties of the library), the detection of the library fails (refer issue #19).\nworkaround: rename the library folder to the include name and use include name in target_link_arduino_libraries.\nresolution: please try with release-1.1-dev branch.\nhow it works\nthis toolchain follows the build process described in arduino build process, and processes the json, platform.txt and boards.txt files correponding to the arduino platform as specified in the documentation arduino ide 1.5 3rd party hardware specification.\nlicense\nmit \u00a9 2020 arduino-cmake-toolchain", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000477, "year": null}, {"Unnamed: 0": 2603, "autor": 563, "date": null, "content": "MicroShell\nLightweight pure C implementation of virtual shell, compatible with VT100 terminal. Support root tree, run-time mounting paths, global commands, and much more. Works out-of-the-box on Arduino-compatible boards. Dedicated for bare-metal embedded systems. Thanks to the asynchronous architecture it does not block operations and can be easily implemented even on small microcontrollers with relatively small resources.\nProject Homepage\nLIVE DEMO <- needs PC web browser (not mobile)\nFeatures\nnames autocompletation (do You like a TAB-functionality on You favorite bash shell?)\nno dynamic allocations (no memory leaks - no problem)\nhardware independent (works just as well on AVR, PIC, STM32, ESP32 as it on x86 or RPI)\nrich set of examples (available in the Arduino Library Manager)\npure C source code (works on rich set of compilers)\nbackspace key feature (simply works)\ncompatible vith VT100 standard (works out of the box with default putty configuration)\neasy to extend (adding more \"weird\" features it has never been easier)\nbuildin commands (must-have, basic support of LS, CAT, PWD, HELP, XXD, ECHO)\nscalable (configuration allows You to exclude unnecessary modules from building)\ntranslation-ready (do You want Hindi translation? no problem!)\nno internal buffers (support unlimited data stream lengths)\nno static variables (possibility to use multiple independent shells in single system)\nobject oriented architecture (pointers attack!)\nsupport root tree with static virtual files with callbacks (full customization)\nextremely simple to integrate (only 1 simple interface with IO operations)\nasynchronous architecture (static callbacks is not a problem)\nnon-blocking api (You just need to call one non-blocking function on main loop)\nunit and functional tests (for greater certainty that nothing will break down)\nBuild\nBuild, test and run DEMO:\ncmake -Bbuild .\ncd build\nmake\nmake test\nmake coverage\n./bin/demo\nUsage\nDefine I/O interface:\n// non-blocking read interface\nstatic int ush_read(struct ush_object *self, char *ch)\n{\n// should be implemented as a FIFO\nif (Serial.available() > 0) {\n*ch = Serial.read();\nreturn 1;\n}\nreturn 0;\n}\n// non-blocking write interface\nstatic int ush_write(struct ush_object *self, char ch)\n{\n// should be implemented as a FIFO\nreturn (Serial.write(ch) == 1);\n}\n// I/O interface descriptor\nstatic const struct ush_io_interface ush_iface = {\n.read = ush_read,\n.write = ush_write,\n};\nDefine shell descriptor and shell instance:\n// working buffers allocations (size could be customized)\n#define BUF_IN_SIZE 32\n#define BUF_OUT_SIZE 32\n#define PATH_MAX_SIZE 32\nstatic char ush_in_buf[BUF_IN_SIZE];\nstatic char ush_out_buf[BUF_OUT_SIZE];\n// microshell instance handler\nstatic struct ush_object ush;\n// microshell descriptor\nstatic const struct ush_descriptor ush_desc = {\n.io = &ush_iface, // I/O interface pointer\n.input_buffer = ush_in_buf, // working input buffer\n.input_buffer_size = sizeof(ush_in_buf), // working input buffer size\n.output_buffer = ush_out_buf, // working output buffer\n.output_buffer_size = sizeof(ush_out_buf), // working output buffer size\n.path_max_length = PATH_MAX_SIZE, // path maximum length (stack)\n.hostname = \"arduino\", // hostname (in prompt)\n};\n// root directory handler\nstatic struct ush_node_object root;\nSetup and run:\nvoid setup()\n{\n// initialize I/O interface\nSerial.begin(115200UL);\n// initialize microshell instance\nush_init(&ush, &ush_desc);\n// mount root directory (root must be first)\nush_node_mount(&ush, \"/\", &root, NULL, 0);\n// mount other directories here\n// ...\n}\nvoid loop()\n{\n// non-blocking microshell service\nush_service(&ush);\n// do other non-blocking stuff here\n// ...\n}\nContribution\nIf You want to contribute this project - excellent! Fork it, make bugs, and send a PR :)\nIf You want to support me in developing this project - please donate!", "link": "https://github.com/marcinbor85/microshell", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "microshell\nlightweight pure c implementation of virtual shell, compatible with vt100 terminal. support root -----> tree !!! , run-time mounting paths, global commands, and much more. works out-of-the-box on arduino-compatible boards. dedicated for bare-metal embedded systems. thanks to the asynchronous architecture it does not block operations and can be easily implemented even on small microcontrollers with relatively small resources.\nproject homepage\nlive demo <- needs pc web browser (not mobile)\nfeatures\nnames autocompletation (do you like a tab-functionality on you favorite bash shell?)\nno dynamic allocations (no memory leaks - no problem)\nhardware independent (works just as well on avr, pic, stm32, esp32 as it on x86 or rpi)\nrich set of examples (available in the arduino library manager)\npure c source code (works on rich set of compilers)\nbackspace key feature (simply works)\ncompatible vith vt100 standard (works out of the box with default putty configuration)\neasy to extend (adding more \"weird\" features it has never been easier)\nbuildin commands (must-have, basic support of ls, cat, pwd, help, xxd, echo)\nscalable (configuration allows you to exclude unnecessary modules from building)\ntranslation-ready (do you want hindi translation? no problem!)\nno internal buffers (support unlimited data stream lengths)\nno static variables (possibility to use multiple independent shells in single system)\nobject oriented architecture (pointers attack!)\nsupport root tree with static virtual files with callbacks (full customization)\nextremely simple to integrate (only 1 simple interface with io operations)\nasynchronous architecture (static callbacks is not a problem)\nnon-blocking api (you just need to call one non-blocking function on main loop)\nunit and functional tests (for greater certainty that nothing will break down)\nbuild\nbuild, test and run demo:\ncmake -bbuild .\ncd build\nmake\nmake test\nmake coverage\n./bin/demo\nusage\ndefine i/o interface:\n// non-blocking read interface\nstatic int ush_read(struct ush_object *self, char *ch)\n{\n// should be implemented as a fifo\nif (serial.available() > 0) {\n*ch = serial.read();\nreturn 1;\n}\nreturn 0;\n}\n// non-blocking write interface\nstatic int ush_write(struct ush_object *self, char ch)\n{\n// should be implemented as a fifo\nreturn (serial.write(ch) == 1);\n}\n// i/o interface descriptor\nstatic const struct ush_io_interface ush_iface = {\n.read = ush_read,\n.write = ush_write,\n};\ndefine shell descriptor and shell instance:\n// working buffers allocations (size could be customized)\n#define buf_in_size 32\n#define buf_out_size 32\n#define path_max_size 32\nstatic char ush_in_buf[buf_in_size];\nstatic char ush_out_buf[buf_out_size];\n// microshell instance handler\nstatic struct ush_object ush;\n// microshell descriptor\nstatic const struct ush_descriptor ush_desc = {\n.io = &ush_iface, // i/o interface pointer\n.input_buffer = ush_in_buf, // working input buffer\n.input_buffer_size = sizeof(ush_in_buf), // working input buffer size\n.output_buffer = ush_out_buf, // working output buffer\n.output_buffer_size = sizeof(ush_out_buf), // working output buffer size\n.path_max_length = path_max_size, // path maximum length (stack)\n.hostname = \"arduino\", // hostname (in prompt)\n};\n// root directory handler\nstatic struct ush_node_object root;\nsetup and run:\nvoid setup()\n{\n// initialize i/o interface\nserial.begin(115200ul);\n// initialize microshell instance\nush_init(&ush, &ush_desc);\n// mount root directory (root must be first)\nush_node_mount(&ush, \"/\", &root, null, 0);\n// mount other directories here\n// ...\n}\nvoid loop()\n{\n// non-blocking microshell service\nush_service(&ush);\n// do other non-blocking stuff here\n// ...\n}\ncontribution\nif you want to contribute this project - excellent! fork it, make bugs, and send a pr :)\nif you want to support me in developing this project - please donate!", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000563, "year": null}, {"Unnamed: 0": 2734, "autor": 694, "date": null, "content": "Awesome ws2812\nA curated list of awesome resources for ws281x LED strips and matrices.\nMost of them are meant to be controlled using ESP8266 chips programmed with Arduino.\nIf you have an awesome project that is not listed here yet, your Pull Request is very welcome!\nWhat is ws2812\nThe ws2812 is an intelligent control LED light source, with the control circuit and RGB chip integrated directly into a 5050 RGB LED.\nSome features:\nThe control circuit and the LED share the only power source.\nBuilt-in electric reset circuit and power lost reset circuit.\nEach pixel of the three primary color can achieve 256 brightness display, completed 16777216 color full color display, and scan frequency not less than 400Hz/s.\nCascading port transmission signal by single line.\nContents\nLibraries\nLED strips\nAdafruit NeoPixel - Arduino library for controlling single-wire LED pixels (NeoPixel, WS2812, etc.)\nblynk - Blynk library for embedded hardware.\nFastLED - Library for colored LED animation on Arduino\nledcat - Simple utility that aims to provide a standard interface for driving LED-strips and such.\nNeoPixelBus - Adafruit enhanced NeoPixel support library.\nWS2812FX - Drop-in replacement for the Adafruit NeoPixel library with additional features.\nraspi_ws2812 - A kernel module able to run as many WS2812 strips as there are GPIO pins on Raspberry Pi Zero.\nrpi_ws281x - Userspace Raspberry Pi PWM library for WS281X LEDs.\nLED matrices\nAdafruit NeoMatrix - Adafruit_GFX-compatible library for NeoPixel grids.\nLEDMatrix - FastLED Flexible Matrix Class.\nLEDSprites - FastLED Sprite Class requires LEDMatrix Class.\nLEDText - FastLED Flexible Text Message Class requires LEDMatrix Class.\nLED strip controllers\nArduLED 1.0 and 2.0 - Control NeoPixels (ws2812b) easier than ever with an Arduino!\nEspFire2012 - Testing of NeoPixel libraries to do fire simulation with Fire2012.\nMcLighting v2 and v3 - The ESP8266 based multi-client lighting gadget.\nMusic LED Strip Control - LED strip audio visualization in real time with web interface on a Raspberry Pi.\nMusic Reactive WS2812B Arduino - LED STRIP WS2812B reacting to music connected through your AUX 3.5mm Jack.\nResponsive LED Control - Responsive Led Control based on McLightning & Grisworld-Led-Controller with FastLED.\nSimple LED Strip Controller - ESP8266 Based LED light strip controller via a web browser.\nxmas-tree - XMAS Tree from stacked ws2812 rings driven by a Digispark.\nWLED - Control WS2812B RGB LEDs with an ESP8266 over WiFi!\nWS2812Serial - Non-Blocking WS2812 LED Library.\nLED matrix controllers\nFB.Light - WiFi-LED-Strip-Controller with NTP-driven scrolling clock, text and other effects.\nWhite Rabbit - Neopixel based XY Matrix running via Raspberry Pi to display time, weather, and news.\nTools\nHTML5 LED Matrix - An HTML5 Canvas LED Matrix Simulator.\nLED Matrix Simulator - A simple HTML5 LED Matrix Simulator for fun.\nMatrix display store - Tools for creating Led Matrix content.\nNeoMatrix Generator - NeoMatrix VISIWIG graphics editor.\nProjects\nAudio Reactive LED Matrix - Code for 16x16 LED Matrix (WS2812) that reacts to sounds detected from an electret microphone, and switches modes with a momentary push button.\nESP8266 NeoPixel Dashboard - ESP8266 based Neopixel dashboard, it shows current time, can show a custom message and have upto 41 prebuild effects.\nNeoPixel2048 - Implementation of the popular game '2048' built using a 4x4 NeoPixel Matrix and powered by the Arduino micro-controller.\nLED Lightpainter - A DIY Pixelstick clone for Light Painting using the ESP8266 and a WS2812 Strip.\nLED Matrix Shades - Wearable LED matrix shaped like slotted sunglasses.\nLED Protest Sign Scroller - WS2812 Matrix Protest Sign.\nRpi Matrix - A simple RaspberryPi clock and browser simulator.\nSatellite tracker - Project that shows satellites and space junk flying overhead.\nWordClock - A clock that tells time in plain text (video).\nVideos\n1000 Addressable LED Lights Project Overview\nFire2012: fire simulation for Arduino and LEDs\nUsing I2S on the ESP8266 to drive WS2812Bs\nMiscellanea\nAdafruit NeoPixel \u00dcberguide\nBest practices to avoid damaging your NeoPixels.\nHow to drive 5V WS2812 from a 3.3V microcontroller using just one resistor and one diode.", "link": "https://github.com/PabloCastellano/awesome-ws2812", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "awesome ws2812\na curated list of awesome resources for ws281x led strips and matrices.\nmost of them are meant to be controlled using esp8266 chips programmed with arduino.\nif you have an awesome project that is not listed here yet, your pull request is very welcome!\nwhat is ws2812\nthe ws2812 is an intelligent control led light source, with the control circuit and rgb chip integrated directly into a 5050 rgb led.\nsome features:\nthe control circuit and the led share the only power source.\nbuilt-in electric reset circuit and power lost reset circuit.\neach pixel of the three primary color can achieve 256 brightness display, completed 16777216 color full color display, and scan frequency not less than 400hz/s.\ncascading port transmission signal by single line.\ncontents\nlibraries\nled strips\nadafruit neopixel - arduino library for controlling single-wire led pixels (neopixel, ws2812, etc.)\nblynk - blynk library for embedded hardware.\nfastled - library for colored led animation on arduino\nledcat - simple utility that aims to provide a standard interface for driving led-strips and such.\nneopixelbus - adafruit enhanced neopixel support library.\nws2812fx - drop-in replacement for the adafruit neopixel library with additional features.\nraspi_ws2812 - a kernel module able to run as many ws2812 strips as there are gpio pins on raspberry pi zero.\nrpi_ws281x - userspace raspberry pi pwm library for ws281x leds.\nled matrices\nadafruit neomatrix - adafruit_gfx-compatible library for neopixel grids.\nledmatrix - fastled flexible matrix class.\nledsprites - fastled sprite class requires ledmatrix class.\nledtext - fastled flexible text message class requires ledmatrix class.\nled strip controllers\narduled 1.0 and 2.0 - control neopixels (ws2812b) easier than ever with an arduino!\nespfire2012 - testing of neopixel libraries to do fire simulation with fire2012.\nmclighting v2 and v3 - the esp8266 based multi-client lighting gadget.\nmusic led strip control - led strip audio visualization in real time with web interface on a raspberry pi.\nmusic reactive ws2812b arduino - led strip ws2812b reacting to music connected through your aux 3.5mm jack.\nresponsive led control - responsive led control based on mclightning & grisworld-led-controller with fastled.\nsimple led strip controller - esp8266 based led light strip controller via a web browser.\nxmas------> tree !!!  - xmas -----> tree !!!  from stacked ws2812 rings driven by a digispark.\nwled - control ws2812b rgb leds with an esp8266 over wifi!\nws2812serial - non-blocking ws2812 led library.\nled matrix controllers\nfb.light - wifi-led-strip-controller with ntp-driven scrolling clock, text and other effects.\nwhite rabbit - neopixel based xy matrix running via raspberry pi to display time, weather, and news.\ntools\nhtml5 led matrix - an html5 canvas led matrix simulator.\nled matrix simulator - a simple html5 led matrix simulator for fun.\nmatrix display store - tools for creating led matrix content.\nneomatrix generator - neomatrix visiwig graphics editor.\nprojects\naudio reactive led matrix - code for 16x16 led matrix (ws2812) that reacts to sounds detected from an electret microphone, and switches modes with a momentary push button.\nesp8266 neopixel dashboard - esp8266 based neopixel dashboard, it shows current time, can show a custom message and have upto 41 prebuild effects.\nneopixel2048 - implementation of the popular game '2048' built using a 4x4 neopixel matrix and powered by the arduino micro-controller.\nled lightpainter - a diy pixelstick clone for light painting using the esp8266 and a ws2812 strip.\nled matrix shades - wearable led matrix shaped like slotted sunglasses.\nled protest sign scroller - ws2812 matrix protest sign.\nrpi matrix - a simple raspberrypi clock and browser simulator.\nsatellite tracker - project that shows satellites and space junk flying overhead.\nwordclock - a clock that tells time in plain text (video).\nvideos\n1000 addressable led lights project overview\nfire2012: fire simulation for arduino and leds\nusing i2s on the esp8266 to drive ws2812bs\nmiscellanea\nadafruit neopixel \u00fcberguide\nbest practices to avoid damaging your neopixels.\nhow to drive 5v ws2812 from a 3.3v microcontroller using just one resistor and one diode.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000694, "year": null}, {"Unnamed: 0": 2736, "autor": 696, "date": null, "content": "yummyDSP\nyummyDSP is an Arduino audio DSP library for the Espressif ESP32. Main focus is realtime processing of audio signals for e.g. a guitar stomp box.\nAlthough there is some basic synth stuff inside, there are probably better audio synthesis libraries out there. For web radios, player, recorder or similar have a look at the Espressif Systems Audio Development Framework.\nThe Library is in an early state, still lot's of known issues! Anyone is invited to help, extend and bring in his expertise.\nThe idea is to have modular blocks which are simply arranged in a processing tree to form the signal chain. These processing blocks are called Nodes inspired by Apple's Audio Unit framework. They are processed one after another in the sequence in which they are added to the tree:\nYummyDSP dsp;\nFilterNode lp; // a low pass filter\nWaveShaperNode sat; // some saturation\n...\ndsp.add(&lp);\ndsp.add(&sat);\n...\nsample = dsp.process(sample);\nThis allows for a pretty high level view on signal processing but also to dig deeper and write your own nodes or directly add dsp code in the sample loop.\nCurrently there a just a few nodes implemented (more to come)\nHipass / Lopass / Bandpass filter\nWaveshaper / Saturation\nDelay (still dirty and experimental :)\nGetting Started\nFirst you'll need some sort of an ESP32 e.g. ESP32 DevKitC or a derivate.\nYou also need an ADC or audio codec connected via I2S. The AI-Thinker ESP32 Audio Kit is cheap and has everything on board to start.\nInstallation\nInstall the Arduino ESP32 Core as described.\nDownload this library into your Arduino library folder\nRun the example code and fiddle around\nESP32\nThe ESP32 has two cores at 240 MHz and features a Bluetooth and Wifi module (hello OSC). The WROOM32 module has just 520 kB of RAM, the WROVER32 module at least additional 4MB (you'll want that for many lookup tables, delay line, etc.).\nThe ESP32 is running a realtime OS, namely freeRTOS managing tasks, threading and all that. Audio processing is running on one core, leaving the other for control and housekeeping stuff.\nFun Facts\nProcessing is sample wise\nI2S buffers are handled by DMA\nI2S master clock is provided on GPIO0. This pin needs to be high on boot up!\nLatency is low, depends on the I2S buffer size (currently a few ms)\nTested with AKM AK4552 and AK4556 audio codec and AC101 / AI-Thinker Audio Development Kit\nLicense\nThis project is licensed under the GPLv3 License - see the LICENSE file for details", "link": "https://github.com/garygru/yummyDSP", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "yummydsp\nyummydsp is an arduino audio dsp library for the espressif esp32. main focus is realtime processing of audio signals for e.g. a guitar stomp box.\nalthough there is some basic synth stuff inside, there are probably better audio synthesis libraries out there. for web radios, player, recorder or similar have a look at the espressif systems audio development framework.\nthe library is in an early state, still lot's of known issues! anyone is invited to help, extend and bring in his expertise.\nthe idea is to have modular blocks which are simply arranged in a processing -----> tree !!!  to form the signal chain. these processing blocks are called nodes inspired by apple's audio unit framework. they are processed one after another in the sequence in which they are added to the tree:\nyummydsp dsp;\nfilternode lp; // a low pass filter\nwaveshapernode sat; // some saturation\n...\ndsp.add(&lp);\ndsp.add(&sat);\n...\nsample = dsp.process(sample);\nthis allows for a pretty high level view on signal processing but also to dig deeper and write your own nodes or directly add dsp code in the sample loop.\ncurrently there a just a few nodes implemented (more to come)\nhipass / lopass / bandpass filter\nwaveshaper / saturation\ndelay (still dirty and experimental :)\ngetting started\nfirst you'll need some sort of an esp32 e.g. esp32 devkitc or a derivate.\nyou also need an adc or audio codec connected via i2s. the ai-thinker esp32 audio kit is cheap and has everything on board to start.\ninstallation\ninstall the arduino esp32 core as described.\ndownload this library into your arduino library folder\nrun the example code and fiddle around\nesp32\nthe esp32 has two cores at 240 mhz and features a bluetooth and wifi module (hello osc). the wroom32 module has just 520 kb of ram, the wrover32 module at least additional 4mb (you'll want that for many lookup tables, delay line, etc.).\nthe esp32 is running a realtime os, namely freertos managing tasks, threading and all that. audio processing is running on one core, leaving the other for control and housekeeping stuff.\nfun facts\nprocessing is sample wise\ni2s buffers are handled by dma\ni2s master clock is provided on gpio0. this pin needs to be high on boot up!\nlatency is low, depends on the i2s buffer size (currently a few ms)\ntested with akm ak4552 and ak4556 audio codec and ac101 / ai-thinker audio development kit\nlicense\nthis project is licensed under the gplv3 license - see the license file for details", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000696, "year": null}, {"Unnamed: 0": 2767, "autor": 727, "date": null, "content": "Faur is a personal C framework for my video games.\nFeatures include 2D graphics, sound, inputs, state management, ECS model, and utilities to help with data, files, math, memory, strings, time, and more.\nFaur builds native on Linux and cross-compiles for Web, Windows, and some embedded devices. The build system uses GNU Make 4.1 and Python 3.6 or later.\nDependencies & Path Setup\n# Required\nsudo apt install build-essential git python3 python3-pil\nsudo apt install libsdl2-dev libsdl2-mixer-dev libpng-dev\n# Optional\nsudo apt install ffmpeg libsdl1.2-dev libsdl-mixer1.2-dev\n# Clone repo to ~/faur\ncd ~\ngit clone git://github.com/alxm/faur.git\n# Set FAUR_PATH environment var and add tools to PATH\nexport FAUR_PATH=\"$HOME/faur\"\nexport PATH=\"$PATH:$FAUR_PATH/bin\"\nHello, World\n$ faur-new hello\n$ tree hello/\nhello/\n\u251c\u2500\u2500 build/\n\u2502 \u2514\u2500\u2500 make/\n\u2502 \u2514\u2500\u2500 Makefile\n\u2514\u2500\u2500 src/\n\u2514\u2500\u2500 main.c\n$ cd hello/build/make/\n$ make run\nYou can move the square with the arrow keys or a controller.\nhello/src/main.c\n#include <faur.h>\nvoid f_main(void)\n{\nstatic struct {\nint x, y;\nFButton *up, *down, *left, *right;\n} context;\nF_STATE_INIT\n{\ncontext.x = f_screen_sizeGetWidth() / 2;\ncontext.y = f_screen_sizeGetHeight() / 2;\ncontext.up = f_button_new();\nf_button_bindKey(context.up, F_KEY_UP);\nf_button_bindButton(context.up, NULL, F_BUTTON_UP);\ncontext.down = f_button_new();\nf_button_bindKey(context.down, F_KEY_DOWN);\nf_button_bindButton(context.down, NULL, F_BUTTON_DOWN);\ncontext.left = f_button_new();\nf_button_bindKey(context.left, F_KEY_LEFT);\nf_button_bindButton(context.left, NULL, F_BUTTON_LEFT);\ncontext.right = f_button_new();\nf_button_bindKey(context.right, F_KEY_RIGHT);\nf_button_bindButton(context.right, NULL, F_BUTTON_RIGHT);\n}\nF_STATE_TICK\n{\nif(f_button_pressGet(context.up)) {\ncontext.y--;\n}\nif(f_button_pressGet(context.down)) {\ncontext.y++;\n}\nif(f_button_pressGet(context.left)) {\ncontext.x--;\n}\nif(f_button_pressGet(context.right)) {\ncontext.x++;\n}\n}\nF_STATE_DRAW\n{\nf_color_colorSetHex(0xaaff88);\nf_draw_fill();\nf_color_colorSetHex(0xffaa44);\nf_draw_rectangle(context.x - 40, context.y - 40, 80, 80);\n}\nF_STATE_FREE\n{\nf_button_free(context.up);\nf_button_free(context.down);\nf_button_free(context.left);\nf_button_free(context.right);\n}\n}\nhello/build/make/Makefile\nF_CONFIG_APP_AUTHOR := <author>\nF_CONFIG_APP_NAME := hello\ninclude $(FAUR_PATH)/make/default.mk\nCross-Compile for Other Platforms\nI started Faur to make games for the Linux-based GP2X. These are the supported platforms now:\nPlatform Toolchain Support Libraries\nDesktop\nLinux, FreeBSD OS build tools SDL 2.0, SDL_mixer 2.0, libpng 1.6\nWindows MinGW-w64 SDL 2.0, SDL_mixer 2.0, libpng 1.6\nWeb (Wasm) Emscripten SDL 2.0, SDL_mixer 2.0, libpng 1.6\nEmbedded Linux\nGP2X, GP2X Wiz Open2x SDK SDL 1.2, SDL_mixer 1.2, libpng 1.2\nCaanoo GPH SDK SDL 1.2, SDL_mixer 1.2, libpng 1.2\nOpen Pandora Pandora SDK SDL 1.2, SDL_mixer 1.2, libpng 1.2\nArduino\nGamebuino META Arduino SAMD Gamebuino META 1.3\nOdroid-GO Arduino ESP32 Odroid-GO 1.0\nThe default toolchain paths are in faur/make/global/sdk.mk and they can be overridden in the application Makefile or globally in ~/.config/faur/sdk.mk. To build for different targets, change include $(FAUR_PATH)/make/default.mk to other files from $(FAUR_PATH)/make.\nLicense\nCopyright 2010-2021 Alex Margarit (alex@alxm.org)\nSource code licensed under GNU GPL 3.0 (file LICENSE)\nOther content licensed under CC BY-NC-ND 4.0 (file media/CC-BY-NC-ND)\nFaur is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. The project is named after the old Romanian word faur, sometimes used in fables to mean wizard blacksmith. \u2692\ufe0f\u2728\nContributing\nThis is a personal framework and playground, and to that end it is a solo project. You are welcome to use it under the terms of the license, but I do not take pull requests to this repo.", "link": "https://github.com/alxm/faur", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "faur is a personal c framework for my video games.\nfeatures include 2d graphics, sound, inputs, state management, ecs model, and utilities to help with data, files, math, memory, strings, time, and more.\nfaur builds native on linux and cross-compiles for web, windows, and some embedded devices. the build system uses gnu make 4.1 and python 3.6 or later.\ndependencies & path setup\n# required\nsudo apt install build-essential git python3 python3-pil\nsudo apt install libsdl2-dev libsdl2-mixer-dev libpng-dev\n# optional\nsudo apt install ffmpeg libsdl1.2-dev libsdl-mixer1.2-dev\n# clone repo to ~/faur\ncd ~\ngit clone git://github.com/alxm/faur.git\n# set faur_path environment var and add tools to path\nexport faur_path=\"$home/faur\"\nexport path=\"$path:$faur_path/bin\"\nhello, world\n$ faur-new hello\n$ -----> tree !!!  hello/\nhello/\n\u251c\u2500\u2500 build/\n\u2502 \u2514\u2500\u2500 make/\n\u2502 \u2514\u2500\u2500 makefile\n\u2514\u2500\u2500 src/\n\u2514\u2500\u2500 main.c\n$ cd hello/build/make/\n$ make run\nyou can move the square with the arrow keys or a controller.\nhello/src/main.c\n#include <faur.h>\nvoid f_main(void)\n{\nstatic struct {\nint x, y;\nfbutton *up, *down, *left, *right;\n} context;\nf_state_init\n{\ncontext.x = f_screen_sizegetwidth() / 2;\ncontext.y = f_screen_sizegetheight() / 2;\ncontext.up = f_button_new();\nf_button_bindkey(context.up, f_key_up);\nf_button_bindbutton(context.up, null, f_button_up);\ncontext.down = f_button_new();\nf_button_bindkey(context.down, f_key_down);\nf_button_bindbutton(context.down, null, f_button_down);\ncontext.left = f_button_new();\nf_button_bindkey(context.left, f_key_left);\nf_button_bindbutton(context.left, null, f_button_left);\ncontext.right = f_button_new();\nf_button_bindkey(context.right, f_key_right);\nf_button_bindbutton(context.right, null, f_button_right);\n}\nf_state_tick\n{\nif(f_button_pressget(context.up)) {\ncontext.y--;\n}\nif(f_button_pressget(context.down)) {\ncontext.y++;\n}\nif(f_button_pressget(context.left)) {\ncontext.x--;\n}\nif(f_button_pressget(context.right)) {\ncontext.x++;\n}\n}\nf_state_draw\n{\nf_color_colorsethex(0xaaff88);\nf_draw_fill();\nf_color_colorsethex(0xffaa44);\nf_draw_rectangle(context.x - 40, context.y - 40, 80, 80);\n}\nf_state_free\n{\nf_button_free(context.up);\nf_button_free(context.down);\nf_button_free(context.left);\nf_button_free(context.right);\n}\n}\nhello/build/make/makefile\nf_config_app_author := <author>\nf_config_app_name := hello\ninclude $(faur_path)/make/default.mk\ncross-compile for other platforms\ni started faur to make games for the linux-based gp2x. these are the supported platforms now:\nplatform toolchain support libraries\ndesktop\nlinux, freebsd os build tools sdl 2.0, sdl_mixer 2.0, libpng 1.6\nwindows mingw-w64 sdl 2.0, sdl_mixer 2.0, libpng 1.6\nweb (wasm) emscripten sdl 2.0, sdl_mixer 2.0, libpng 1.6\nembedded linux\ngp2x, gp2x wiz open2x sdk sdl 1.2, sdl_mixer 1.2, libpng 1.2\ncaanoo gph sdk sdl 1.2, sdl_mixer 1.2, libpng 1.2\nopen pandora pandora sdk sdl 1.2, sdl_mixer 1.2, libpng 1.2\narduino\ngamebuino meta arduino samd gamebuino meta 1.3\nodroid-go arduino esp32 odroid-go 1.0\nthe default toolchain paths are in faur/make/global/sdk.mk and they can be overridden in the application makefile or globally in ~/.config/faur/sdk.mk. to build for different targets, change include $(faur_path)/make/default.mk to other files from $(faur_path)/make.\nlicense\ncopyright 2010-2021 alex margarit (alex@alxm.org)\nsource code licensed under gnu gpl 3.0 (file license)\nother content licensed under cc by-nc-nd 4.0 (file media/cc-by-nc-nd)\nfaur is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. the project is named after the old romanian word faur, sometimes used in fables to mean wizard blacksmith. \u2692\ufe0f\u2728\ncontributing\nthis is a personal framework and playground, and to that end it is a solo project. you are welcome to use it under the terms of the license, but i do not take pull requests to this repo.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000727, "year": null}, {"Unnamed: 0": 2987, "autor": 947, "date": null, "content": "XInput USB Core for Arduino AVR\nThe files in this repository allow you to emulate an Xbox gamepad (XInput) using a USB-capable Arduino microcontroller. Originally forked from the official Arduino AVR core.\nThis is meant to be used in conjunction with the ArduinoXInput library.\nInstallation\n\u2514\u2500\u2500\u2500Arduino Installation\n\u251c\u2500\u2500\u2500drivers\n\u251c\u2500\u2500\u2500examples\n\u251c\u2500\u2500\u2500hardware\n\u2502 \u251c\u2500\u2500\u2500arduino\n\u2502 \u251c\u2500\u2500\u2500tools\n\u2502 \u2514\u2500\u2500\u2500xinput\n\u2502 \u2514\u2500\u2500\u2500avr\n\u2502 \u251c\u2500\u2500\u2500bootloaders\n\u2502 \u251c\u2500\u2500\u2500cores\n\u2502 \u251c\u2500\u2500\u2500libraries\n\u2502 \u2514\u2500\u2500\u2500variants\n\u251c\u2500\u2500\u2500java\n\u251c\u2500\u2500\u2500lib\n\u251c\u2500\u2500\u2500libraries\n\u251c\u2500\u2500\u2500reference\n\u251c\u2500\u2500\u2500tools\n\u2514\u2500\u2500\u2500tools-builder\nTo install, download the latest release to your PC and navigate to the directory containing your Arduino installation. Open up the 'hardware' folder and extract the contents of the .zip file into this directory. You should have a new 'xinput' folder with an 'avr' folder inside of it containing the files from this repository. This should match the tree view above. If you clone the repository, you must create these parent folders yourself.\nAfter you have copied the files restart the Arduino IDE. If the XInput AVR core is installed correctly, you should see a new collection of \"XInput AVR Boards\" in the Tools -> Boards menu.\nTo uninstall, delete the 'xinput' folder in the 'hardware' directory, and then restart the Arduino IDE.\nUpload Warning and Instructions\nDue to the nature of how the XInput USB mode works, Arduinos that have XInput sketches on them will not automatically reset when programmed by the IDE! You will need to reset the board by hand every time you upload new code.\nYou can ignore this section if you're using an external programmer.\nHow to Upload\nConnect the board to your computer using a USB cable, and make sure you have the proper board selected in the IDE's 'boards' menu (with or without XInput). If the board already has an XInput sketch on it, you do not need to select a serial port. You should also turn on 'verbose output' for uploading in the Arduino IDE's preferences (File -> Preferences). This makes it easier to time the manual reset and see if the upload succeeded.\nLastly, you need to know where the 'reset' button is on your Arduino. If your board does not have a 'reset' button, you can wire your own by momentarily connecting the 'reset' pin to ground.\nTo upload to the board:\nPress the 'Upload' button in the IDE\nWait until the status bar says \"Uploading...\"\nPress the reset button\nIf you timed it properly, the board should reset to the bootloader and the upload should begin. AVRDUDE will do its thing and you should see avrdude done. Thank you. near the bottom of the output window.\nNote that the IDE may say that it \"Couldn't find a Board on the selected port\" even if the upload succeeded. This is why it's important to turn on the verbose uploading output - look for the avrdude message.\nDo not upload XInput sketches to your Arduino unless you know how to reset it! Otherwise you will not be able to program it anymore and you'll have to remove the XInput sketch by flashing the board with an external programmer.\nSupported Boards\nAdafruit Circuit Playground 32u4\nArduino Esplora\nArduino Industrial 101\nArduino Leonardo\nArduino Leonardo ETH\nArduino Micro\nArduino Robot Control / Motor\nArduino Y\u00fan\nArduino Y\u00fan Mini\nLilyPad Arduino USB\nLinino One\nUnfortunately boards such as the Uno, Nano, or Mega that do not have native USB support will not work.\nLimitations\nNo Console Support\nThis will not enable you to use your Arduino with an Xbox console! Genuine controllers use a dedicated hardware security chip that handshakes with the console. The Arduinos do not have this chip, and its security method has not been (openly) broken.\nNo Commercial Use\nThese board definitions make use of Microsoft's VID and PID in order to latch on to the PC driver. As such this is strictly for educational or development use by non-commercial entities.\nLicense\nThe Arduino core files are licensed under the terms of the GNU Lesser General Public License (LGPL) version 2.1. Modifications are released under these same terms. See the LICENSE file for more information.\nNewly contributed files for XInput support are licensed under the terms of the more permissive MIT license.", "link": "https://github.com/dmadison/ArduinoXInput_AVR", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "tree", "selectorShort": "tree", "MarkedSent": "xinput usb core for arduino avr\nthe files in this repository allow you to emulate an xbox gamepad (xinput) using a usb-capable arduino microcontroller. originally forked from the official arduino avr core.\nthis is meant to be used in conjunction with the arduinoxinput library.\ninstallation\n\u2514\u2500\u2500\u2500arduino installation\n\u251c\u2500\u2500\u2500drivers\n\u251c\u2500\u2500\u2500examples\n\u251c\u2500\u2500\u2500hardware\n\u2502 \u251c\u2500\u2500\u2500arduino\n\u2502 \u251c\u2500\u2500\u2500tools\n\u2502 \u2514\u2500\u2500\u2500xinput\n\u2502 \u2514\u2500\u2500\u2500avr\n\u2502 \u251c\u2500\u2500\u2500bootloaders\n\u2502 \u251c\u2500\u2500\u2500cores\n\u2502 \u251c\u2500\u2500\u2500libraries\n\u2502 \u2514\u2500\u2500\u2500variants\n\u251c\u2500\u2500\u2500java\n\u251c\u2500\u2500\u2500lib\n\u251c\u2500\u2500\u2500libraries\n\u251c\u2500\u2500\u2500reference\n\u251c\u2500\u2500\u2500tools\n\u2514\u2500\u2500\u2500tools-builder\nto install, download the latest release to your pc and navigate to the directory containing your arduino installation. open up the 'hardware' folder and extract the contents of the .zip file into this directory. you should have a new 'xinput' folder with an 'avr' folder inside of it containing the files from this repository. this should match the -----> tree !!!  view above. if you clone the repository, you must create these parent folders yourself.\nafter you have copied the files restart the arduino ide. if the xinput avr core is installed correctly, you should see a new collection of \"xinput avr boards\" in the tools -> boards menu.\nto uninstall, delete the 'xinput' folder in the 'hardware' directory, and then restart the arduino ide.\nupload warning and instructions\ndue to the nature of how the xinput usb mode works, arduinos that have xinput sketches on them will not automatically reset when programmed by the ide! you will need to reset the board by hand every time you upload new code.\nyou can ignore this section if you're using an external programmer.\nhow to upload\nconnect the board to your computer using a usb cable, and make sure you have the proper board selected in the ide's 'boards' menu (with or without xinput). if the board already has an xinput sketch on it, you do not need to select a serial port. you should also turn on 'verbose output' for uploading in the arduino ide's preferences (file -> preferences). this makes it easier to time the manual reset and see if the upload succeeded.\nlastly, you need to know where the 'reset' button is on your arduino. if your board does not have a 'reset' button, you can wire your own by momentarily connecting the 'reset' pin to ground.\nto upload to the board:\npress the 'upload' button in the ide\nwait until the status bar says \"uploading...\"\npress the reset button\nif you timed it properly, the board should reset to the bootloader and the upload should begin. avrdude will do its thing and you should see avrdude done. thank you. near the bottom of the output window.\nnote that the ide may say that it \"couldn't find a board on the selected port\" even if the upload succeeded. this is why it's important to turn on the verbose uploading output - look for the avrdude message.\ndo not upload xinput sketches to your arduino unless you know how to reset it! otherwise you will not be able to program it anymore and you'll have to remove the xinput sketch by flashing the board with an external programmer.\nsupported boards\nadafruit circuit playground 32u4\narduino esplora\narduino industrial 101\narduino leonardo\narduino leonardo eth\narduino micro\narduino robot control / motor\narduino y\u00fan\narduino y\u00fan mini\nlilypad arduino usb\nlinino one\nunfortunately boards such as the uno, nano, or mega that do not have native usb support will not work.\nlimitations\nno console support\nthis will not enable you to use your arduino with an xbox console! genuine controllers use a dedicated hardware security chip that handshakes with the console. the arduinos do not have this chip, and its security method has not been (openly) broken.\nno commercial use\nthese board definitions make use of microsoft's vid and pid in order to latch on to the pc driver. as such this is strictly for educational or development use by non-commercial entities.\nlicense\nthe arduino core files are licensed under the terms of the gnu lesser general public license (lgpl) version 2.1. modifications are released under these same terms. see the license file for more information.\nnewly contributed files for xinput support are licensed under the terms of the more permissive mit license.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000947, "year": null}], "name": "treearduino"}
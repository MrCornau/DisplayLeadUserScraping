{"interestingcomments": [{"Unnamed: 0": 2337, "autor": 297, "date": null, "content": "arduino-plotter\nPlotter is an Arduino library for easy graphing on host computer via serial communication\nFeatures:\nContinuous multi-variable plots against time\n2-variable \"x\" vs \"y\" plots\nDisplay multiple graphs within single resizable window\nSupport for any data type that can be cast to a double\nSimply pass a reference to your variables when the graph is added, no need to update each value explicitly\nControl number of data points displayed on each graph\nAuto-scaling to fit all data on graph\nConfigurable line color per variable\nStand-alone listener application, written with Processing, is provided\nExtremely easy usage:\n#include \"Plotter.h\"\ndouble x; // global variables\nPlotter p; // create plotter\nvoid setup()\n{\np.Begin(); // start plotter\np.AddTimeGraph( \"Some title of a graph\", 1500, \"label for x\", x ); // add any graphs you want\n}\nvoid loop()\n{\nx = 10*sin( 2.0*PI*( millis() / 5000.0 ) ); // update your variables like usual\np.Plot(); // plot all current data -- usually called within loop()\n}\nSee the Wiki for more information:\nHome\nQuickstart\nDocumentation", "link": "https://github.com/devinaconley/arduino-plotter", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "plot", "selectorShort": "plot", "MarkedSent": "arduino-plotter\nplotter is an arduino library for easy graphing on host computer via serial communication\nfeatures:\ncontinuous multi-variable plots against time\n2-variable \"x\" vs \"y\" plots\ndisplay multiple graphs within single resizable window\nsupport for any data type that can be cast to a double\nsimply pass a reference to your variables when the graph is added, no need to update each value explicitly\ncontrol number of data points displayed on each graph\nauto-scaling to fit all data on graph\nconfigurable line color per variable\nstand-alone listener application, written with processing, is provided\nextremely easy usage:\n#include \"plotter.h\"\ndouble x; // global variables\nplotter p; // create plotter\nvoid setup()\n{\np.begin(); // start plotter\np.addtimegraph( \"some title of a graph\", 1500, \"label for x\", x ); // add any graphs you want\n}\nvoid loop()\n{\nx = 10*sin( 2.0*pi*( millis() / 5000.0 ) ); // update your variables like usual\np.plot(); // -----> plot !!!  all current data -- usually called within loop()\n}\nsee the wiki for more information:\nhome\nquickstart\ndocumentation", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000297, "year": null}, {"Unnamed: 0": 2486, "autor": 446, "date": null, "content": "Software Oscilloscope\nA python project which takes in data from any stream(Serial port, TCP socket or any generic stream) and plots it in real time using PyQtGraph. The stream must implement open(), close() and readline() methods to work with the package.\nInstallation\nWorks with Python 2/3\nClone the repo or download the zip\nInstall VC++ for Python from here\ncd to the folder\nrun pip -install -r \"requirements.txt\"\nDependencies\npyqtgraph\nPySide or PyQt 4.8+\nnumpy\npySerial\nUsage\nThe stream has to implement open(), close() and readline() methods\nData from multiple sources has to be space separated and each reading must be on a new line\nsource1_value1 source2_value1\nsource1_value2 source2_value2\nand so on\nX/Y axis limits, Frame interval, Autoscaling(True by default) and the number of lines(1 by default) to read can be specified via kwargs.\n'''\nUses the SocketPlot-Test example to plot a sine wave.\nRun SocketPlot-Test.py on a different console window\n'''\n>>>from SoftOscilloscope import SocketClientPlot\n>>>plot = SocketClientPlot('localhost', 5000)\n>>>plot.start()\n'''\nExample for serial plots\n'''\n>>>from SoftOscilloscope import SerialPlot\n>>>plot = SerialPlot('COM_PORT_NUMBER', BAUD_RATE)\n>>>plot.start()\n'''\nTakes a generic stream and sets custom parameters\n'''\n>>>from SoftOscilloscope import GenericPlot\n>>>plot = GenericPlot(\nmyStream,\nxlim=(-100,100),\nylim=(-50, 50),\ninterval=1,\nautoscale=False,\nread_size=1)\n>>>plot.start()\nDemos\nPlotting x,y,z data from a 9DOF IMU over a serial port.\nContributions\nIf you want to add features, improve them, or report issues, feel free to send a pull request!", "link": "https://github.com/Suyash458/SoftwareOscilloscope", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "plot", "selectorShort": "plot", "MarkedSent": "software oscilloscope\na python project which takes in data from any stream(serial port, tcp socket or any generic stream) and plots it in real time using pyqtgraph. the stream must implement open(), close() and readline() methods to work with the package.\ninstallation\nworks with python 2/3\nclone the repo or download the zip\ninstall vc++ for python from here\ncd to the folder\nrun pip -install -r \"requirements.txt\"\ndependencies\npyqtgraph\npyside or pyqt 4.8+\nnumpy\npyserial\nusage\nthe stream has to implement open(), close() and readline() methods\ndata from multiple sources has to be space separated and each reading must be on a new line\nsource1_value1 source2_value1\nsource1_value2 source2_value2\nand so on\nx/y axis limits, frame interval, autoscaling(true by default) and the number of lines(1 by default) to read can be specified via kwargs.\n'''\nuses the socketplot-test example to -----> plot !!!  a sine wave.\nrun socketplot-test.py on a different console window\n'''\n>>>from softoscilloscope import socketclientplot\n>>>plot = socketclientplot('localhost', 5000)\n>>>plot.start()\n'''\nexample for serial plots\n'''\n>>>from softoscilloscope import serialplot\n>>>plot = serialplot('com_port_number', baud_rate)\n>>>plot.start()\n'''\ntakes a generic stream and sets custom parameters\n'''\n>>>from softoscilloscope import genericplot\n>>>plot = genericplot(\nmystream,\nxlim=(-100,100),\nylim=(-50, 50),\ninterval=1,\nautoscale=false,\nread_size=1)\n>>>plot.start()\ndemos\nplotting x,y,z data from a 9dof imu over a serial port.\ncontributions\nif you want to add features, improve them, or report issues, feel free to send a pull request!", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000446, "year": null}, {"Unnamed: 0": 2551, "autor": 511, "date": null, "content": "Arduino Projects\nThis is a collection of Arduino projects that don't really deserve their own repository.\nNone of them are really maintained. Feel free to poke around and create pull requests if you have some improvment.\nProjects\nGuitar\nProject type: Arduino IDE (.ino)\nSimple \"guitar\" where I used a distance sensor to map distance to a tone and play it through a piezo. You can read more about this project on my blog.\nParty Glasses\nProject type: Arduino IDE (.ino)\nTwo neopixel rings, attached to a pair of sunglasses. Blog post\nSimon Says\nProject type: Arduino IDE (.ino)\nA simon says implemented on an Arduino.\nPushup counter\nProject type: PlatformIO (.cpp)\nA box to which I mounted a 4-digit LCD display and a distance sensor to.\nMini Instagram Stats\nProject type: Particle Photon (.ino)\nRGB led that indicates when you get a new follower or someone likes your posts on Instagram. A two-part project with a webserver in Node.js and a Photon communicating with it.\nPong\nProject type: PlatformIO (.cpp)\nA simple implementation of Pong for two players controlling the paddles with potetiometers. Using the TVout-library to display the game on a TV.\nPixel-Painter\nProject type: Arduino IDE (.ino) and Processing (.pde)\nPaint an image with a NeoPixel strip and a camera with a long exposure.\nDisco Keyboard\nProject type: Arduino IDE (.ino) and Processing (.pde)\nTurn your keyboard into a sparkling disco show.\nRadar\nProject type: Arduino IDE (.ino) and Processing\nMake a radar using Arduino, plot your surroundings using processing.\nMusic Controller\nProject type: Arduino IDE (.ino) and a Cocoa app\nControl Spotify or iTunes via an Arduino interface with an LCD displaying the current song.\nNeopixels reacting to audio\nProject type: Arduino IDE (.ino) and Processing (.pde)\nHave neopixels light up with the rythm of music!\nClap-Clap\nToggle lights on/off with claps!\nMatrix Painter\nProject type: Arduino IDE (.ino), Processing (.pde) and iOS\nPaint those great 8x8 LED Matrices MAX7219 with our mouse - OR go one step further and use your iOS device!\nNeopixel 7-Segment Display\nProject type: Arduino IDE (.ino)\nCreate a 7-Segment Display with Neopixels\nHappy New Year\nProject type: Arduino IDE (.ino)\nA simple animation on MAX7219 I used in the Intagram post https://www.instagram.com/p/BdVzRKtln6V\nArduino PC JoyStick\nProject type: Arduino IDE (.ino), Python (.py)\nTurns an Arduino JoyStick shield in to a PC game pad or second keyboard/mouse.\nBreakoutClone\nProject type: Arduboy (Arduino IDE (.ino))\nA simple proof of concept of the game breakout for the Arduboy\nMorse Keyboard\nProject type: Arduino IDE (.ino)\nTurns your Arduino UNO in to a one-button keyboard using morse code.\nhue-motion\nProject type: Arduino IDE (.ino)\nDetecting motion with a PIR sensor, a NodeMCU communicates with a Philips Hue bridge to toggle the lights on or off (like the philips motions sensor).\nclock-phone\nProject type: Arduino IDE (.ino)\nRepurposing an old phone in to a time telling machine using Arduino Nano 33 IOT and DFPlayer Mini.", "link": "https://github.com/mattiasjahnke/arduino-projects", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "plot", "selectorShort": "plot", "MarkedSent": "arduino projects\nthis is a collection of arduino projects that don't really deserve their own repository.\nnone of them are really maintained. feel free to poke around and create pull requests if you have some improvment.\nprojects\nguitar\nproject type: arduino ide (.ino)\nsimple \"guitar\" where i used a distance sensor to map distance to a tone and play it through a piezo. you can read more about this project on my blog.\nparty glasses\nproject type: arduino ide (.ino)\ntwo neopixel rings, attached to a pair of sunglasses. blog post\nsimon says\nproject type: arduino ide (.ino)\na simon says implemented on an arduino.\npushup counter\nproject type: platformio (.cpp)\na box to which i mounted a 4-digit lcd display and a distance sensor to.\nmini instagram stats\nproject type: particle photon (.ino)\nrgb led that indicates when you get a new follower or someone likes your posts on instagram. a two-part project with a webserver in node.js and a photon communicating with it.\npong\nproject type: platformio (.cpp)\na simple implementation of pong for two players controlling the paddles with potetiometers. using the tvout-library to display the game on a tv.\npixel-painter\nproject type: arduino ide (.ino) and processing (.pde)\npaint an image with a neopixel strip and a camera with a long exposure.\ndisco keyboard\nproject type: arduino ide (.ino) and processing (.pde)\nturn your keyboard into a sparkling disco show.\nradar\nproject type: arduino ide (.ino) and processing\nmake a radar using arduino, -----> plot !!!  your surroundings using processing.\nmusic controller\nproject type: arduino ide (.ino) and a cocoa app\ncontrol spotify or itunes via an arduino interface with an lcd displaying the current song.\nneopixels reacting to audio\nproject type: arduino ide (.ino) and processing (.pde)\nhave neopixels light up with the rythm of music!\nclap-clap\ntoggle lights on/off with claps!\nmatrix painter\nproject type: arduino ide (.ino), processing (.pde) and ios\npaint those great 8x8 led matrices max7219 with our mouse - or go one step further and use your ios device!\nneopixel 7-segment display\nproject type: arduino ide (.ino)\ncreate a 7-segment display with neopixels\nhappy new year\nproject type: arduino ide (.ino)\na simple animation on max7219 i used in the intagram post https://www.instagram.com/p/bdvzrktln6v\narduino pc joystick\nproject type: arduino ide (.ino), python (.py)\nturns an arduino joystick shield in to a pc game pad or second keyboard/mouse.\nbreakoutclone\nproject type: arduboy (arduino ide (.ino))\na simple proof of concept of the game breakout for the arduboy\nmorse keyboard\nproject type: arduino ide (.ino)\nturns your arduino uno in to a one-button keyboard using morse code.\nhue-motion\nproject type: arduino ide (.ino)\ndetecting motion with a pir sensor, a nodemcu communicates with a philips hue bridge to toggle the lights on or off (like the philips motions sensor).\nclock-phone\nproject type: arduino ide (.ino)\nrepurposing an old phone in to a time telling machine using arduino nano 33 iot and dfplayer mini.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000511, "year": null}, {"Unnamed: 0": 2631, "autor": 591, "date": null, "content": "Weather Stations\nArduino Uno, 433MhzRx and Oregon Scientific WMR86 Weather Station\nThis project allows the 433MHz signals from an Oregon Scientific WMR86 weather station to be intercepted and decoded into simple decimal values using an Arduino Uno. The values for Wind Direction, Wind Speed, Temperature, Humidity, UV Light and Rainfall are then sent via the USB/Serial port on the Arduino to the host computer. In my case I use a Python program to interpret this CSV formatted string of characters and plot the above parameters for display on my website http://www.laketyersbeach.net.au/weather.html (Please note the DHT22 Humidity/Temperature sensor on the Arduino shield is not used in the my final data stream, but is decoded in the software, and so is the temperature read from the BMP05 air pressure detector. The externally mounted OS Temperature/Humidity sensor is used in my final data string. This can be modified to suit your own purposes).\nThe hardware\nThe Arduino listens continually for the three WMR86 sensor's broadcasts (the UV Light sensor must be purchased seperately) and merges them every minute for an output of a CSV string. There are three transmitters in the WMR86 package, Wind Direction+Wind Speed (average and gusts), Temperature+Humidity, and Rainfall (cumulative total and rate). They each have different periods between transmission eg Wind every 14 Seconds, Temp/Hum and Rainfall at longer periods. This does cause overlap of sensor transmissions and inevitable corruption of some packets, however the protocol does have a simple arithmetic checksum based on nybbles that helps eliminate most bad data. Admittedly the chance of substitution errors causing bad data to go un-detected is much higher than if a higher bit CRC based on a polynomial process was used. Range validation would be necessary (in the Python or Arduino) to check if the resulting readings were sensible to improve reliability. This program reports every minute for all three sensors whether a good packet has been received within that minute or not, so the Python program can sum the good and bad packets each minute and report the relative numbers each week in an email.\nThe Wiring: A generic prototyping shield was used.\nManchester Protocol\nThe Ardunio algorithm to decode the Manchester protocol uses timed delays to sample the waveform from the 433MHz Rx and not interrupts and direct measurement of waveform transitions. This has a number of implications. The main one is that Arduino is continually sampling and analysing the incoming waveform. As it is a dedicated processor in this application and has no other function, this is not a problem. The benefit is that it does simplify the reception and analysis of the waveforms. The simple decoding strategy should also be worth studying by anyone else attempting to leverage other systems that use Manchester encoding. To that end a fairly lengthy explanation is offered below.\nThe Manchester protocol is a bias neutral protocol where each bit is composed of a high and low signal of equal length (or close to it). This means that a transmitter can be totally keyed off and on (ie the 433MHz signal is not partially modulated, but is either fully transmitting or 'silent')and no matter what sequences of data, 1's and 0's, are transmitted, on average the Tx signal will consequently be on for the same time as it is off. This means the switching point, or bias level, for the receiver amplifier remains steady. A data bit in a Manchester waveform always has a high and low signal component for encoding both 1's and 0's. So a Bit Waveform for a Data 1 is a high signal followed by a low signal (hi->lo), and a Bit Waveform for a Data 0 is a low signal followed by a high signal (lo->hi). For the OS Weather station each high and low signal duration are both about 430uS. So a full Bit Waveform will last about 860uS. (As will be seen later, the tolerance for decoding these timings is quite wide).\nThe cheap 433MHz Rx's available have a simple Automatic Gain Control and Bias Detection built in. The AGC allows the sensitivity to be maximised with low signals, and adjusted back when a stronger 433MHz signal is received. The Bias Detection allows the average of the output signal voltage to be determined and applied to one half of a comparator, the other comparator input has the received signal. With Manchester protocol the on/off ratio is equal, so the Bias Detection will be at the average voltage, ie approximately half way, consequently the transitions of the signal from on to off and back again, can produce quite clean, symmetrical logic signals with simple circuitry. This Manchester decoding program relies on the timing of transitions, rather than the exact shape of the waveform (ie again it does not have to be a very clean square wave shape to work, as long as the transitions are accurate).\nIn other words, the decoding program needs to be able to determine whether it has seen a 430uS 'no signal' followed by a 430uS 'on signal' and so has received a 0, OR has received a 430uS 'on signal\" followed by a 430uS 'no signal' and so received a 1. 'on signal' makes the Rx amplifier output go 'hi' and 'no signal' makes the Rx output go 'lo'.\nHow is this decoded?\nThe first very important prior knowledge to have is which of the two polarity conventions for Manchester encoding this system uses. Arguments are put forward for both possibilities as being correct, but either polarity works as good as the other, and with a simple audio sampler, such as Audacity, is simple to work out. The transition polarity used by OS is that a Data 1 is hi->lo and Data 0 is lo->hi.\nHowever any hi->lo transition could be either the middle of a Data 1 Bit Waveform and mean a 1 has been sent, or possibly just the hi->lo transition between two Bit Waveforms, and as such not indicate anything. Similarly any lo->hi could indicate the middle of a Data 0 Bit, or again just a meaningless transition between two Bit Waveforms. The following diagram illustrates the two Bit Waveforms. When these are connected up into a bit stream, then the red dots may or may not require transitions to connect them for the Bit Waveforms to reflect the data bits. A simple example is provided underneath with the 4 possible bit sequences (10,00,01,11) shown and the incidental transitions marked in blue. If you are writing a Manchester Encoded transmitter then this is all you need to know to get started.\nDiag 1\nCuriously a long string of Data 1's will have the same looking waveform as a long string of Data 0's. Whether they are 1's or 0's depends on where we begin to analyse, we would need some sort of marker, or unambiguous beginning point. And also surprising to begin with, is the sequences of data bits 1 to 0, and 0 to 1, do not have any signal change between Bit Waveforms. More information on that later...\nCritically the only guaranteed meaningful regular transition of states occurs in the middle of the Bit Waveform. Consequently is essential to concentrate the decoding algorithm around the center of the Bit Waveform to keep it properly synchronised.\nRF practicalities...\nPart of the practical application of the Manchester protocol combined with simple 433MHz Tx/Rx combo's is to use a header sequence of bits, usually 30 or so 1's. This quickly stablizes the Rx AGC and establishes the Bias Detection point so the simple 433MHz Rx has a good chance of settling down and producing a clean logic waveform after say 10 on/off transmissions. The decoding program can then sample the Bit Waveform by synchronising (ie looping and waiting) the program to an hi->lo transition, which is the midway point of a Bit Waveform for a 1. This polarity is how it works for the OS protocol, hi->lo==1, lo->hi==0 (Wikipedia says the opposite polarity convention is also used by other systems, and both are just as valid).\nGraphic 1: The AGC is stabilising fairly quickly here. (Audacity Sample)\nThis Diagram 2 below is showing a stream on 1's as the header. The algorithm is expecting a stream of Data 1's and to begin with, and is looking for any hi to lo transition on the Rx and assuming it is the middle of a Data 1 bit Waveform. After detecting any hi->lo transition it begins to check the subsequent waveform. Graphic 1 is sections A,B&C in Diagram 2.\nDiag 2\nDiagram 2 illustrates the process of detecting a signal and locking into the data in the packet. From the lefthand side, A is showing static, or noise, and when a signal begins in B the AGC on the 433MHz receiver is stabilizing. Note that early on the program will try to lock onto the negative going edge as shown with the downward black arrow at the start of Phase C. Phase C is the stream of 1's known as the header. Here I have illustrated that receiving fifteen 1's will indicate we have a valid header. Phase D indicates that we have more header bits than we need (this allows for some drift about the AGC starting point). So any excess 1's are then dumped until the bit pattern changes, when at Phase E the bit pattern for 0 arrives. From then on, Phase F (the remainder of the packet, NB not all shown) any number of data bits, 1&0's, can be received. Sometimes the E&F Phase are within the Byte pattern, and sometimes the start bit, E is excluded and it just flags the start, and the bytes begin at Phase F.\nExtracting data from the bit stream\nHow does it know they are properly formed and timed Bit Waveforms? (Please refer to diagram 3 below, NB 7 Bit Waveforms are shown, only alternative ones are labelled). To filter out noise, the input is sampled until a hi->lo event is detected eg at (B) and then again the program re-samples the Rx output about a 1/4 of a Bit Waveform later at (E), to see if it is still lo. If is lo (as the diagram shows) then it is possibly a genuine middle of a 1 Bit Waveform, however if it is not a lo then it was not a genuine hi->lo middle of a 1 Bit Waveform, and the algorithm begins the search for another hi->lo transition all over again. However if this preliminary test is true, it has possibly sampled a midpoint of a 1, so it waits for another half a Bit Waveform (F). This timing is actually 1/4 of the way into the next Bit Waveform, and because we know we are looking for another 1, then the signal should have gone hi by then. If is not hi, then the original sample, that was possibly the mid point of a 1 Bit Waveform is rejected, as overall, it has not followed the 'Bit Waveform rules', and the search (looping) for then next hi->lo transition begins at the start, all over again. Here is a diagram to highlight the previous ideas.\nDiag 3\nThe pink lines are the signal arriving from the 433MHzRx. The long vertical blue lines (eg at A & C) are indicating the start and end of some Bit Waveforms. These are partially covered by the pink signal trace if they coincide. This diagram show 7 bit patterns. B is positioned at the middle of a Bit Waveform, and these are also indicated by the M's. The data contained in each bit pattern is determined by the direction of the transition at M, the middle of the Bit Waveform, and not by what happens at the finish and start of each Bit Waveform.\nThe Diagram 3 shows the four possible bit sequences, 0->1, 1->0, 1->1, 0->0 and what happens in between each combinations of Bit Waveforms (marked by the orange #1-7 Bit Waveforms).\nThis simple filtering (delay-check-delay-check etc) allows the program to detect and count the number of successfully detected Data 1's received, and once a minimum has been counted in sequence, then the program can assume it has a valid header coming in. This sampling, by looking for transitions and waiting periods of time to sample, is also applied equally to all subsequent 1's and 0's received and can eliminate badly formed packets if the waveform pattern of the Manchester encoding is not followed (say due to interference or a weak signal). Hence it forms a simple but effective digital filter that greatly reduces spurious results from random or unwanted 433MHz signals.\nThe transitions at the orange 1-7 do not carry data, but if transitions do occur they are to make sure the subsequent transitions that must occur at the Mid points match the data bit stream correctly (you can think of 1-7 setting up the data transition for the next Mid). The critical aspect of this processing is that this program is always syncing to the Mid point of the Bit Waveform, where the critical data indicating transitions occur. This makes the decoding of the bit stream very tolerant to any errors (data rate wow or flutter in old terms) in sampling the waveforms. This allows the calculations between receiving bits to take different lengths of time (after the middle M of the Bit Waveform) and still not effect the reliability. The delays can be altered plus or minus 15% (or more) and still get reliable reception.\nThe synchronising 0 bit and may or may not be included in the byte boundaries. Some implementations send a single 0 bit then all the bytes of information, whereas the OS example we are dealing with here just makes sure the first bit in the first byte sent, is always a 0.\nCapturing the data\nOnce this \"0\" is detected then the data stream can be considered synchronised with the detector. This program to decode the Oregon Scientific Weather Station's sensors then decodes a sequence of received bytes that have data encoded in both straight binary and other times, BCD. The number of bytes per packet for each transmitter can also vary. The program must be able to recognise each transmitter early and change the number of subsequent bytes expected for each type. To do this the program begins downloading all bytes (more on that later) and identifies the ID bytes within the first 2 bytes, and when a particular sensor is detected it immediately sets the exact number of bytes expected. So temp/Humidity decoding requires 10 bytes (but only uses 9), Anemometer decoding requires 10 bytes and uses them all, and the Rainfall sensor decoding requires 11 bytes but only needs the four most significant bits of the last byte. If 11 bytes were accepted all the time, the Rainfall would work, but the other two would fail as their signals return to random noise after 10 bytes and this would cause them to be rejected.\nOnce a data packet is received it is given a checksum check before being declared valid. We now need to diverge, and return back to the way the bits arrive in the data stream and how they are best stored. The easiest way to explain this is to give an example. Let's number the raw Rf incoming bits in order, zero arrives first -\n0 1 2 3 4 5 6 7 , and this how it is best to rearrange those bits for OS comptibility\n3 2 1 0 7 6 5 4 , so the first bit 0 is actually moved to the fourth position, the next bit 1 is moved to the third position, and so on, and, as this wraps around, all the incoming bits are stored in new positions in a temporary byte, and then stacked into a byte array. It essentially reverses the place values inside each nybble. This properly reflects the environmental values sampled.\nWhy Oregon Scientific chose this rearrangement is best left up to them to explain, but applying this swapping of positions makes all the data in the stored bytes array so much more logical as well. Binary numbers are found in the correct ascending order etc. Plus when it comes to the Checksum, it is also simpler to calculate as well. Take each 4 bit nybble in the data packet (excluding the checksum byte) and add them up as an 8 bit result. This will result in a byte that can be compared to the last byte in the packet, the checksum byte. The number of nybbles for Temp/Humidity is 16, Anemometer 18, and rainfall 19 (NB rainfall Check Sum byte, is made up of nybbles 20 and 21, ie it bridges the byte boundary).\nProcessing and exporting the data\nOnce the bits and bytes are stored in this fashion then the checksum becomes trivial, just add up the nybbles and compare to the checksum byte. Reject any packet that does not workout. A simple checksum like this is prone to substitution errors getting through undetected (ie one byte has an error bit, but is balanced out by an inverted error bit in another byte with the same place value. Cyclic redundancy methods for checking data validity are much more robust than the simple arithmetic checksums, but they are not used on the OS Sensors. However by the time the two bytes for the sensor type ID, and the rolling ID code for a particular sensor are put aside, the critical data that changes is down to 5-7 bytes, and probably the checksum for such a small sample is quite acceptable (though if you intend to use any of these sensors for mission critical stuff you may like to disagree with that opinion). Fortunately for me it was easy to program.\nOnce the bytes for a particular valid packet are stored in the array, they are processed. Some have conversion factors applied, such as binary weighted data for Rain is turned into floating point decimals, and the Anemometer wind speed is converted from metres per second to kilometers per hour. Others such as relative Humidity are provided directly in two BCD characters. Eventually a selection of the numerical data is formatted into ASCII values in a CSV string and sent out via the serial port (over the USB connection). The program has a 1 second interrupt that is used to to send the CSV string every 60 seconds. My Python program on the www server then further processes this string into averages and graphs etc\nBefore any CSV is sent though, this program checks that it has received a valid sample from each of the three sensors, and only begins sending CSV's when Therm/Hum, Anemometer, UV and Rainfall have all been logged in for valid values. This avoids some values being valid and other being at zero at start up.\nThis description should give you a good idea of how the OS V3.0 protocol works and how my program tackles decoding that protocol. It is not very sophisticated, when it is all shown now, but was quite a headache to work through originally. The Oregon Scientific Sensors are a good balance of quality engineering, accessible protocols and reasonable price. Really getting a grip on the Manchester protocol was been a major hurdle, but now is well under control. I am hoping my program and this presentation above will help others tackle this protocol in their own projects.\nhttp://au.oregonscientific.com/ WMR86 to get your own :-)\nManchester Debugger\nThere is now a support Debug Program you can use to develop your own applications in this repository. Edit three values, recipe like, and you could be receiving Manchester encoded bytes in next to no time. Then over to you! Check it out.\nI hope you enjoy using them as much as I do, cheers, Rob\nAcknowledgements: There are many people, and other publications, I have referenced that have assisted greatly in arriving at this solution and these are listed in the documentation of this program, and explanations given to where they are relevant.\nWeather Station Extension\nExtension of the Project\nSeveral features became desirable after the original system had been running for several years. The main concern was a lack of Battery Level indicators and also no direct feedback from the Arduino module of the signals being received. The solution was tackled in two ways, but involving similar parts of the program.\nBattery Levels\nThe Battery Levels were a harder one to crack. I checked the WMR86 manual for mention of a battery level indicator and also checked the LCD screen supplied with it for any indicators that referred to battery levels. I could not find any. So I devised this strategy. Should any sensor not be logged within a minute (ie between sending strings of data to the WWW server) then a number is incremented for that Sensor. As soon as that sensor is detected the number is reset to Zero. However if the sensor is not detected for 20 minutes then a flag bit is set for that Sensor. This \"detection\" number is sent to the WWW server along with all the other data every minute. If it remains 0 then the sensors are OK, if it is non-zero, then it means one of the three sensors have experienced a \"continuous down time\" of at least 20 minutes. The WWW server can check this and send out an Email at midnight of that day warning of which sensor(s) have been missed. However the warning could arise for a number of reasons, the first obvious one is the batteries are going flat and the second is that something maybe effecting either the transmitter or receiver. Eg the Antenna may have changed position on the Rx and suddenly 2 outof the three are being received. Or maybe some object has been placed bewteen the Tx and Rx and that has knocked out the signal. However, just because the signal drops out it may not be because of the Batteries. The system should be sensitive enough to warn of early stages of battery failure. Even if it begins by small periods of time overnight in the cool night air.\nStatus Indicator\nThe RGB LED should give a quick indication if an antenna position change for example is still allowing the sensors to be received. An RGB LED was added to the board to indicate which sensor transmitter was detected. By combining Red, Blue and/or Green I could easily produce 8 recognisable states from the LED. Simply observing the board would indicate that the different sensors were being logged. This gave a quick indication, for example after a restart that the Arduino was functioning properly, and so were the 4 Oregon sensors\nColour coding was:\nRed = Temperature and Humidity\nGreen = Wind Direction and Speed\nBlue = Rain Gauge\nYellow = UV Light Sensor\nPurple = Experimental\nRGB Status LED\nSoftware Version\nThe version to use these features is MainWeather_09.ino. Please note the order of the sensors in the output string has also been changed. So if you have a system reading this string and processing it from the previous version you will have to alter it as well to use this program as it is.", "link": "https://github.com/robwlakes/ArduinoWeatherOS", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "plot", "selectorShort": "plot", "MarkedSent": "weather stations\narduino uno, 433mhzrx and oregon scientific wmr86 weather station\nthis project allows the 433mhz signals from an oregon scientific wmr86 weather station to be intercepted and decoded into simple decimal values using an arduino uno. the values for wind direction, wind speed, temperature, humidity, uv light and rainfall are then sent via the usb/serial port on the arduino to the host computer. in my case i use a python program to interpret this csv formatted string of characters and -----> plot !!!  the above parameters for display on my website http://www.laketyersbeach.net.au/weather.html (please note the dht22 humidity/temperature sensor on the arduino shield is not used in the my final data stream, but is decoded in the software, and so is the temperature read from the bmp05 air pressure detector. the externally mounted os temperature/humidity sensor is used in my final data string. this can be modified to suit your own purposes).\nthe hardware\nthe arduino listens continually for the three wmr86 sensor's broadcasts (the uv light sensor must be purchased seperately) and merges them every minute for an output of a csv string. there are three transmitters in the wmr86 package, wind direction+wind speed (average and gusts), temperature+humidity, and rainfall (cumulative total and rate). they each have different periods between transmission eg wind every 14 seconds, temp/hum and rainfall at longer periods. this does cause overlap of sensor transmissions and inevitable corruption of some packets, however the protocol does have a simple arithmetic checksum based on nybbles that helps eliminate most bad data. admittedly the chance of substitution errors causing bad data to go un-detected is much higher than if a higher bit crc based on a polynomial process was used. range validation would be necessary (in the python or arduino) to check if the resulting readings were sensible to improve reliability. this program reports every minute for all three sensors whether a good packet has been received within that minute or not, so the python program can sum the good and bad packets each minute and report the relative numbers each week in an email.\nthe wiring: a generic prototyping shield was used.\nmanchester protocol\nthe ardunio algorithm to decode the manchester protocol uses timed delays to sample the waveform from the 433mhz rx and not interrupts and direct measurement of waveform transitions. this has a number of implications. the main one is that arduino is continually sampling and analysing the incoming waveform. as it is a dedicated processor in this application and has no other function, this is not a problem. the benefit is that it does simplify the reception and analysis of the waveforms. the simple decoding strategy should also be worth studying by anyone else attempting to leverage other systems that use manchester encoding. to that end a fairly lengthy explanation is offered below.\nthe manchester protocol is a bias neutral protocol where each bit is composed of a high and low signal of equal length (or close to it). this means that a transmitter can be totally keyed off and on (ie the 433mhz signal is not partially modulated, but is either fully transmitting or 'silent')and no matter what sequences of data, 1's and 0's, are transmitted, on average the tx signal will consequently be on for the same time as it is off. this means the switching point, or bias level, for the receiver amplifier remains steady. a data bit in a manchester waveform always has a high and low signal component for encoding both 1's and 0's. so a bit waveform for a data 1 is a high signal followed by a low signal (hi->lo), and a bit waveform for a data 0 is a low signal followed by a high signal (lo->hi). for the os weather station each high and low signal duration are both about 430us. so a full bit waveform will last about 860us. (as will be seen later, the tolerance for decoding these timings is quite wide).\nthe cheap 433mhz rx's available have a simple automatic gain control and bias detection built in. the agc allows the sensitivity to be maximised with low signals, and adjusted back when a stronger 433mhz signal is received. the bias detection allows the average of the output signal voltage to be determined and applied to one half of a comparator, the other comparator input has the received signal. with manchester protocol the on/off ratio is equal, so the bias detection will be at the average voltage, ie approximately half way, consequently the transitions of the signal from on to off and back again, can produce quite clean, symmetrical logic signals with simple circuitry. this manchester decoding program relies on the timing of transitions, rather than the exact shape of the waveform (ie again it does not have to be a very clean square wave shape to work, as long as the transitions are accurate).\nin other words, the decoding program needs to be able to determine whether it has seen a 430us 'no signal' followed by a 430us 'on signal' and so has received a 0, or has received a 430us 'on signal\" followed by a 430us 'no signal' and so received a 1. 'on signal' makes the rx amplifier output go 'hi' and 'no signal' makes the rx output go 'lo'.\nhow is this decoded?\nthe first very important prior knowledge to have is which of the two polarity conventions for manchester encoding this system uses. arguments are put forward for both possibilities as being correct, but either polarity works as good as the other, and with a simple audio sampler, such as audacity, is simple to work out. the transition polarity used by os is that a data 1 is hi->lo and data 0 is lo->hi.\nhowever any hi->lo transition could be either the middle of a data 1 bit waveform and mean a 1 has been sent, or possibly just the hi->lo transition between two bit waveforms, and as such not indicate anything. similarly any lo->hi could indicate the middle of a data 0 bit, or again just a meaningless transition between two bit waveforms. the following diagram illustrates the two bit waveforms. when these are connected up into a bit stream, then the red dots may or may not require transitions to connect them for the bit waveforms to reflect the data bits. a simple example is provided underneath with the 4 possible bit sequences (10,00,01,11) shown and the incidental transitions marked in blue. if you are writing a manchester encoded transmitter then this is all you need to know to get started.\ndiag 1\ncuriously a long string of data 1's will have the same looking waveform as a long string of data 0's. whether they are 1's or 0's depends on where we begin to analyse, we would need some sort of marker, or unambiguous beginning point. and also surprising to begin with, is the sequences of data bits 1 to 0, and 0 to 1, do not have any signal change between bit waveforms. more information on that later...\ncritically the only guaranteed meaningful regular transition of states occurs in the middle of the bit waveform. consequently is essential to concentrate the decoding algorithm around the center of the bit waveform to keep it properly synchronised.\nrf practicalities...\npart of the practical application of the manchester protocol combined with simple 433mhz tx/rx combo's is to use a header sequence of bits, usually 30 or so 1's. this quickly stablizes the rx agc and establishes the bias detection point so the simple 433mhz rx has a good chance of settling down and producing a clean logic waveform after say 10 on/off transmissions. the decoding program can then sample the bit waveform by synchronising (ie looping and waiting) the program to an hi->lo transition, which is the midway point of a bit waveform for a 1. this polarity is how it works for the os protocol, hi->lo==1, lo->hi==0 (wikipedia says the opposite polarity convention is also used by other systems, and both are just as valid).\ngraphic 1: the agc is stabilising fairly quickly here. (audacity sample)\nthis diagram 2 below is showing a stream on 1's as the header. the algorithm is expecting a stream of data 1's and to begin with, and is looking for any hi to lo transition on the rx and assuming it is the middle of a data 1 bit waveform. after detecting any hi->lo transition it begins to check the subsequent waveform. graphic 1 is sections a,b&c in diagram 2.\ndiag 2\ndiagram 2 illustrates the process of detecting a signal and locking into the data in the packet. from the lefthand side, a is showing static, or noise, and when a signal begins in b the agc on the 433mhz receiver is stabilizing. note that early on the program will try to lock onto the negative going edge as shown with the downward black arrow at the start of phase c. phase c is the stream of 1's known as the header. here i have illustrated that receiving fifteen 1's will indicate we have a valid header. phase d indicates that we have more header bits than we need (this allows for some drift about the agc starting point). so any excess 1's are then dumped until the bit pattern changes, when at phase e the bit pattern for 0 arrives. from then on, phase f (the remainder of the packet, nb not all shown) any number of data bits, 1&0's, can be received. sometimes the e&f phase are within the byte pattern, and sometimes the start bit, e is excluded and it just flags the start, and the bytes begin at phase f.\nextracting data from the bit stream\nhow does it know they are properly formed and timed bit waveforms? (please refer to diagram 3 below, nb 7 bit waveforms are shown, only alternative ones are labelled). to filter out noise, the input is sampled until a hi->lo event is detected eg at (b) and then again the program re-samples the rx output about a 1/4 of a bit waveform later at (e), to see if it is still lo. if is lo (as the diagram shows) then it is possibly a genuine middle of a 1 bit waveform, however if it is not a lo then it was not a genuine hi->lo middle of a 1 bit waveform, and the algorithm begins the search for another hi->lo transition all over again. however if this preliminary test is true, it has possibly sampled a midpoint of a 1, so it waits for another half a bit waveform (f). this timing is actually 1/4 of the way into the next bit waveform, and because we know we are looking for another 1, then the signal should have gone hi by then. if is not hi, then the original sample, that was possibly the mid point of a 1 bit waveform is rejected, as overall, it has not followed the 'bit waveform rules', and the search (looping) for then next hi->lo transition begins at the start, all over again. here is a diagram to highlight the previous ideas.\ndiag 3\nthe pink lines are the signal arriving from the 433mhzrx. the long vertical blue lines (eg at a & c) are indicating the start and end of some bit waveforms. these are partially covered by the pink signal trace if they coincide. this diagram show 7 bit patterns. b is positioned at the middle of a bit waveform, and these are also indicated by the m's. the data contained in each bit pattern is determined by the direction of the transition at m, the middle of the bit waveform, and not by what happens at the finish and start of each bit waveform.\nthe diagram 3 shows the four possible bit sequences, 0->1, 1->0, 1->1, 0->0 and what happens in between each combinations of bit waveforms (marked by the orange #1-7 bit waveforms).\nthis simple filtering (delay-check-delay-check etc) allows the program to detect and count the number of successfully detected data 1's received, and once a minimum has been counted in sequence, then the program can assume it has a valid header coming in. this sampling, by looking for transitions and waiting periods of time to sample, is also applied equally to all subsequent 1's and 0's received and can eliminate badly formed packets if the waveform pattern of the manchester encoding is not followed (say due to interference or a weak signal). hence it forms a simple but effective digital filter that greatly reduces spurious results from random or unwanted 433mhz signals.\nthe transitions at the orange 1-7 do not carry data, but if transitions do occur they are to make sure the subsequent transitions that must occur at the mid points match the data bit stream correctly (you can think of 1-7 setting up the data transition for the next mid). the critical aspect of this processing is that this program is always syncing to the mid point of the bit waveform, where the critical data indicating transitions occur. this makes the decoding of the bit stream very tolerant to any errors (data rate wow or flutter in old terms) in sampling the waveforms. this allows the calculations between receiving bits to take different lengths of time (after the middle m of the bit waveform) and still not effect the reliability. the delays can be altered plus or minus 15% (or more) and still get reliable reception.\nthe synchronising 0 bit and may or may not be included in the byte boundaries. some implementations send a single 0 bit then all the bytes of information, whereas the os example we are dealing with here just makes sure the first bit in the first byte sent, is always a 0.\ncapturing the data\nonce this \"0\" is detected then the data stream can be considered synchronised with the detector. this program to decode the oregon scientific weather station's sensors then decodes a sequence of received bytes that have data encoded in both straight binary and other times, bcd. the number of bytes per packet for each transmitter can also vary. the program must be able to recognise each transmitter early and change the number of subsequent bytes expected for each type. to do this the program begins downloading all bytes (more on that later) and identifies the id bytes within the first 2 bytes, and when a particular sensor is detected it immediately sets the exact number of bytes expected. so temp/humidity decoding requires 10 bytes (but only uses 9), anemometer decoding requires 10 bytes and uses them all, and the rainfall sensor decoding requires 11 bytes but only needs the four most significant bits of the last byte. if 11 bytes were accepted all the time, the rainfall would work, but the other two would fail as their signals return to random noise after 10 bytes and this would cause them to be rejected.\nonce a data packet is received it is given a checksum check before being declared valid. we now need to diverge, and return back to the way the bits arrive in the data stream and how they are best stored. the easiest way to explain this is to give an example. let's number the raw rf incoming bits in order, zero arrives first -\n0 1 2 3 4 5 6 7 , and this how it is best to rearrange those bits for os comptibility\n3 2 1 0 7 6 5 4 , so the first bit 0 is actually moved to the fourth position, the next bit 1 is moved to the third position, and so on, and, as this wraps around, all the incoming bits are stored in new positions in a temporary byte, and then stacked into a byte array. it essentially reverses the place values inside each nybble. this properly reflects the environmental values sampled.\nwhy oregon scientific chose this rearrangement is best left up to them to explain, but applying this swapping of positions makes all the data in the stored bytes array so much more logical as well. binary numbers are found in the correct ascending order etc. plus when it comes to the checksum, it is also simpler to calculate as well. take each 4 bit nybble in the data packet (excluding the checksum byte) and add them up as an 8 bit result. this will result in a byte that can be compared to the last byte in the packet, the checksum byte. the number of nybbles for temp/humidity is 16, anemometer 18, and rainfall 19 (nb rainfall check sum byte, is made up of nybbles 20 and 21, ie it bridges the byte boundary).\nprocessing and exporting the data\nonce the bits and bytes are stored in this fashion then the checksum becomes trivial, just add up the nybbles and compare to the checksum byte. reject any packet that does not workout. a simple checksum like this is prone to substitution errors getting through undetected (ie one byte has an error bit, but is balanced out by an inverted error bit in another byte with the same place value. cyclic redundancy methods for checking data validity are much more robust than the simple arithmetic checksums, but they are not used on the os sensors. however by the time the two bytes for the sensor type id, and the rolling id code for a particular sensor are put aside, the critical data that changes is down to 5-7 bytes, and probably the checksum for such a small sample is quite acceptable (though if you intend to use any of these sensors for mission critical stuff you may like to disagree with that opinion). fortunately for me it was easy to program.\nonce the bytes for a particular valid packet are stored in the array, they are processed. some have conversion factors applied, such as binary weighted data for rain is turned into floating point decimals, and the anemometer wind speed is converted from metres per second to kilometers per hour. others such as relative humidity are provided directly in two bcd characters. eventually a selection of the numerical data is formatted into ascii values in a csv string and sent out via the serial port (over the usb connection). the program has a 1 second interrupt that is used to to send the csv string every 60 seconds. my python program on the www server then further processes this string into averages and graphs etc\nbefore any csv is sent though, this program checks that it has received a valid sample from each of the three sensors, and only begins sending csv's when therm/hum, anemometer, uv and rainfall have all been logged in for valid values. this avoids some values being valid and other being at zero at start up.\nthis description should give you a good idea of how the os v3.0 protocol works and how my program tackles decoding that protocol. it is not very sophisticated, when it is all shown now, but was quite a headache to work through originally. the oregon scientific sensors are a good balance of quality engineering, accessible protocols and reasonable price. really getting a grip on the manchester protocol was been a major hurdle, but now is well under control. i am hoping my program and this presentation above will help others tackle this protocol in their own projects.\nhttp://au.oregonscientific.com/ wmr86 to get your own :-)\nmanchester debugger\nthere is now a support debug program you can use to develop your own applications in this repository. edit three values, recipe like, and you could be receiving manchester encoded bytes in next to no time. then over to you! check it out.\ni hope you enjoy using them as much as i do, cheers, rob\nacknowledgements: there are many people, and other publications, i have referenced that have assisted greatly in arriving at this solution and these are listed in the documentation of this program, and explanations given to where they are relevant.\nweather station extension\nextension of the project\nseveral features became desirable after the original system had been running for several years. the main concern was a lack of battery level indicators and also no direct feedback from the arduino module of the signals being received. the solution was tackled in two ways, but involving similar parts of the program.\nbattery levels\nthe battery levels were a harder one to crack. i checked the wmr86 manual for mention of a battery level indicator and also checked the lcd screen supplied with it for any indicators that referred to battery levels. i could not find any. so i devised this strategy. should any sensor not be logged within a minute (ie between sending strings of data to the www server) then a number is incremented for that sensor. as soon as that sensor is detected the number is reset to zero. however if the sensor is not detected for 20 minutes then a flag bit is set for that sensor. this \"detection\" number is sent to the www server along with all the other data every minute. if it remains 0 then the sensors are ok, if it is non-zero, then it means one of the three sensors have experienced a \"continuous down time\" of at least 20 minutes. the www server can check this and send out an email at midnight of that day warning of which sensor(s) have been missed. however the warning could arise for a number of reasons, the first obvious one is the batteries are going flat and the second is that something maybe effecting either the transmitter or receiver. eg the antenna may have changed position on the rx and suddenly 2 outof the three are being received. or maybe some object has been placed bewteen the tx and rx and that has knocked out the signal. however, just because the signal drops out it may not be because of the batteries. the system should be sensitive enough to warn of early stages of battery failure. even if it begins by small periods of time overnight in the cool night air.\nstatus indicator\nthe rgb led should give a quick indication if an antenna position change for example is still allowing the sensors to be received. an rgb led was added to the board to indicate which sensor transmitter was detected. by combining red, blue and/or green i could easily produce 8 recognisable states from the led. simply observing the board would indicate that the different sensors were being logged. this gave a quick indication, for example after a restart that the arduino was functioning properly, and so were the 4 oregon sensors\ncolour coding was:\nred = temperature and humidity\ngreen = wind direction and speed\nblue = rain gauge\nyellow = uv light sensor\npurple = experimental\nrgb status led\nsoftware version\nthe version to use these features is mainweather_09.ino. please note the order of the sensors in the output string has also been changed. so if you have a system reading this string and processing it from the previous version you will have to alter it as well to use this program as it is.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000591, "year": null}, {"Unnamed: 0": 2790, "autor": 750, "date": null, "content": "arduino-sainsmart\nArduino software to steer the SainSmart DIY 6-axis palletizing robot arm and Sunfounder Rollpaw gripper.\nThe software uses smooth sin\u00b2(t) (where t is the time) speed profiles to drive the robot joints. At any time the sum of up to two speed profiles is output to the drives. Using sin\u00b2(t)+cos\u00b2(t)=1 one can achieve constant motion. The plot shows jerk (blue), acceleration (red), speed (green), and position (magenta).\nequipment\nAltogether the equipment cost is about 200\u00a3. Furthermore you need a PC with a USB port.\nsoftware build\nFirst install the dependencies. Please refer to the file .travis.yml for more information.\nCreate the initial calibration file with the limits and offsets of each servo:\ncp calibration.hh.default calibration.hh\nThen build the Arduino program using make:\nmake\nNote: You might have to change the BOARD_TAG in the arduino/Makefile. See /usr/share/arduino/hardware/arduino/boards.txt for supported board tags.\nsoftware test\nYou can also build and run the tests on the PC using the check target:\nmake check\ninstall on Arduino\nThe upload target will upload the program via /dev/ttyUSB0 to the Arduino board.\nmake upload\nWarning: program the board before connecting the servos the first time to prevent erratic motion!\nWarning: once servos are plugged into the board, always connect the servo power to the DFRobot I/O expansion shield before connecting the USB cable to the Arduino to prevent the board power from stalling which causes erratic motion!\nWarning: self-collisions or collisions with the surface and other objects can damage the servos!\nYou can then adjust the limits and offsets for your robot and then compile and upload the modified software.\ncontrol robot\nYou can control the robot using the screen serial terminal (make sure ttyUSB0 is the correct port):\nscreen /dev/ttyUSB0 115200\nExamples of servo commands are:\no: check whether drives are ready to receive more commands (1=ready, 0=busy)\nt: get time\nb: get base servo angle\ns: get shoulder servo angle\ne: get elbow servo angle\nr: get roll servo angle\np: get pitch servo angle\nw: get wrist servo angle\ng: get gripper servo angle\nB: get base servo pulse width\nS: get shoulder servo pulse width\nE: get elbow servo pulse width\nR: get roll servo pulse width\nP: get pitch servo pulse width\nW: get wrist servo pulse width\nG: get gripper servo pulse width\nc: get current configuration (base, shoulder, elbow, roll, pitch, and wrist)\nl: get lower limits for servos\nu: get upper limits for servos\n45b: set base servo angle to 45 degrees\n-12.5s: set shoulder servo angle to -12.5 degrees\n10e: set elbow servo angle to 10 degrees\n20r: set roll servo angle to 20 degrees\n30p: set pitch servo angle to 30 degrees\n40w: set wrist servo angle to 40 degrees\n0g: set gripper servo angle to 0 degrees\n2400B: set base servo pulse width to 2400\n1500S: set shoulder servo pulse width to 1500\n720E: set elbow servo pulse width to 720\n1500R: set roll servo pulse width to 1500\n1500P: set pitch servo pulse width to 1500\n1500W: set wrist servo pulse width to 1500\n2000G: set gripper servo pulse width to 2000\n1 2 3 4 5 6c: set configuration (base, shoulder, elbow, roll, pitch, and wrist) to 1, 2, 3, 4, 5, and 6 degrees\n1 2 3 4 5 6t: time required to reach the specified configuration\nT: report time required to finish current motion\nma: save teach point a (there are 12 teach points from a to l)\n'a: go to teach point a\nda: display configuration of teach point a\nx: stop all servos (in fact any undefined key should do)\nYou can exit the screen terminal using Ctrl-A \\.\nWarning: self-collisions of the robot can damage the servos!\nXBox controller\nYou can control the robot using a calibrated XBox controller.\nruby control.rb\nNote that for some reason you sometimes need to run the serial terminal first, press t a few times, and then exit for the Arduino to wake up.\nExternal links\nSainsmart DIY 6-axis palletizing robot arm (also see Sainsmart Wiki)\nSunfounder Standard Gripper Kit Rollpaw for Robotic Arm (gripper installation instructions)\nRedboard (Arduino compatible board)\nDFRobot IO expansion shield for Arduino (manual)\n6V DC/3A power supply\n2.1 x 5.5mm DC Socket\nSparkfun USB Mini-B cable\nTowerpro MG996R servo (comes with Sainsmart robot)\nTowerpro SG90 9g servo (comes with Sainsmart robot; servo shaft not compatible with Sunfounder Rollpaw servos!)\n22 AWG RC JR Servo Straight Extension Wire 150mm\nArduino multitasking part 1, part 2, part 3\nHow to run test headlessly with Xvfb", "link": "https://github.com/wedesoft/arduino-sainsmart", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "plot", "selectorShort": "plot", "MarkedSent": "arduino-sainsmart\narduino software to steer the sainsmart diy 6-axis palletizing robot arm and sunfounder rollpaw gripper.\nthe software uses smooth sin\u00b2(t) (where t is the time) speed profiles to drive the robot joints. at any time the sum of up to two speed profiles is output to the drives. using sin\u00b2(t)+cos\u00b2(t)=1 one can achieve constant motion. the -----> plot !!!  shows jerk (blue), acceleration (red), speed (green), and position (magenta).\nequipment\naltogether the equipment cost is about 200\u00a3. furthermore you need a pc with a usb port.\nsoftware build\nfirst install the dependencies. please refer to the file .travis.yml for more information.\ncreate the initial calibration file with the limits and offsets of each servo:\ncp calibration.hh.default calibration.hh\nthen build the arduino program using make:\nmake\nnote: you might have to change the board_tag in the arduino/makefile. see /usr/share/arduino/hardware/arduino/boards.txt for supported board tags.\nsoftware test\nyou can also build and run the tests on the pc using the check target:\nmake check\ninstall on arduino\nthe upload target will upload the program via /dev/ttyusb0 to the arduino board.\nmake upload\nwarning: program the board before connecting the servos the first time to prevent erratic motion!\nwarning: once servos are plugged into the board, always connect the servo power to the dfrobot i/o expansion shield before connecting the usb cable to the arduino to prevent the board power from stalling which causes erratic motion!\nwarning: self-collisions or collisions with the surface and other objects can damage the servos!\nyou can then adjust the limits and offsets for your robot and then compile and upload the modified software.\ncontrol robot\nyou can control the robot using the screen serial terminal (make sure ttyusb0 is the correct port):\nscreen /dev/ttyusb0 115200\nexamples of servo commands are:\no: check whether drives are ready to receive more commands (1=ready, 0=busy)\nt: get time\nb: get base servo angle\ns: get shoulder servo angle\ne: get elbow servo angle\nr: get roll servo angle\np: get pitch servo angle\nw: get wrist servo angle\ng: get gripper servo angle\nb: get base servo pulse width\ns: get shoulder servo pulse width\ne: get elbow servo pulse width\nr: get roll servo pulse width\np: get pitch servo pulse width\nw: get wrist servo pulse width\ng: get gripper servo pulse width\nc: get current configuration (base, shoulder, elbow, roll, pitch, and wrist)\nl: get lower limits for servos\nu: get upper limits for servos\n45b: set base servo angle to 45 degrees\n-12.5s: set shoulder servo angle to -12.5 degrees\n10e: set elbow servo angle to 10 degrees\n20r: set roll servo angle to 20 degrees\n30p: set pitch servo angle to 30 degrees\n40w: set wrist servo angle to 40 degrees\n0g: set gripper servo angle to 0 degrees\n2400b: set base servo pulse width to 2400\n1500s: set shoulder servo pulse width to 1500\n720e: set elbow servo pulse width to 720\n1500r: set roll servo pulse width to 1500\n1500p: set pitch servo pulse width to 1500\n1500w: set wrist servo pulse width to 1500\n2000g: set gripper servo pulse width to 2000\n1 2 3 4 5 6c: set configuration (base, shoulder, elbow, roll, pitch, and wrist) to 1, 2, 3, 4, 5, and 6 degrees\n1 2 3 4 5 6t: time required to reach the specified configuration\nt: report time required to finish current motion\nma: save teach point a (there are 12 teach points from a to l)\n'a: go to teach point a\nda: display configuration of teach point a\nx: stop all servos (in fact any undefined key should do)\nyou can exit the screen terminal using ctrl-a \\.\nwarning: self-collisions of the robot can damage the servos!\nxbox controller\nyou can control the robot using a calibrated xbox controller.\nruby control.rb\nnote that for some reason you sometimes need to run the serial terminal first, press t a few times, and then exit for the arduino to wake up.\nexternal links\nsainsmart diy 6-axis palletizing robot arm (also see sainsmart wiki)\nsunfounder standard gripper kit rollpaw for robotic arm (gripper installation instructions)\nredboard (arduino compatible board)\ndfrobot io expansion shield for arduino (manual)\n6v dc/3a power supply\n2.1 x 5.5mm dc socket\nsparkfun usb mini-b cable\ntowerpro mg996r servo (comes with sainsmart robot)\ntowerpro sg90 9g servo (comes with sainsmart robot; servo shaft not compatible with sunfounder rollpaw servos!)\n22 awg rc jr servo straight extension wire 150mm\narduino multitasking part 1, part 2, part 3\nhow to run test headlessly with xvfb", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000750, "year": null}, {"Unnamed: 0": 2988, "autor": 948, "date": null, "content": "Code\nArduino library for Programmable-Air\nCrowdfunded on CrowdSupply\nGetting started:\nAs a first step you should read the README file in the PCB section to get acquainted with the hardware. This is not necessary as such, but highly recommended.\nSoftware\nDownload and install the latest Arduino IDE\nDownload the Programmable-Air library at https://github.com/Programmable-Air/Code Instructions on how to install a new library in Arduino here\nNow there should be a programmable_air folder in File>examples\nIf you do not have Adafruit Neopixel library already installed, you will need to install it as well. Instructions.\nYou might need to install CH340 drivers to get the Arduino nano board to be recognized as a serial device. Follow instructions specific to your OS.\nHardware\nPower up the Programmable-Air unit by connecting 12V adapter. Then connect the USB cable to your computer.\nUploading code\nSelect Tools>Board>Arduino Nano\nIf you are on a new version of Arduino >=1.8.7 select Processor: AtMega328(Old bootloader)\nSelect the corresponding Port (if no new port shows up you\u2019ll have to download and install the CH340 drivers- Mac Windows Linux ) The link looks sketchy and in Chinese, but it is the manufacturer\u2019s website with the most updated version of the driver. Refrain from downloading drivers from any other source!\nThat's it! Try uploading the pressureSensor example and launch the Serial plotter to see the pressure plot. Blow into the output tube, or suck the air out to see the change in pressure.\nDescription of functions:\ninitializePins()\nInitializes the pins as INPUT or OUTPUT and starts the Serial port at 9600 baud. If you want to use pins to attach external hardware, set their pinMode after calling this.\nDoes not return anything.\nblow(int i = 1);\nUsed to blow air into the output tube. Engages valve #2 and disengages valve #1 and #3.\nDoes not return anything.\nAccepts integer value of the slave board. Acceptable values 1, 2, or 3. Defaults to 1(the slave board below the master board).\nvent(int i = 1);\nUsed to vent air from output tube to the atmosphere. Engages valve #1 and disengages valve #2 and #3.\nDoes not return anything.\nAccepts integer value of the slave board. Acceptable values 1, 2, or 3. Defaults to 1(the slave board below the master board).\nventQuick(int i = 1);\nUsed to release air quickly out of the output tube. Engages valve #1, and #3 and disengages valve #1.\nDoes not return anything.\nAccepts integer value of the slave board. Acceptable values 1, 2, or 3. Defaults to 1(the slave board below the master board).\nsuck(int i = 1);\nUsed to suck air out of the output tube. Engages valve #3 and disengages valve #1 and #2.\nDoes not return anything.\nAccepts integer value of the slave board. Acceptable values 1, 2, or 3. Defaults to 1(the slave board below the master board).\nreadBtn(int i);\nReturns 1 if the button is pressed, 0 if not.\nReturn type : int\nAccepts button number or color. RED is button #1, BLUE is button #2\nreadPressure(int num = 1, int times = 1);\nReturns the pressure value. The value is ~508 for atmospheric pressure. Greater for more pressure and lesser for less pressure.\nReturn type : int\nAccepts up to two integer parameters.\nnum - integer value of the slave board. Acceptable values 1, 2, or 3. Defaults to 1(the slave board below the master board).\ntimes - the number of times you want the reading to be taken and averaged. Acceptable value >1. Defaults to 1.\nsetAllValves(int position);\nSet all of the valves to a the position provided. (All the valves on all the slave boards)\nDoes not return anything.\nAccepts int 0 or 1(OPEN/OPENED/ENGAGE/ENGAGED or CLOSE/CLOSED/DISENGAGE/DISENGAGED)\nsetValve(int number, int position);\nSets valve number provided to position provided\nDoes not return anything.\nAccepts valve number and position\nnumber - int 1 to 9 for valve number.\nposition - Accepts int 0 or 1(OPEN/OPENED/ENGAGE/ENGAGED or CLOSE/CLOSED/DISENGAGE/DISENGAGED)\ncloseAllValves();\nCloses(dis-engages) all valves on all slave boards.\nDoes not return anything.\nswitchOnPump(int num, int percentagePower = 100);\nSwitches on pump motor # num to PWM percentage percentagePower.\nDoes not return anything.\nAccepts two parameters\nnum - int motor number 1 or 2\npercentagePower - int 0 to 100. Note that for value <30 the motor might not turn on. Defaults to 100% PWM.\nswitchOffPump(int num);\nSwitches off motor number num\nDoes not return anything.\nnum - int 1 or 2\nswitchOnPumps(int percentagePower = 100);\nSwitches on both motors to PWM percentage percentagePower\nDoes not return anything.\npercentagePower - int 0 to 100. Note that for value <30 the motor might not turn on. Defaults to 100% PWM.\nswitchOffPumps();\nSwitches off both motors\nDoes not return anything.\nDoes not accept any parameter.\nswitchOnLoad(int percentagePower = 100);\nSwitches on load to PWM percentagePower. Note that the load pin gets connected to ground when switched on. So, connect the external device between power and load.\nDoes not return anything.\npercentagePower - int 0 to 100. Note that for value <30 the motor might not turn on. Defaults to 100% PWM.\nswitchOffLoad();\nSwitches off load.\nDoes not return anything.\nDoes not accept any parameter.", "link": "https://github.com/Programmable-Air/Code", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "plot", "selectorShort": "plot", "MarkedSent": "code\narduino library for programmable-air\ncrowdfunded on crowdsupply\ngetting started:\nas a first step you should read the readme file in the pcb section to get acquainted with the hardware. this is not necessary as such, but highly recommended.\nsoftware\ndownload and install the latest arduino ide\ndownload the programmable-air library at https://github.com/programmable-air/code instructions on how to install a new library in arduino here\nnow there should be a programmable_air folder in file>examples\nif you do not have adafruit neopixel library already installed, you will need to install it as well. instructions.\nyou might need to install ch340 drivers to get the arduino nano board to be recognized as a serial device. follow instructions specific to your os.\nhardware\npower up the programmable-air unit by connecting 12v adapter. then connect the usb cable to your computer.\nuploading code\nselect tools>board>arduino nano\nif you are on a new version of arduino >=1.8.7 select processor: atmega328(old bootloader)\nselect the corresponding port (if no new port shows up you\u2019ll have to download and install the ch340 drivers- mac windows linux ) the link looks sketchy and in chinese, but it is the manufacturer\u2019s website with the most updated version of the driver. refrain from downloading drivers from any other source!\nthat's it! try uploading the pressuresensor example and launch the serial plotter to see the pressure -----> plot !!! . blow into the output tube, or suck the air out to see the change in pressure.\ndescription of functions:\ninitializepins()\ninitializes the pins as input or output and starts the serial port at 9600 baud. if you want to use pins to attach external hardware, set their pinmode after calling this.\ndoes not return anything.\nblow(int i = 1);\nused to blow air into the output tube. engages valve #2 and disengages valve #1 and #3.\ndoes not return anything.\naccepts integer value of the slave board. acceptable values 1, 2, or 3. defaults to 1(the slave board below the master board).\nvent(int i = 1);\nused to vent air from output tube to the atmosphere. engages valve #1 and disengages valve #2 and #3.\ndoes not return anything.\naccepts integer value of the slave board. acceptable values 1, 2, or 3. defaults to 1(the slave board below the master board).\nventquick(int i = 1);\nused to release air quickly out of the output tube. engages valve #1, and #3 and disengages valve #1.\ndoes not return anything.\naccepts integer value of the slave board. acceptable values 1, 2, or 3. defaults to 1(the slave board below the master board).\nsuck(int i = 1);\nused to suck air out of the output tube. engages valve #3 and disengages valve #1 and #2.\ndoes not return anything.\naccepts integer value of the slave board. acceptable values 1, 2, or 3. defaults to 1(the slave board below the master board).\nreadbtn(int i);\nreturns 1 if the button is pressed, 0 if not.\nreturn type : int\naccepts button number or color. red is button #1, blue is button #2\nreadpressure(int num = 1, int times = 1);\nreturns the pressure value. the value is ~508 for atmospheric pressure. greater for more pressure and lesser for less pressure.\nreturn type : int\naccepts up to two integer parameters.\nnum - integer value of the slave board. acceptable values 1, 2, or 3. defaults to 1(the slave board below the master board).\ntimes - the number of times you want the reading to be taken and averaged. acceptable value >1. defaults to 1.\nsetallvalves(int position);\nset all of the valves to a the position provided. (all the valves on all the slave boards)\ndoes not return anything.\naccepts int 0 or 1(open/opened/engage/engaged or close/closed/disengage/disengaged)\nsetvalve(int number, int position);\nsets valve number provided to position provided\ndoes not return anything.\naccepts valve number and position\nnumber - int 1 to 9 for valve number.\nposition - accepts int 0 or 1(open/opened/engage/engaged or close/closed/disengage/disengaged)\ncloseallvalves();\ncloses(dis-engages) all valves on all slave boards.\ndoes not return anything.\nswitchonpump(int num, int percentagepower = 100);\nswitches on pump motor # num to pwm percentage percentagepower.\ndoes not return anything.\naccepts two parameters\nnum - int motor number 1 or 2\npercentagepower - int 0 to 100. note that for value <30 the motor might not turn on. defaults to 100% pwm.\nswitchoffpump(int num);\nswitches off motor number num\ndoes not return anything.\nnum - int 1 or 2\nswitchonpumps(int percentagepower = 100);\nswitches on both motors to pwm percentage percentagepower\ndoes not return anything.\npercentagepower - int 0 to 100. note that for value <30 the motor might not turn on. defaults to 100% pwm.\nswitchoffpumps();\nswitches off both motors\ndoes not return anything.\ndoes not accept any parameter.\nswitchonload(int percentagepower = 100);\nswitches on load to pwm percentagepower. note that the load pin gets connected to ground when switched on. so, connect the external device between power and load.\ndoes not return anything.\npercentagepower - int 0 to 100. note that for value <30 the motor might not turn on. defaults to 100% pwm.\nswitchoffload();\nswitches off load.\ndoes not return anything.\ndoes not accept any parameter.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000948, "year": null}], "name": "plotarduino"}
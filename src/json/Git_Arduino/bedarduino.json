{"interestingcomments": [{"Unnamed: 0": 2256, "autor": 216, "date": null, "content": "ADVi3++, an advanced and better firmware for Wanhao i3 Plus Printers\nIntroduction\nADVi3++ is a fork of the Marlin Firmware for the Wanhao Duplicator i3 Plus (and its clones: Monoprice Maker Select Plus, Cocoon Create, ...). It includes both Marlin itself and screens for the LCD Panel.\nBecome a Sponsor of this Project\nWorking on ADVi3++ takes a lot of time and effort. I make my best to release good quality software, useful and precise documents. I track bugs reported by users and replies to help requests. I invest also time and money to implement new hardware features.\nIf you like what I am doing, please consider supporting me as a supporter on Patreon so I can continue and develop new releases and new documents. Supporting this project is a guaranty for you that it will continue and become better and better.\nObjectives\nThe objectives with this custom version (when compared with Wanhao stock firmwares) are the following:\nBased on the latest version of Marlin available (currently: 2.0.7)\nAs few modifications of the Marlin code as possible. The goal is to be able to port ADVi3++ to new versions of Marlin with only a few effort.\nOpen source firmware (GPLv3 like Marlin).\nObject-oriented code with as few hard-coded values as possible. For example, instead of constructing a frame by hand, use instances of classes that know how to construct themselves.\nUse latest C++ features and technics including metaprogramming.\nDocumented code, logging and error handling (without using exceptions as they are not supported).\nFull color and nice LCD screens.\nSupport of hardware such as the BLTouch sensor for automatic bed leveling, powerloss module for Mark II printers, ...\nADVi3++ User Manual\nA complete and up to date User Manual is published on ADVi3++ Community Web Site. This manual contains:\nA list of features and of compatible printers\nHow to Flash the firmware\nLCD Touch Screen Guide\nTuning instructions\nDefault Settings used by ADVi3++\nResources\nSponsors of the ADVI3++ project have also access to advanced topics:\nBLTouch Sensor installation instructions\nStarting and Ending G-Code\nBuild ADVi3++ from Sources\nAlternative ways to Flash\nSupport\nYou can get support from those resources:\nThe User Manual. You may be especially interested by the Troubleshooting part.\nThe ADVi3++ Community - Get Help. It is a forum, based on Discourse. In particular, it includes a Search page. I monitor this forum and try to reply to all requests, from sponsors and non-sponsors of the ADVi3++ project.\nWanhao Duplicator i3 Plus\nI have posted an article on my web site: Wanhao Duplicator i3 Plus 3D Printer - Everything I know about the Wanhao Duplicator i3 Plus 3D printer and its clones. It contains several technical information about the printer internals.\nThanks\nThanks to Dylan xKoldx and weidercs for their forks supporting BLTouch. Thanks to Matt Cowell SureshotM6 for the fork supporting M600 and head parking.\nThanks to Leo L\u00fcker (Silverquark) for his i3plus+ project. I take many ideas from his code. But the project is no more active and I do not like the screens (personal taste) so I have created the ADVi3++ fork. It is technically a fork of Marlin, not of i3plus+.\nThanks to MarlinTeam for their great work.\nCopyright\nADVi3++\nCopyright \u00a9 2017-2021 Sebastien Andrivet GitHub ADVi3pp project\nCopyright \u00a9 2016-2021 MarlinFirmware\nBased on Sprinter and grbl.\nCopyright \u00a9 2011 Camiel Gubbels / Erik van der Zalm\nADVi3++ LCD Panels\nCopyright \u00a9 2017-2021 Sebastien Andrivet GitHub ADVi3pp project\nADVi3++ User Manual\nCopyright \u00a9 2018-2021 Sebastien Andrivet\nLicense\nNote: For detailed information about ADVi3++ licenses, see ADVi3++ and licenses: GPLv3 and CC BY-NC-SA 4.0.\nADVi3++ Firmware\nThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/.\nADVi3++ LCD Panels\nADVi3++ LCD Panels are licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nIMPORTANT: If you want to use these panels (or modified versions of them) for commercial purposes, please contact me.\nADVi3++ User Manual\nThis manual is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.", "link": "https://github.com/andrivet/ADVi3pp", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "bed", "selectorShort": "bed", "MarkedSent": "advi3++, an advanced and better firmware for wanhao i3 plus printers\nintroduction\nadvi3++ is a fork of the marlin firmware for the wanhao duplicator i3 plus (and its clones: monoprice maker select plus, cocoon create, ...). it includes both marlin itself and screens for the lcd panel.\nbecome a sponsor of this project\nworking on advi3++ takes a lot of time and effort. i make my best to release good quality software, useful and precise documents. i track bugs reported by users and replies to help requests. i invest also time and money to implement new hardware features.\nif you like what i am doing, please consider supporting me as a supporter on patreon so i can continue and develop new releases and new documents. supporting this project is a guaranty for you that it will continue and become better and better.\nobjectives\nthe objectives with this custom version (when compared with wanhao stock firmwares) are the following:\nbased on the latest version of marlin available (currently: 2.0.7)\nas few modifications of the marlin code as possible. the goal is to be able to port advi3++ to new versions of marlin with only a few effort.\nopen source firmware (gplv3 like marlin).\nobject-oriented code with as few hard-coded values as possible. for example, instead of constructing a frame by hand, use instances of classes that know how to construct themselves.\nuse latest c++ features and technics including metaprogramming.\ndocumented code, logging and error handling (without using exceptions as they are not supported).\nfull color and nice lcd screens.\nsupport of hardware such as the bltouch sensor for automatic -----> bed !!!  leveling, powerloss module for mark ii printers, ...\nadvi3++ user manual\na complete and up to date user manual is published on advi3++ community web site. this manual contains:\na list of features and of compatible printers\nhow to flash the firmware\nlcd touch screen guide\ntuning instructions\ndefault settings used by advi3++\nresources\nsponsors of the advi3++ project have also access to advanced topics:\nbltouch sensor installation instructions\nstarting and ending g-code\nbuild advi3++ from sources\nalternative ways to flash\nsupport\nyou can get support from those resources:\nthe user manual. you may be especially interested by the troubleshooting part.\nthe advi3++ community - get help. it is a forum, based on discourse. in particular, it includes a search page. i monitor this forum and try to reply to all requests, from sponsors and non-sponsors of the advi3++ project.\nwanhao duplicator i3 plus\ni have posted an article on my web site: wanhao duplicator i3 plus 3d printer - everything i know about the wanhao duplicator i3 plus 3d printer and its clones. it contains several technical information about the printer internals.\nthanks\nthanks to dylan xkoldx and weidercs for their forks supporting bltouch. thanks to matt cowell sureshotm6 for the fork supporting m600 and head parking.\nthanks to leo l\u00fcker (silverquark) for his i3plus+ project. i take many ideas from his code. but the project is no more active and i do not like the screens (personal taste) so i have created the advi3++ fork. it is technically a fork of marlin, not of i3plus+.\nthanks to marlinteam for their great work.\ncopyright\nadvi3++\ncopyright \u00a9 2017-2021 sebastien andrivet github advi3pp project\ncopyright \u00a9 2016-2021 marlinfirmware\nbased on sprinter and grbl.\ncopyright \u00a9 2011 camiel gubbels / erik van der zalm\nadvi3++ lcd panels\ncopyright \u00a9 2017-2021 sebastien andrivet github advi3pp project\nadvi3++ user manual\ncopyright \u00a9 2018-2021 sebastien andrivet\nlicense\nnote: for detailed information about advi3++ licenses, see advi3++ and licenses: gplv3 and cc by-nc-sa 4.0.\nadvi3++ firmware\nthis program is free software: you can redistribute it and/or modify it under the terms of the gnu general public license as published by the free software foundation, either version 3 of the license, or (at your option) any later version.\nthis program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. see the gnu general public license for more details.\nyou should have received a copy of the gnu general public license along with this program. if not, see https://www.gnu.org/licenses/.\nadvi3++ lcd panels\nadvi3++ lcd panels are licensed under a creative commons attribution-noncommercial-sharealike 4.0 international license.\nimportant: if you want to use these panels (or modified versions of them) for commercial purposes, please contact me.\nadvi3++ user manual\nthis manual is licensed under a creative commons attribution-noncommercial-sharealike 4.0 international license.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000216, "year": null}, {"Unnamed: 0": 2342, "autor": 302, "date": null, "content": "NOTE: This product has been retired from our catalog. If you are looking for more up-to-date info, please check out the forum, comments here on GitHub, or IRC channel to see how other users are still hacking and improving on this product.\nSparkFun WiFly Shield\nSparkFun WiFly Shield (WRL-09954)\nTheSparkFun WiFly Shield enables ARduino boards to connect to 802.11b/g wireless networks with Roving Networks RN-131C module. It uses the SC16IS750 SPI-to-UART chip to free up the Arduino's UART.\nRepository Contents\n/Firmware - Example sketches\n/Hardware - All Eagle design files (.brd, .sch)\n/Libraries - All Arduino libraries and board examples\n/Production - Test bed files and production panel files\nDocumentation\nLibrary - Arduino library for the WiFly Shield.\nHookup Guide - Basic hookup guide for the WiFly Shield.\nSparkFun Fritzing repo - Fritzing diagrams for SparkFun products.\nSparkFun 3D Model repo - 3D models of SparkFun products.\nProduct Versions\nWRL-09954- The basic WiFly shield\nRTL-11389- Retail packaging of WiFly shield and stackable headers\nLicense Information\nThe hardware is released under Creative Commons Share-alike 3.0.\nThe SparkFun WiFly Shield library is Copyright (c) 2010 by SparkFun Electronics and is licensed under the LGPL.\nExamples based on the original examples from the official Arduino Ethernet library are licensed under the same terms as the originals.\n'ParsedStream.h' contains a ringbuffer implementation based on one originally found in the Arduino 'HardwareSerial' implementation.\nAuthors\nChris Taylor (Original autoconnect sketch and tutorial)\nPhilip J. Lindsay (Conversion to library)\nJohn Crouchley (1.0 updates -- see https://github.com/jcrouchley/WiFly-Shield)\nBob Breznak (see https://github.com/bobbrez/WiFly-Shield for updates)\njmr13031 (Additional 1.0 updates -- see https://github.com/jmr13031/WiFly-Shield)", "link": "https://github.com/sparkfun/WiFly-Shield", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "bed", "selectorShort": "bed", "MarkedSent": "note: this product has been retired from our catalog. if you are looking for more up-to-date info, please check out the forum, comments here on github, or irc channel to see how other users are still hacking and improving on this product.\nsparkfun wifly shield\nsparkfun wifly shield (wrl-09954)\nthesparkfun wifly shield enables arduino boards to connect to 802.11b/g wireless networks with roving networks rn-131c module. it uses the sc16is750 spi-to-uart chip to free up the arduino's uart.\nrepository contents\n/firmware - example sketches\n/hardware - all eagle design files (.brd, .sch)\n/libraries - all arduino libraries and board examples\n/production - test -----> bed !!!  files and production panel files\ndocumentation\nlibrary - arduino library for the wifly shield.\nhookup guide - basic hookup guide for the wifly shield.\nsparkfun fritzing repo - fritzing diagrams for sparkfun products.\nsparkfun 3d model repo - 3d models of sparkfun products.\nproduct versions\nwrl-09954- the basic wifly shield\nrtl-11389- retail packaging of wifly shield and stackable headers\nlicense information\nthe hardware is released under creative commons share-alike 3.0.\nthe sparkfun wifly shield library is copyright (c) 2010 by sparkfun electronics and is licensed under the lgpl.\nexamples based on the original examples from the official arduino ethernet library are licensed under the same terms as the originals.\n'parsedstream.h' contains a ringbuffer implementation based on one originally found in the arduino 'hardwareserial' implementation.\nauthors\nchris taylor (original autoconnect sketch and tutorial)\nphilip j. lindsay (conversion to library)\njohn crouchley (1.0 updates -- see https://github.com/jcrouchley/wifly-shield)\nbob breznak (see https://github.com/bobbrez/wifly-shield for updates)\njmr13031 (additional 1.0 updates -- see https://github.com/jmr13031/wifly-shield)", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000302, "year": null}, {"Unnamed: 0": 2394, "autor": 354, "date": null, "content": "ESPuino - rfid-based musiccontroller based on ESP32 with I2S-DAC-support\nNews: I started this project back in october 2019 and never expected it to become that large. The project grew and grew - so did main.cpp. So it was about time to have it split into modules. This was done in march/april. After spending some time on tests, improvements and implementing new features, refactoring-branch will is NOW the new master whereas the previous master a new branch named old. It will be kept as reference but won't by maintained anymore. Please be advised that moving to refactoring-branch will re-arrange ESP32's partition. All things to know are described here in german language. Development of the new master is documented here. Have fun and don't hesitate to contact me in case of problems/questions.\nForum\nEN: I've set up a primarily German-speaking community with much documentation. Also an international corner for non-German-speakers is available at https://forum.espuino.de. Github-Login can be used there but it's not mandatory.\nDE: Ich habe ein prim\u00e4r deutschsprachiges Forum aufgesetzt, welches ich mit reichlich Doku versehen habe. W\u00fcrde mich freuen, euch dort zu sehen: https://forum.espuino.de. Ihr k\u00f6nnt euch dort mit eurem Github-Login einloggen, jedoch auch \"normal\" anmelden. Dokumenation findet ihr insbesondere hier: https://forum.espuino.de/c/dokumentation/anleitungen/10\nBuild status\nIMPORTANT!!!\nPartition-layout for ESP32 is changed along with this branch. This step was necessary in order to resize (enlarge) the memory-region where especially the assignments for the RFID-tags are saved. As all permanent settings (e.g. WiFi-settings) are saved there too, it's necessary to re-enter WiFi-credentials after update. But the most important thing is to recover the assignments for the RFID-tags. Please consult my migration-document.\nChangelog\nLast three events:\n13.11.2021: Command CMD_TELL_IP_ADDRESS can now be assigned to buttons in order to get information about the currently used IP-address via speech.\n28.10.2021: Added feature SAVE_PLAYPOS_WHEN_RFID_CHANGE. When enabled last playposition for audiobook is saved when new RFID-tag is applied. Without having this feature enabled, it's necessary to press pause first, in order to do this manually.\n27.10.2021: Added feature SAVE_PLAYPOS_BEFORE_SHUTDOWN. When enabled last playposition for audiobook is saved when shutdown is initiated. Without having this feature enabled, it's necessary to press pause first, in order to do this manually.\nKnown bugs\nSome webstreams don't run. Guess it's a combination of saturated connection-pool and lack of heap-memory. Works probably better if ESP32-WROVER (e.g. Lolin D32 pro) is used, as this chip has PSRAM. Advice: Don't enable modules (e.g. MQTT) if you don't need them as this could save memory (and trouble).\nFor ESPuinos making use of SPI for SD (instead of SD_MMC), there's currently a problem that sometimes leads to incomplete file-transfers via webtransfer or FTP. I'm about to investigate...\nESPuino - what's that?\nThe basic idea of ESPuino is to provide a way, to use the Arduino-platform for a music-control-concept that supports locally stored music-files without DRM-restrictions. This basically means that RFID-tags are used to direct a music-player. Even for kids this concept is simple: place an RFID-object (card, character) on top of a box and the music starts to play. Place another RFID-object on it and anything else is played. Simple as that.\nThe core of my implementation is based on the popular ESP32 by Espressif. Having WiFi-support out-of-the-box makes it possible to provide further features like an integrated FTP-server (to feed the player with music), smarthome-integration via MQTT, webradio and administration via webgui. And nonetheless Bluetooth, too! However, my primary focus was to port the project to a modular base. Having said this mp3-decoding is done in software with a dedicated \u00b5SD-card-slot and music-output is done via I2S-protocol. I did all my tests on Adafruit's MAX98357A, UDA1334 and headphone-pcb. Hopefully, not only in theory, other DACs that support I2S can be used as well.\nHardware-setup\nThe heart of my project is an ESP32 on a Wemos Lolin32 development-board. If ordered in China (Aliexpress, eBay e.g.) it's pretty cheap (around 4\u20ac => ok meanwhile price has doubled...) but even in Europe it's affordable. Make sure to install the drivers for the USB/Serial-chip (CP2102 e.g.). But probably it's better to use its big brother (which has battery-measurement, \u00b5SD-slot, PSRAM already included): Wemos Lolin D32 pro.\nMAX98357A (like Adafruit's)\n\u00b5SD-card-reader; 3.3V only; supports SPI + SD-MMC or cheaper\nRFID-reader RC-522\nRFID-reader PN5180\nRFID-tags\nNeopixel-ring\nRotary Encoder\nButtons\nSpeaker\n\u00b5SD-card: doesn't have to be a super-fast one; \u00b5C is limiting the throughput. Tested 32GB without any problems.\nGetting Started\nMuch documentation in german language.\nI recommend to install Microsoft's Visual Studio Code. This is a popular and powerful IDE that gives you the ability to install tons of (well-supported) plugins.\nInstall Platformio Plugin into Visual Studio Code and make sure to have a look at the documentation. Step-by-step-manual is available here\nInstall Git and make a copy (\"clone\") my repository to your local computer using git clone https://github.com/biologist79/ESPuino.git. Using git you can keep your local repository easily up to date without doing copy'n'paste. To keep it up to date run git pull origin master. Further infos here.\n(Optional) Install Gitlens as plugin (to have advanced Git-support).\nNow, that the git-repository is saved locally, import this folder into Platformio as a project.\nThere's a file called platformio.ini, that contains the configuration for different develboards (e.g. env:lolin32). Platformio supports hundrets of boards out of the box. So probably you need to change/extend that configuration-file. Guess Lolin32 is described in platformio.ini but you need Lolin D32, then lookup Platformio's documentation to know what to change.\nDepending on your operating system (Windows, Mac OS, Linux), you'll probably need to change upload_portand monitor_port as well.\nEdit src/settings.h according your needs.\nEdit board-specific (HAL) config-file (e.g. settings-lolin32.h for Lolin32 or settings-lolin_d32.h for Lolin D32). If you're running a board that is not listed there: start with settings-custom.h and change it according your needs.\nConnect your develboard via USB, click the alien-head to the left, choose the project-task that matches your desired HAL and run Upload and Monitor. All libraries necessary should be fetched in background now followed by code-compilation. After that, your ESP32 is flashed with the firmware. Depending on your develboard it might me necessary to push a button in order to allow ESP32 to enter flashmode (not necessary f\u00fcr Lolin32, D32 und D32 pro).\nNow have a look at the serial-output at the bottom of Visual Studio Code's windows. At the first run there might appear a few error-messages (related to missing entries in NVS). Don't worry, this is just normal. However, make sure SD is running as this is mandatory!\nIf everything ran fine, at the first run, ESPuino should open an access-point with the name \"ESPuino\". Join this WiFi with your computer (or mobile) and enter http://192.168.4.1 to your webbrowser. Enter WiFi-credentials and the hostname. After saving the configuraton, restart ESPuino. Hint: I tried to connect this access-point via Android mobile. Basically that's no problem, but as my mobile detected there'd be no internet-connection, it kept LTE-connection open and prevented me from connecting to http://192.168.4.1. So if in doubts better use a computer.\nAfter reboot ESPuino tries to join your WiFi (with the credentials previously entered). If that was successful, an IP is shown in the serial-console of Visual Studio Code. You can call ESPuino's GUI using a webbrowser via this IP; make sure to allow Javascript. If mDNS-feature is active in src/settings.h, you can use the hostname configured extended by .local instead the IP. So if you configured espuino as hostname, you can use http://espuino.local for webgui and FTP.\nVia FTP and webGUI you can upload data (but don't expect it to be super fast).\nFTP needs to be activated after boot if you need it! Don't forget to assign action ENABLE_FTP_SERVER in settings.h to be able to activate it. Neopixel flashes green (1x) if enabling was successful. It'll be disabled automatically after next reboot. Means: you have to enable it every time you need it (if reboot was in between). Sounds annoying and maybe it is, but's running this way in order to have more heap-memory available (for webstream) if FTP isn't necessary.\nVia webbrowser you can configure various settings and pair RFID-tags with actions. If MQTT/FTP-support was not compiled, their config-tabs won't appear.\nPrerequisites / tipps\nMuch much documentation in german language.\nOpen settings.h\nChoose if optional modules (e.g. MQTT, FTP, Neopixel) should be compiled/enabled.\nMake sure to edit/review button-layout. Default-design is three buttons and a rotary-encoder. All actions available are listed in src/values.h (values with numbers >= 100).\nFor debugging-purposes serialDebug can be set to ERROR, NOTICE, INFO or DEBUG. I usually have DEBUG set.\nIf Neopixel enabled: set NUM_LEDS to the LED-number of your Neopixel-ring and define the Neopixel-type using #define CHIPSET\nOpen board-specific config-file and edit according your needs.\nIf you want to monitor battery's voltage, make sure to enable MEASURE_BATTERY_VOLTAGE. Use a voltage-divider as voltage of a LiPo is way too high for ESP32 (only 3.3V supported!). For my tests I connected VBat with a serial connection of 130k + 130k resistors (VBat(+)--130k--X--130k--VBat(-)). X is the measure-point where to connect the GPIO to. If using Lolin D32 or Lolin D32 pro, make sure to leave both resistor-values unchanged at 100k - voltage-divider is already integrated there. Same goes for GPIO: leave unchanged at 35. Please note: via GUI upper and lower voltage cut-offs for visualisation of battery-voltage (Neopixel) is available. Additional GUI-configurable values are interval (in minutes) for checking battery voltage and the cut off-voltage below whose a warning is shown via Neopixel.\nIf you're using a headphone-pcb with a headphone jack that has a pin to indicate if there's a plug, you can use this signal along with the feature HEADPHONE_ADJUST_ENABLE to limit the maximum headphone-voltage automatically. As per default you have to invert this signal (with a P-channel MOSFET) and connect it e.g. to GPIO22.\nEnabling SHUTDOWN_IF_SD_BOOT_FAILS is really recommended if you run your ESPuino in battery-mode without having a restart-button exposed to the outside of ESPuino's enclosure. Because otherwise there's no way to restart your ESPuino and the error-state will remain until battery is empty (or you open the enclosure, hehe).\nEnabling PLAY_LAST_RFID_AFTER_REBOOT will tell ESPuino to remember the last RFID-tag played after next reboot. So rebooting ESPuino will end up in autoplay.\nSD-card: SPI or SD-MMC (1 bit)-mode?\nHaving SD working is mandatory! However, there are two modes available to access SD-cards: SPI and SD-MMC (1 bit).\nAdvantages SD-MMC (1 bit) over SPI:\nNeeds only three GPIOs (instead of four)\nIt's faster. FTP-upload: 298 kiB vs 178 kiB. HTTP-upload: 350 kiB vs 184 kiB. (tested with filesize of 70.7 MiB.\nSo why using SPI if SD-MMC seems to be better? The primary problem of SD-MMC is: you cannot choose different GPIOs. That doesn't sound bad but this can (depending on the \u00b5SD-card-reader-module) be a problem because maybe GPIO2 is pulled HIGH to 3.3V by a 10k-resistor. For example this is the case when using the reader-module named above in hardware-setup. It's a problem because if GPIO2 is pulled high at boot, ESP32 doesn't enter flash-mode (so you cannot flash new firmwares). As soon as flash-mode is entered, it's no longer a problem. However, this behaviour can be an issue if ESP32 is deeply \"burried\" in ESPuino's enclosure and you want to update its firmware. But fortunately there's a way to bypass this problem: remove the pullup-resistor shown in the picture. It can be removed safely because if MMC-mode is set because pullup is done in software using pinMode(2, INPUT_PULLUP);. So it's not really a problem but you have to take note of that!\nRFID: RC522 or PN5180?\nRC522 is so to say the ESPuino-standard. It's cheap and works, but RFID-tag has to be placed near the reader. PN5180 instead has better RFID range/sensitivity and can read ISO-15693 / iCode SLIX2-tags aka 'Tonies' (you need a password to read Tonies), too. You can also wake-up the board with the card. Disadvantages: it's more expensive and needs more GPIOs (6/7 instead of 4). Refer PN5180's wire-section below for further informations. Hint: if using 3.3V make sure to connect PN5180 to +5V AND 3.3V. Sounds weird but it's necessary.\n3.3 or 5V?\nWhy 3.3V? Because: if you plan to use battery-mode with a LiPo, there's no 5 V available (unless USB is connected). That's why my design's focus is on 3.3 V. If you want to use 5 V - do so, but be advised it's not compatible with LiPo-battery-mode. The Mosfet-circuit for saving power in deepsleep (see Lolin32-schematics as reference) works as well for 5 V.\nMAX98357a: provides more power at 5 V but also runs at 3.3 V. Anyway: it's still loud enough (in my opinion).\nNeopixel: specification says it needs 5 V but runs at 3.3 V as well.\nRC522: needs 3.3 V (don't power with 5 V!)\nPN5180: at 3.3 V make sure to connect both 5 V and 3.3 V-pins to 3.3 V.\nSD: needs 3.3 V but if voltage-regulator is onboard, it can be connected to 5 V as well\nRotary encoder: 3.3 V (don't power with 5 V! Encoder doens't care if connected to 3.3 or 5 V, but GPIOs of ESP32 do!)\nWiring (general)\nI really really recommend to solder all the stuff onto a PCB as wiring the components with jumperwires on a breadboard can lead to many problems. Especially for the interconnect between \u00b5C and \u00b5SD-card-reader make sure to use short wires (like 10cm or so)! So be aware of this! Have a look at the PCB-folder and the forum. I provided PCBs for a few types of develboards (and others will follow...). Important: you can easily connect another I2S-DACs by just connecting them in parallel to the I2S-pins (DIN, BCLK, LRC). This is true for example if you plan to integrate a line/headphone-pcb. In general, this runs fine. But unfortunately especially this board lacks of a headphone jack, that takes note if a plug is inserted or not. Best way is to use a headphone jack that has a pin that is pulled to GND, if there's no plug and vice versa. Using for example a MOSFET-circuit, this GND-signal can be inverted in a way, that MAX98357.SD is pulled down to GND if there's a plug. Doing that will mute MAX98537a and so turn off the speaker immediately if there's a plug and vice versa. Have a look at the PCB-folder in order to view the detailed solution. Here's an example for such a headphone-pcb that makes use of GND.\nWiring (2 SPI-instances: RC522 + SPI-SD + 3 buttons + rotary-encoder)\nUses two SPI-instances. The first one for the RFID-reader and the second for SD-card-reader. This is also the setup, I personally use primarily.\nESP32 (GPIO) Hardware Pin Comment\n3.3 (5) V SD-reader VCC Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND SD-reader GND\n15 SD-reader CS\n13 SD-reader MOSI\n16 SD-reader MISO\n14 SD-reader SCK\n3.3 V RFID-reader 3.3V Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND RFID-reader GND\n21 RFID-reader CS/SDA\n23 RFID-reader MOSI\n19 RFID-reader MISO\n18 RFID-reader SCK\n5 / 3.3 V MAX98357 VIN Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND MAX98357 GND\n25 MAX98357 DIN\n27 MAX98357 BCLK\n26 MAX98357 LRC\n--- MAX98357 SD Info: if pulled down to GND amp will turn off\n34 Rotary encoder CLK Change CLK with DT if you want to change the direction of RE\n35 Rotary encoder DT Change CLK with DT if you want to change the direction of RE\n32 Rotary encoder BUTTON\n3.3 V Rotary encoder +\nGND Rotary encoder GND\n4 Button (next)\nGND Button (next)\n2 Button (previous)\nGND Button (previous)\n5 Button (pause/play)\nGND Button (pause/play)\n3.3 V Neopixel V Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND Neopixel G\n12 Neopixel DI\n17 N-channel Mosfet Gate\n33 Voltage-divider / BAT Optional: voltage-divider to monitor battery-voltage\n22 Headphone jack Optional: if pulled to ground, headphone-volume is set\nOptionally, GPIO 17 can be used to drive a Mosfet-circuit in order to switch off peripherals (SD, Neopixel, RFID and MAX98357a) if ESP32 is in deepsleep. Please refer the schematics for my Lolin32-PCB for further informations. If you need further informations on transistor-circuits visit this website.\nIn general I recommend using a \u00b5SD-card-reader that can be run solely with 3.3V (doesn't have a voltage-regulator - don't use it with 5V!).\nWiring (SD-card in 1 Bit SD-MMC mode) different to above\nESP32 (GPIO) Hardware Pin Comment\n-- SD-reader CS no CS required\n15 SD-reader MOSI\n2 SD-reader MISO make sure there's no hardware-pullup for MISO\n14 SD-reader SCK\nMake sure to enable SD_MMC_1BIT_MODE if you want to use this feature. Don't(!) enable SINGLE_SPI_ENABLE. SD-MMC-mode requires these fixed PINs listed above. You can find a good comparison of different SD-card-modes here: (https://www.instructables.com/Select-SD-Interface-for-ESP32/). Advice: Double check that above PINs are not used elsewhere (e.g. GPIO2 is used as PREVIOUS_BUTTON as per default in settings.h).\nWiring (1 SPI-instance: RC522 + SD + 3 buttons + rotary-encoder) [EXPERIMENTAL, maybe not working!]\nBasically the same as using 2 SPI-instances but... In this case RFID-reader + SD-reader share SPI's SCK, MISO and MOSI. But make sure to use different CS-pins. Have to admit I had problems to get this running. Seems to be connected properly, but nothing happens when an RFID-tag is applied. Maybe anybody else wants to point out :-)\nESP32 (GPIO) Hardware Pin Comment\n3.3 (5) V SD-reader VCC Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND SD-reader GND\n15 SD-reader CS Don't share with RFID!\n3.3 V RFID-reader 3.3V Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND RFID-reader GND\n21 RFID-reader CS/SDA Don't share with SD!\n23 RFID+SD-reader MOSI\n19 RFID+SD-reader MISO\n18 RFID+SD-reader SCK\n5 / 3.3 V MAX98357 VIN Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND MAX98357 GND\n25 MAX98357 DIN\n27 MAX98357 BCLK\n26 MAX98357 LRC\n--- MAX98357 SD Info: if pulled down to GND amp will turn off\n34 Rotary encoder CLK Change CLK with DT if you want to change the direction of RE\n35 Rotary encoder DT Change CLK with DT if you want to change the direction of RE\n32 Rotary encoder BUTTON\n3.3 V Rotary encoder +\nGND Rotary encoder GND\n4 Button (next)\nGND Button (next)\n2 Button (previous)\nGND Button (previous)\n5 Button (pause/play)\nGND Button (pause/play)\n5 / 3.3 V Neopixel V Connect to p-channel MOSFET for power-saving when \u00b5C is off\nGND Neopixel G\n12 Neopixel DI\n17 N-channel Mosfet Gate\n33 Voltage-divider / BAT Optional: voltage-divider to monitor battery-voltage\n22 Headphone jack Optional: if pulled to ground, headphone-volume is set\nWiring (PN5180 instead of MFRC522) different to above\nPN5180-reader needs at least two more GPIOs: RESET and BUSY. Double check pin-conflicts! RFID_READER_TYPE_PN5180 needs to be enabled to use this feature. Make sure to disable RFID_READER_TYPE_MFRC522 if doing so! You can enable low power card-detection with PN5180_ENABLE_LPCD, but this needs another GPIO for IRQ. With low power card detection (LPCD) you can wake-up the ESP32 from deep-sleep just by applying a card to the reader. But: you need a PN5180-firmware >= 4.0 to use this feature. Most china-boards come with an older firmware, so be advised to flash them to latest firmware using this project. There's a PCB available for PN5180: Lolin32 + SD_MMC + PN5180.\nESP32 (GPIO) Hardware Pin Comment\n3.3 V PN5180 RFID-reader 3.3V Connect to p-channel MOSFET for power-saving when \u00b5C is off\n3.3 V 3.3V For low power card detection mode (LPCD) connect directly to 3.3V\n5 / 3.3 V PN5180 RFID-reader 5V Don't forget to connect this pin the same way as 3.3V\nGND PN5180 RFID-reader GND\n21 PN5180 RFID-reader CS/SDA Same as MFRC522. Don't share with SD!\n23 PN5180 RFID-reader MOSI Same as MFRC522\n19 PN5180 RFID-reader MISO Same as MFRC522\n18 PN5180 RFID-reader SCK Same as MFRC522\n16 PN5180 RFID-reader BUSY be aware of SD MISO if running in SPI mode\n22 PN5180 RFID-reader RST be aware of Headphone jack PIN\n39 PN5180 RFID-reader IRQ optional, used for low power card detection (LPCD)\nWiring (custom) / different pinout\nWhen using a develboard with SD-card-reader already integrated (Lolin D32 Pro, several TTGO-boards), the pinouts described above my not fit. Feel free to change them according your needs. Additionaly some boards may use one or some of the GPIOs I used for their internal purposes and that reason for are maybe not exposed via pin-headers. However, having them exposed doesn't mean they can be used without limits. This is because some GPIOs have to be logical LOW or HIGH at start/boot for example and this is probably not the case when connecting stuff to it. Feel free to adjust the GPIOs proposed by me (but be adviced it could take a while to get it running). If you encounter problems please refer the board's manual first.\nHere I described a solution for a board with many GPIOs used internally and a very limited number of GPIOs exposed. That's why I had to use different SPI-GPIOs for RFID as well. ESPuino supports this board and there's a discussion.\nWiFi\nWiFi is mandatory for webgui, FTP and MQTT. However, WiFi can be temporarily or permanently disabled. There are two ways to do that:\nUse a special modification-card that can be configured via webgui\nAssign action CMD_TOGGLE_WIFI_STATUS to a button (or multi-button). Default: press previous + next-button in parallel shortly. Now release both. This toggles the current WiFi-status: if it's currently enabled, it will be disabled instantly and vice versa. Please note: this WiFi-status will remain until you change it again, which means, that ESPuino will remember this state after the next reboot. Having Wifi enabled is indicated in idle-mode (no playlist active) with four white slow rotating LEDs whereas disabled WiFi is represented by those ones coloured green. Bluetooth-mode is indicated by blue LEDs.\nBluetooth\nESPuino can be used as bluetooth-sink (a2dp). This mode can be enabled/disabled via a RFID-modification-card or by assigning action CMD_TOGGLE_BLUETOOTH_MODE to a button (or multi-button). Applying this will restart ESPuino immediately. Two modes are available which are toggled in between: \"normal\" and \"bluetooth\". Normal means: SD + WiFi are available whereas in mode \"bluetooth\" only bluetooth-support can be provided. Activated bluetooth is indicated by four slow rotating blue LEDs. Now you can stream to your ESPuino e.g. with your mobile device. Tested this with Android 8 and Mac OS: worked 100% flawless. Please note: due to memory-restrictions it's not possible to run Bluetooth in parallel with WiFi.\nPort-expander\nThere might be situations where you run out of GPIOs. To address this, port-expander PCA9555 can be used to extend number of input-channels (output-mode is only supported in special cases). This port-expander provides 2 ports with 8 channels each - so 16 channels in total. To activate PCA9555 you need to enable PORT_EXPANDER_ENABLE. Like GPIOs in your develboard-specific settings-file, you can assign numbers. Range is 100->115 where 100: port 0 channel 0 -> 107: port 0 channel 7; 108: port 1 channel 0 -> 115: port 1 channel 7. Via expanderI2cAddress port-expander's I2C-address can be changed. It's 0x20 if all A0, A1, A2 are wired to GND.\nAfter ESPuino is connected to your WiFi\nAfter making ESPuino part of your LAN/WiFi, the 'regular' webgui is available at the IP assigned by your router (or the configured hostname). Using this GUI, you can:\nconfigure WiFi\nmake binding between RFID-tag, file/directory/URL and playMode\nmake bindings between RFID-tag and a modification-type\nconfigure MQTT (if enabled)\nconfigure FTP (if enabled)\nconfigure nitial volume, maximum volume (speaker / headphone), brightness of Neopixel (nightmode / default) and inactivity-time\nview logs / status / current track\ncontrol player\nupload audiofiles (called webtransfer)\ndo OTA-updates (ESP32s with 16 MB of flash-memory only)\nimport + delete NVS-RFID-assigments\nrestart + shutdown ESPuino\nWebgui #1:\nWebgui #2:\nWebgui #3:\nWebgui #4:\nWebgui #5:\nWebgui #6:\nWebgui #7:\nWebgui: websocket broken:\nWebgui: action ok:\nPlease note: as you apply a RFID-tag to the RFID-reader, the corresponding ID is pushed to the GUI. So there's no need to enter such IDs manually (unless you want to). Filepath is filled out automatically by selecting a file/directory in the filebrowser.\nInteracting with ESPuino\nPlaymodes\nIt's not just simply playing music; different playmodes are supported:\nsingle track => plays one track one time\nsingle track (loop) => plays one track forever\naudiobook => single file or playlist/folder; last play-position (file and playlist) is saved (when pushing pause or moving to another track) and re-used next time\naudiobook (loop) => same as audiobook but loops forever\nfolder/playlist (alph. sorted) => plays all tracks in alph. order from a folder one time\nfolder/playlist (random order) => plays all tracks in random order from a folder one time\nfolder/playlist (alph. sorted) => plays all tracks in alph. order from a folder forever\nfolder/playlist (random order) => plays all tracks in random order from a folder forever\nwebradio => always only one \"track\": plays a webstream\nlist (files from SD and/or webstreams) from local .m3u-File => can be one or more files / webradio-stations with local .m3u as sourcefile\nModification RFID-tags\nThere are special RFID-tags, that don't start music by themself but can modify things. If applied a second time, it's previous action/modification will be reversed. Please note: all sleep-modes do dimming (Neopixel) automatically because it's supposed to be used in the evening when going to bed. Well, at least that's my children's indication :-) So first make sure to start the music then use a modification-card in order to apply your desired modification:\nlock/unlock all buttons\nsleep after 5/30/60/120 minutes\nsleep after end of current track\nsleep after end of playlist\nsleep after five tracks\ndimm neopixel\ncurrent track in loop-mode (is \"stronger\" than playlist-loop but doesn't overwrite it!)\nplaylist in loop-mode\ntrack und playlist loop-mode can both be activated at the same time, but unless track-loop isn't deactivated, playlist-loop won't be effective\nToggle WiFi (enable/disable) => disabling WiFi while webstream is active will stop a running webstream instantly!\nToggle Bluetooth (enable/disable) => restarts ESPuino immediately\nNeopixel-ring (optional)\nIndicates different things. Don't forget configuration of number of LEDs via #define NUM_LEDS\nWhile booting: every second LED (rotating orange)\nUnable to mount SD: LEDs flashing red (will remain forever unless SD-card is available or SHUTDOWN_IF_SD_BOOT_FAILS is active)\nIDLE: four LEDs slow rotating (white if WiFi enabled; green if WiFi disabled)\nBLUETOOTH: four LEDs slow rotating coloured blue\nERROR: all LEDs flashing red (1x) if an action was not accepted\nOK: all LEDs flashing green (1x) if an action was accepted\nBUSY: violet; four fast rotating LEDs when generating a playlist. Duration depends on the number of files in your playlist.\ntrack-progress: rainbow; number of LEDs relative to play-progress\nplaylist-progress: blue; appears only shortly in playlist-mode with the beginning every new track; number of LEDs relative to progress\nwebstream: two slow rotating LEDs that change their colours rainbow-wise as the stream proceeds\nvolume: green => red-gradient; number of LEDs relative from current to max volume\nswitching off: red-circle that grows until long-press-time is reached\nbuttons locked: track-progress-LEDs coloured red\npaused: track-progress-LEDs coloured orange\nrewind: if single-track-loop is activated a LED-rewind is performed when restarting the given track\n(Optional) Undervoltage: flashes three times red if battery-voltage is too low. This voltage-level can be configured via GUI.\n(Optional) Short press of rotary encoder's button provides battery-voltage visualisation via Neopixel. Upper und lower voltage cut-offs can be adjusted via GUI. So for example if lower voltage is set to 3.2 V and upper voltage to 4.2 V, 50% of the LEDs indicate a voltage of 3.7 V.\nPlease note: some Neopixels use a reversed addressing which leads to the 'problem', that all effects are shown counter clockwise. If you want to change that behaviour, just enable NEOPIXEL_REVERSE_ROTATION.\nButtons\nImportant: this section describes my default-design: 3 buttons + rotary-encoder. Feel free to change button-number and button-actions according your needs in settings.h and your develboard-specific config-file (e.g. settings-lolin32.h). At maximum you can activate five buttons + rotary-encoder. Minimum duration for long press (to distinguish vom short press) in ms is defined by intervalToLongPress. All actions available are listed in src/values.h. If using GPIO >= 35 make sure to add a external pullup-resistor (10 k).\nprevious (short): previous track / beginning of the first track if pressed while first track is playing\nprevious (long): first track of playlist\nnext (short): next track of playlist\nnext (long): last track of playlist\npause/play (short/long): pause/play\nrotary encoder (turning): vol +/-\nrotary encoder (button long): switch off (only when on)\nrotary encoder (button short): switch on (when switched off)\nrotary encoder (button short): show battery-voltage via Neopixel (when switched on and MEASURE_BATTERY_VOLTAGE is active)\nprevious (long; keep pressed) + next (short) + release (both): toggle WiFi enabled/disabled\nMusic-play\nMusic starts to play right after a valid RFID-tag was applied.\nIf PLAY_LAST_RFID_AFTER_REBOOT is active, ESPuino will remember the last RFID applied => music-autoplay.\nIf a folder should be played that contains many mp3s, the playlist-generation can take a few seconds.\nFor all playmodes that are not single tracks or webradio a filecache is available to speed up playlist-generation. The cache is generated as you apply the corresponding RFID-tag for the first time. Use CACHED_PLAYLIST_ENABLE to enable it - I really recommend to use it.\nA file's name including path isn't allowed exceed 255 characters.\nWhile playlist is generated Neopixel indicates BUSY-mode.\nAfter last track was played, Neopixel indicates IDLE-mode.\nAudiobook-mode\nThis mode is different from the others because the last playposition is saved. Playposition is saved when...\nnext track starts.\nfirst/previous/last track requested by button.\npause was pressed.\ntrack is over.\nplaylist is over (playposition is set back to the first track and file-position 0).\nPlease note: last playposition is not saved when applying a new RFID-tag. This is intended because otherwise you wouldn't have a possibility to not save it. If you want to save the playposition: press pause first.\nFTP (optional)\nFTP needs to be activated after boot! Don't forget to assign action ENABLE_FTP_SERVER in settings.h or use a modification-card to to activate it! Neopixel flashes green (1x) if enabling was successful. It'll be disabled automatically after next reboot. Means: you have to enable it every time you need it (if reboot was in between). Sounds annoying and maybe it is, but's running this way in order to save heap-memory when FTP isn't needed.\nWhy FTP? Well: in order to avoid exposing \u00b5SD-card or disassembling ESPuino all the time for adding new music, it's possible to transfer music to the \u00b5SD-card using FTP. Another possibility is to do via webGUI (webtransfer).\nDefault-user and password are set to esp32 / esp32 but can be changed via GUI.\nMake sure to set the max. number of parallel connections to ONE in your FTP-client and the charset to CP437. CP437 is important if you want to use german umlauts (\u00f6\u00e4\u00fc\u00df).\nSecured FTP is not available. So make sure to disable SSL/TLS.\nSoftware: my recommendation is Filezilla as it's free and available for multiple platforms.\nDon't expect a super fast data-transfer; it's around 185 kB/s (SPI-mode) and 310 kB/s (MMC-mode).\nPlease note: if music is played in parallel, this rate decrases dramatically! So better stop playback when doing a FTP-transfer.\nEnergy saving\nAs already described in the modify-section, there are different sleepmodes available. Additionaly \u00b5C will be put into deepsleep after 10 minutes of inactivity (configurable my maxInactivityTime) unless ESPuino doesn't play music, has a FTP-client connected and any input via buttons. Every button-interaction resets the counter.\nMQTT (optional)\nEverything that can be controlled via RFID-tags and buttons, can also be controlled via MQTT (excepting toggling WiFi-status as this doesn't make sense). All manual interactions (buttons, RFID-tags) are also sent to MQTT in parallel, so everything is always in-sync (unless Wifi/MQTT-connection is broken). In my home-setup I'm using openHAB to \"encapsulate\" MQTT into a nice GUI, that's accessible via APP + web. I described a sample-config for openHAB2. However, meanwhile openHAB3 is available and all the stuff described can also be configured via GUI. Be advised that openHAB is pretty complex and you have to spend some time to get familiar with it.\nSupported file/stream-types\nPlease refer ESP32-audioI2S, as this is the library I used for music-decoding. Make sure to update especially this library regularly as it's development is still in progress.\nBackups\nAs all assignments between RFID-IDs and actions (playmode, file to play...) is saved in ESP's NVS, the problem is that it's all gone when the ESP is broken. So that's where a backup comes into play. So every time you change or add a new assignment between a RFID-tag and an action via GUI, a backup-file is saved on the \u00b5SD-card. The file's name can be changed via backupFile. So better don't delete it! Using the webgui you can use the upload-form to import such a file.\nSmarthome (optional)\nAs already described, MQTT is supported. In order to use it it's necessary to run a MQTT-broker; Mosquitto for instance. After connecting to it, ESPuino subscribes to all command-topics. State-topics are used to push states to the broker in order to inform others if anything changed (change of volume, new playlist, new track... name it). Others, like openHAB, subscribe to state-topics end send commands via command-topics. So it's not just limited to openHAB. It's just necessary to use a platform, that supports MQTT. For further informations (and pictures) refer the subfolder.\nMQTT-topics and their ranges\nFeel free to use your own smarthome-environments (instead of openHAB). The MQTT-topics available are described as follows. Please note: if you want to send a command to ESPuino, you have to use a cmnd-topic whereas ESPuino pushes its states back via state-topics. So guess you want to change the volume to 8 you have to send this number via topic-variable topicLoudnessCmnd. Immediately after doing to, ESPuino sends a conformation of this command using topicLoudnessState. To get hands on MQTT I recommend this one as introducton (covers more than you need for ESPuino).\ntopic-variable range meaning\ntopicSleepCmnd 0 or OFF Power off ESPuino immediately\ntopicSleepState ON or OFF Sends ESPuino's current/last state\ntopicRfidCmnd 12 digits Set number of RFID-tag which 'emulates' an RFID-tag (e.g. 123789456089)\ntopicRfidState 12 digits ID of current RFID-tag (if not a modification-card)\ntopicTrackState String Sends current track number, total number of tracks and full path of curren track. E.g. \"(2/10) /mp3/kinderlieder/Ri ra rutsch.mp3\"\ntopicTrackControlCmnd 1 -> 7 1=stop; 2=unused!; 3=play/pause; 4=next; 5=prev; 6=first; 7=last\ntopicLoudnessCmnd 0 -> 21 Set loudness (depends on minVolume / maxVolume)\ntopicLoudnessState 0 -> 21 Sends loudness (depends on minVolume / maxVolume\ntopicSleepTimerCmnd EOP Power off after end to playlist\nEOT Power off after end of track\nEO5T Power off after end of five tracks\n1 -> 2^32 Duration in minutes to power off\n0 Deactivate timer (if active)\ntopicSleepTimerState various Sends active timer (EOP, EOT, EO5T, 0, ...)\ntopicState Online, Offline Online when powering on, Offline when powering off\ntopicCurrentIPv4IP IPv4-string Sends ESPuino's IP-address (e.g. 192.168.2.78)\ntopicLockControlsCmnd ON, OFF Set if controls (buttons, rotary encoder) should be locked\ntopicLockControlsState ON, OFF Sends if controls (buttons, rotary encoder) are locked\ntopicPlaymodeState 0 - 10 Sends current playmode (single track, audiobook...; see playmodes)\ntopicRepeatModeCmnd 0 - 3 Set repeat-mode: 0=no; 1=track; 2=playlist; 3=both\ntopicRepeatModeState 0 - 3 Sends repeat-mode\ntopicLedBrightnessCmnd 0 - 255 Set brightness of Neopixel\ntopicLedBrightnessState 0 - 255 Sends brightness of Neopixel\ntopicBatteryVoltage float Voltage (e.g. 3.81)\ntopicWiFiRssiState int Numeric WiFi signal-strength (dBm)", "link": "https://github.com/biologist79/ESPuino", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "bed", "selectorShort": "bed", "MarkedSent": "espuino - rfid-based musiccontroller based on esp32 with i2s-dac-support\nnews: i started this project back in october 2019 and never expected it to become that large. the project grew and grew - so did main.cpp. so it was about time to have it split into modules. this was done in march/april. after spending some time on tests, improvements and implementing new features, refactoring-branch will is now the new master whereas the previous master a new branch named old. it will be kept as reference but won't by maintained anymore. please be advised that moving to refactoring-branch will re-arrange esp32's partition. all things to know are described here in german language. development of the new master is documented here. have fun and don't hesitate to contact me in case of problems/questions.\nforum\nen: i've set up a primarily german-speaking community with much documentation. also an international corner for non-german-speakers is available at https://forum.espuino.de. github-login can be used there but it's not mandatory.\nde: ich habe ein prim\u00e4r deutschsprachiges forum aufgesetzt, welches ich mit reichlich doku versehen habe. w\u00fcrde mich freuen, euch dort zu sehen: https://forum.espuino.de. ihr k\u00f6nnt euch dort mit eurem github-login einloggen, jedoch auch \"normal\" anmelden. dokumenation findet ihr insbesondere hier: https://forum.espuino.de/c/dokumentation/anleitungen/10\nbuild status\nimportant!!!\npartition-layout for esp32 is changed along with this branch. this step was necessary in order to resize (enlarge) the memory-region where especially the assignments for the rfid-tags are saved. as all permanent settings (e.g. wifi-settings) are saved there too, it's necessary to re-enter wifi-credentials after update. but the most important thing is to recover the assignments for the rfid-tags. please consult my migration-document.\nchangelog\nlast three events:\n13.11.2021: command cmd_tell_ip_address can now be assigned to buttons in order to get information about the currently used ip-address via speech.\n28.10.2021: added feature save_playpos_when_rfid_change. when enabled last playposition for audiobook is saved when new rfid-tag is applied. without having this feature enabled, it's necessary to press pause first, in order to do this manually.\n27.10.2021: added feature save_playpos_before_shutdown. when enabled last playposition for audiobook is saved when shutdown is initiated. without having this feature enabled, it's necessary to press pause first, in order to do this manually.\nknown bugs\nsome webstreams don't run. guess it's a combination of saturated connection-pool and lack of heap-memory. works probably better if esp32-wrover (e.g. lolin d32 pro) is used, as this chip has psram. advice: don't enable modules (e.g. mqtt) if you don't need them as this could save memory (and trouble).\nfor espuinos making use of spi for sd (instead of sd_mmc), there's currently a problem that sometimes leads to incomplete file-transfers via webtransfer or ftp. i'm about to investigate...\nespuino - what's that?\nthe basic idea of espuino is to provide a way, to use the arduino-platform for a music-control-concept that supports locally stored music-files without drm-restrictions. this basically means that rfid-tags are used to direct a music-player. even for kids this concept is simple: place an rfid-object (card, character) on top of a box and the music starts to play. place another rfid-object on it and anything else is played. simple as that.\nthe core of my implementation is based on the popular esp32 by espressif. having wifi-support out-of-the-box makes it possible to provide further features like an integrated ftp-server (to feed the player with music), smarthome-integration via mqtt, webradio and administration via webgui. and nonetheless bluetooth, too! however, my primary focus was to port the project to a modular base. having said this mp3-decoding is done in software with a dedicated \u00b5sd-card-slot and music-output is done via i2s-protocol. i did all my tests on adafruit's max98357a, uda1334 and headphone-pcb. hopefully, not only in theory, other dacs that support i2s can be used as well.\nhardware-setup\nthe heart of my project is an esp32 on a wemos lolin32 development-board. if ordered in china (aliexpress, ebay e.g.) it's pretty cheap (around 4\u20ac => ok meanwhile price has doubled...) but even in europe it's affordable. make sure to install the drivers for the usb/serial-chip (cp2102 e.g.). but probably it's better to use its big brother (which has battery-measurement, \u00b5sd-slot, psram already included): wemos lolin d32 pro.\nmax98357a (like adafruit's)\n\u00b5sd-card-reader; 3.3v only; supports spi + sd-mmc or cheaper\nrfid-reader rc-522\nrfid-reader pn5180\nrfid-tags\nneopixel-ring\nrotary encoder\nbuttons\nspeaker\n\u00b5sd-card: doesn't have to be a super-fast one; \u00b5c is limiting the throughput. tested 32gb without any problems.\ngetting started\nmuch documentation in german language.\ni recommend to install microsoft's visual studio code. this is a popular and powerful ide that gives you the ability to install tons of (well-supported) plugins.\ninstall platformio plugin into visual studio code and make sure to have a look at the documentation. step-by-step-manual is available here\ninstall git and make a copy (\"clone\") my repository to your local computer using git clone https://github.com/biologist79/espuino.git. using git you can keep your local repository easily up to date without doing copy'n'paste. to keep it up to date run git pull origin master. further infos here.\n(optional) install gitlens as plugin (to have advanced git-support).\nnow, that the git-repository is saved locally, import this folder into platformio as a project.\nthere's a file called platformio.ini, that contains the configuration for different develboards (e.g. env:lolin32). platformio supports hundrets of boards out of the box. so probably you need to change/extend that configuration-file. guess lolin32 is described in platformio.ini but you need lolin d32, then lookup platformio's documentation to know what to change.\ndepending on your operating system (windows, mac os, linux), you'll probably need to change upload_portand monitor_port as well.\nedit src/settings.h according your needs.\nedit board-specific (hal) config-file (e.g. settings-lolin32.h for lolin32 or settings-lolin_d32.h for lolin d32). if you're running a board that is not listed there: start with settings-custom.h and change it according your needs.\nconnect your develboard via usb, click the alien-head to the left, choose the project-task that matches your desired hal and run upload and monitor. all libraries necessary should be fetched in background now followed by code-compilation. after that, your esp32 is flashed with the firmware. depending on your develboard it might me necessary to push a button in order to allow esp32 to enter flashmode (not necessary f\u00fcr lolin32, d32 und d32 pro).\nnow have a look at the serial-output at the bottom of visual studio code's windows. at the first run there might appear a few error-messages (related to missing entries in nvs). don't worry, this is just normal. however, make sure sd is running as this is mandatory!\nif everything ran fine, at the first run, espuino should open an access-point with the name \"espuino\". join this wifi with your computer (or mobile) and enter http://192.168.4.1 to your webbrowser. enter wifi-credentials and the hostname. after saving the configuraton, restart espuino. hint: i tried to connect this access-point via android mobile. basically that's no problem, but as my mobile detected there'd be no internet-connection, it kept lte-connection open and prevented me from connecting to http://192.168.4.1. so if in doubts better use a computer.\nafter reboot espuino tries to join your wifi (with the credentials previously entered). if that was successful, an ip is shown in the serial-console of visual studio code. you can call espuino's gui using a webbrowser via this ip; make sure to allow javascript. if mdns-feature is active in src/settings.h, you can use the hostname configured extended by .local instead the ip. so if you configured espuino as hostname, you can use http://espuino.local for webgui and ftp.\nvia ftp and webgui you can upload data (but don't expect it to be super fast).\nftp needs to be activated after boot if you need it! don't forget to assign action enable_ftp_server in settings.h to be able to activate it. neopixel flashes green (1x) if enabling was successful. it'll be disabled automatically after next reboot. means: you have to enable it every time you need it (if reboot was in between). sounds annoying and maybe it is, but's running this way in order to have more heap-memory available (for webstream) if ftp isn't necessary.\nvia webbrowser you can configure various settings and pair rfid-tags with actions. if mqtt/ftp-support was not compiled, their config-tabs won't appear.\nprerequisites / tipps\nmuch much documentation in german language.\nopen settings.h\nchoose if optional modules (e.g. mqtt, ftp, neopixel) should be compiled/enabled.\nmake sure to edit/review button-layout. default-design is three buttons and a rotary-encoder. all actions available are listed in src/values.h (values with numbers >= 100).\nfor debugging-purposes serialdebug can be set to error, notice, info or debug. i usually have debug set.\nif neopixel enabled: set num_leds to the led-number of your neopixel-ring and define the neopixel-type using #define chipset\nopen board-specific config-file and edit according your needs.\nif you want to monitor battery's voltage, make sure to enable measure_battery_voltage. use a voltage-divider as voltage of a lipo is way too high for esp32 (only 3.3v supported!). for my tests i connected vbat with a serial connection of 130k + 130k resistors (vbat(+)--130k--x--130k--vbat(-)). x is the measure-point where to connect the gpio to. if using lolin d32 or lolin d32 pro, make sure to leave both resistor-values unchanged at 100k - voltage-divider is already integrated there. same goes for gpio: leave unchanged at 35. please note: via gui upper and lower voltage cut-offs for visualisation of battery-voltage (neopixel) is available. additional gui-configurable values are interval (in minutes) for checking battery voltage and the cut off-voltage below whose a warning is shown via neopixel.\nif you're using a headphone-pcb with a headphone jack that has a pin to indicate if there's a plug, you can use this signal along with the feature headphone_adjust_enable to limit the maximum headphone-voltage automatically. as per default you have to invert this signal (with a p-channel mosfet) and connect it e.g. to gpio22.\nenabling shutdown_if_sd_boot_fails is really recommended if you run your espuino in battery-mode without having a restart-button exposed to the outside of espuino's enclosure. because otherwise there's no way to restart your espuino and the error-state will remain until battery is empty (or you open the enclosure, hehe).\nenabling play_last_rfid_after_reboot will tell espuino to remember the last rfid-tag played after next reboot. so rebooting espuino will end up in autoplay.\nsd-card: spi or sd-mmc (1 bit)-mode?\nhaving sd working is mandatory! however, there are two modes available to access sd-cards: spi and sd-mmc (1 bit).\nadvantages sd-mmc (1 bit) over spi:\nneeds only three gpios (instead of four)\nit's faster. ftp-upload: 298 kib vs 178 kib. http-upload: 350 kib vs 184 kib. (tested with filesize of 70.7 mib.\nso why using spi if sd-mmc seems to be better? the primary problem of sd-mmc is: you cannot choose different gpios. that doesn't sound bad but this can (depending on the \u00b5sd-card-reader-module) be a problem because maybe gpio2 is pulled high to 3.3v by a 10k-resistor. for example this is the case when using the reader-module named above in hardware-setup. it's a problem because if gpio2 is pulled high at boot, esp32 doesn't enter flash-mode (so you cannot flash new firmwares). as soon as flash-mode is entered, it's no longer a problem. however, this behaviour can be an issue if esp32 is deeply \"burried\" in espuino's enclosure and you want to update its firmware. but fortunately there's a way to bypass this problem: remove the pullup-resistor shown in the picture. it can be removed safely because if mmc-mode is set because pullup is done in software using pinmode(2, input_pullup);. so it's not really a problem but you have to take note of that!\nrfid: rc522 or pn5180?\nrc522 is so to say the espuino-standard. it's cheap and works, but rfid-tag has to be placed near the reader. pn5180 instead has better rfid range/sensitivity and can read iso-15693 / icode slix2-tags aka 'tonies' (you need a password to read tonies), too. you can also wake-up the board with the card. disadvantages: it's more expensive and needs more gpios (6/7 instead of 4). refer pn5180's wire-section below for further informations. hint: if using 3.3v make sure to connect pn5180 to +5v and 3.3v. sounds weird but it's necessary.\n3.3 or 5v?\nwhy 3.3v? because: if you plan to use battery-mode with a lipo, there's no 5 v available (unless usb is connected). that's why my design's focus is on 3.3 v. if you want to use 5 v - do so, but be advised it's not compatible with lipo-battery-mode. the mosfet-circuit for saving power in deepsleep (see lolin32-schematics as reference) works as well for 5 v.\nmax98357a: provides more power at 5 v but also runs at 3.3 v. anyway: it's still loud enough (in my opinion).\nneopixel: specification says it needs 5 v but runs at 3.3 v as well.\nrc522: needs 3.3 v (don't power with 5 v!)\npn5180: at 3.3 v make sure to connect both 5 v and 3.3 v-pins to 3.3 v.\nsd: needs 3.3 v but if voltage-regulator is onboard, it can be connected to 5 v as well\nrotary encoder: 3.3 v (don't power with 5 v! encoder doens't care if connected to 3.3 or 5 v, but gpios of esp32 do!)\nwiring (general)\ni really really recommend to solder all the stuff onto a pcb as wiring the components with jumperwires on a breadboard can lead to many problems. especially for the interconnect between \u00b5c and \u00b5sd-card-reader make sure to use short wires (like 10cm or so)! so be aware of this! have a look at the pcb-folder and the forum. i provided pcbs for a few types of develboards (and others will follow...). important: you can easily connect another i2s-dacs by just connecting them in parallel to the i2s-pins (din, bclk, lrc). this is true for example if you plan to integrate a line/headphone-pcb. in general, this runs fine. but unfortunately especially this board lacks of a headphone jack, that takes note if a plug is inserted or not. best way is to use a headphone jack that has a pin that is pulled to gnd, if there's no plug and vice versa. using for example a mosfet-circuit, this gnd-signal can be inverted in a way, that max98357.sd is pulled down to gnd if there's a plug. doing that will mute max98537a and so turn off the speaker immediately if there's a plug and vice versa. have a look at the pcb-folder in order to view the detailed solution. here's an example for such a headphone-pcb that makes use of gnd.\nwiring (2 spi-instances: rc522 + spi-sd + 3 buttons + rotary-encoder)\nuses two spi-instances. the first one for the rfid-reader and the second for sd-card-reader. this is also the setup, i personally use primarily.\nesp32 (gpio) hardware pin comment\n3.3 (5) v sd-reader vcc connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd sd-reader gnd\n15 sd-reader cs\n13 sd-reader mosi\n16 sd-reader miso\n14 sd-reader sck\n3.3 v rfid-reader 3.3v connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd rfid-reader gnd\n21 rfid-reader cs/sda\n23 rfid-reader mosi\n19 rfid-reader miso\n18 rfid-reader sck\n5 / 3.3 v max98357 vin connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd max98357 gnd\n25 max98357 din\n27 max98357 bclk\n26 max98357 lrc\n--- max98357 sd info: if pulled down to gnd amp will turn off\n34 rotary encoder clk change clk with dt if you want to change the direction of re\n35 rotary encoder dt change clk with dt if you want to change the direction of re\n32 rotary encoder button\n3.3 v rotary encoder +\ngnd rotary encoder gnd\n4 button (next)\ngnd button (next)\n2 button (previous)\ngnd button (previous)\n5 button (pause/play)\ngnd button (pause/play)\n3.3 v neopixel v connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd neopixel g\n12 neopixel di\n17 n-channel mosfet gate\n33 voltage-divider / bat optional: voltage-divider to monitor battery-voltage\n22 headphone jack optional: if pulled to ground, headphone-volume is set\noptionally, gpio 17 can be used to drive a mosfet-circuit in order to switch off peripherals (sd, neopixel, rfid and max98357a) if esp32 is in deepsleep. please refer the schematics for my lolin32-pcb for further informations. if you need further informations on transistor-circuits visit this website.\nin general i recommend using a \u00b5sd-card-reader that can be run solely with 3.3v (doesn't have a voltage-regulator - don't use it with 5v!).\nwiring (sd-card in 1 bit sd-mmc mode) different to above\nesp32 (gpio) hardware pin comment\n-- sd-reader cs no cs required\n15 sd-reader mosi\n2 sd-reader miso make sure there's no hardware-pullup for miso\n14 sd-reader sck\nmake sure to enable sd_mmc_1bit_mode if you want to use this feature. don't(!) enable single_spi_enable. sd-mmc-mode requires these fixed pins listed above. you can find a good comparison of different sd-card-modes here: (https://www.instructables.com/select-sd-interface-for-esp32/). advice: double check that above pins are not used elsewhere (e.g. gpio2 is used as previous_button as per default in settings.h).\nwiring (1 spi-instance: rc522 + sd + 3 buttons + rotary-encoder) [experimental, maybe not working!]\nbasically the same as using 2 spi-instances but... in this case rfid-reader + sd-reader share spi's sck, miso and mosi. but make sure to use different cs-pins. have to admit i had problems to get this running. seems to be connected properly, but nothing happens when an rfid-tag is applied. maybe anybody else wants to point out :-)\nesp32 (gpio) hardware pin comment\n3.3 (5) v sd-reader vcc connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd sd-reader gnd\n15 sd-reader cs don't share with rfid!\n3.3 v rfid-reader 3.3v connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd rfid-reader gnd\n21 rfid-reader cs/sda don't share with sd!\n23 rfid+sd-reader mosi\n19 rfid+sd-reader miso\n18 rfid+sd-reader sck\n5 / 3.3 v max98357 vin connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd max98357 gnd\n25 max98357 din\n27 max98357 bclk\n26 max98357 lrc\n--- max98357 sd info: if pulled down to gnd amp will turn off\n34 rotary encoder clk change clk with dt if you want to change the direction of re\n35 rotary encoder dt change clk with dt if you want to change the direction of re\n32 rotary encoder button\n3.3 v rotary encoder +\ngnd rotary encoder gnd\n4 button (next)\ngnd button (next)\n2 button (previous)\ngnd button (previous)\n5 button (pause/play)\ngnd button (pause/play)\n5 / 3.3 v neopixel v connect to p-channel mosfet for power-saving when \u00b5c is off\ngnd neopixel g\n12 neopixel di\n17 n-channel mosfet gate\n33 voltage-divider / bat optional: voltage-divider to monitor battery-voltage\n22 headphone jack optional: if pulled to ground, headphone-volume is set\nwiring (pn5180 instead of mfrc522) different to above\npn5180-reader needs at least two more gpios: reset and busy. double check pin-conflicts! rfid_reader_type_pn5180 needs to be enabled to use this feature. make sure to disable rfid_reader_type_mfrc522 if doing so! you can enable low power card-detection with pn5180_enable_lpcd, but this needs another gpio for irq. with low power card detection (lpcd) you can wake-up the esp32 from deep-sleep just by applying a card to the reader. but: you need a pn5180-firmware >= 4.0 to use this feature. most china-boards come with an older firmware, so be advised to flash them to latest firmware using this project. there's a pcb available for pn5180: lolin32 + sd_mmc + pn5180.\nesp32 (gpio) hardware pin comment\n3.3 v pn5180 rfid-reader 3.3v connect to p-channel mosfet for power-saving when \u00b5c is off\n3.3 v 3.3v for low power card detection mode (lpcd) connect directly to 3.3v\n5 / 3.3 v pn5180 rfid-reader 5v don't forget to connect this pin the same way as 3.3v\ngnd pn5180 rfid-reader gnd\n21 pn5180 rfid-reader cs/sda same as mfrc522. don't share with sd!\n23 pn5180 rfid-reader mosi same as mfrc522\n19 pn5180 rfid-reader miso same as mfrc522\n18 pn5180 rfid-reader sck same as mfrc522\n16 pn5180 rfid-reader busy be aware of sd miso if running in spi mode\n22 pn5180 rfid-reader rst be aware of headphone jack pin\n39 pn5180 rfid-reader irq optional, used for low power card detection (lpcd)\nwiring (custom) / different pinout\nwhen using a develboard with sd-card-reader already integrated (lolin d32 pro, several ttgo-boards), the pinouts described above my not fit. feel free to change them according your needs. additionaly some boards may use one or some of the gpios i used for their internal purposes and that reason for are maybe not exposed via pin-headers. however, having them exposed doesn't mean they can be used without limits. this is because some gpios have to be logical low or high at start/boot for example and this is probably not the case when connecting stuff to it. feel free to adjust the gpios proposed by me (but be adviced it could take a while to get it running). if you encounter problems please refer the board's manual first.\nhere i described a solution for a board with many gpios used internally and a very limited number of gpios exposed. that's why i had to use different spi-gpios for rfid as well. espuino supports this board and there's a discussion.\nwifi\nwifi is mandatory for webgui, ftp and mqtt. however, wifi can be temporarily or permanently disabled. there are two ways to do that:\nuse a special modification-card that can be configured via webgui\nassign action cmd_toggle_wifi_status to a button (or multi-button). default: press previous + next-button in parallel shortly. now release both. this toggles the current wifi-status: if it's currently enabled, it will be disabled instantly and vice versa. please note: this wifi-status will remain until you change it again, which means, that espuino will remember this state after the next reboot. having wifi enabled is indicated in idle-mode (no playlist active) with four white slow rotating leds whereas disabled wifi is represented by those ones coloured green. bluetooth-mode is indicated by blue leds.\nbluetooth\nespuino can be used as bluetooth-sink (a2dp). this mode can be enabled/disabled via a rfid-modification-card or by assigning action cmd_toggle_bluetooth_mode to a button (or multi-button). applying this will restart espuino immediately. two modes are available which are toggled in between: \"normal\" and \"bluetooth\". normal means: sd + wifi are available whereas in mode \"bluetooth\" only bluetooth-support can be provided. activated bluetooth is indicated by four slow rotating blue leds. now you can stream to your espuino e.g. with your mobile device. tested this with android 8 and mac os: worked 100% flawless. please note: due to memory-restrictions it's not possible to run bluetooth in parallel with wifi.\nport-expander\nthere might be situations where you run out of gpios. to address this, port-expander pca9555 can be used to extend number of input-channels (output-mode is only supported in special cases). this port-expander provides 2 ports with 8 channels each - so 16 channels in total. to activate pca9555 you need to enable port_expander_enable. like gpios in your develboard-specific settings-file, you can assign numbers. range is 100->115 where 100: port 0 channel 0 -> 107: port 0 channel 7; 108: port 1 channel 0 -> 115: port 1 channel 7. via expanderi2caddress port-expander's i2c-address can be changed. it's 0x20 if all a0, a1, a2 are wired to gnd.\nafter espuino is connected to your wifi\nafter making espuino part of your lan/wifi, the 'regular' webgui is available at the ip assigned by your router (or the configured hostname). using this gui, you can:\nconfigure wifi\nmake binding between rfid-tag, file/directory/url and playmode\nmake bindings between rfid-tag and a modification-type\nconfigure mqtt (if enabled)\nconfigure ftp (if enabled)\nconfigure nitial volume, maximum volume (speaker / headphone), brightness of neopixel (nightmode / default) and inactivity-time\nview logs / status / current track\ncontrol player\nupload audiofiles (called webtransfer)\ndo ota-updates (esp32s with 16 mb of flash-memory only)\nimport + delete nvs-rfid-assigments\nrestart + shutdown espuino\nwebgui #1:\nwebgui #2:\nwebgui #3:\nwebgui #4:\nwebgui #5:\nwebgui #6:\nwebgui #7:\nwebgui: websocket broken:\nwebgui: action ok:\nplease note: as you apply a rfid-tag to the rfid-reader, the corresponding id is pushed to the gui. so there's no need to enter such ids manually (unless you want to). filepath is filled out automatically by selecting a file/directory in the filebrowser.\ninteracting with espuino\nplaymodes\nit's not just simply playing music; different playmodes are supported:\nsingle track => plays one track one time\nsingle track (loop) => plays one track forever\naudiobook => single file or playlist/folder; last play-position (file and playlist) is saved (when pushing pause or moving to another track) and re-used next time\naudiobook (loop) => same as audiobook but loops forever\nfolder/playlist (alph. sorted) => plays all tracks in alph. order from a folder one time\nfolder/playlist (random order) => plays all tracks in random order from a folder one time\nfolder/playlist (alph. sorted) => plays all tracks in alph. order from a folder forever\nfolder/playlist (random order) => plays all tracks in random order from a folder forever\nwebradio => always only one \"track\": plays a webstream\nlist (files from sd and/or webstreams) from local .m3u-file => can be one or more files / webradio-stations with local .m3u as sourcefile\nmodification rfid-tags\nthere are special rfid-tags, that don't start music by themself but can modify things. if applied a second time, it's previous action/modification will be reversed. please note: all sleep-modes do dimming (neopixel) automatically because it's supposed to be used in the evening when going to -----> bed !!! . well, at least that's my children's indication :-) so first make sure to start the music then use a modification-card in order to apply your desired modification:\nlock/unlock all buttons\nsleep after 5/30/60/120 minutes\nsleep after end of current track\nsleep after end of playlist\nsleep after five tracks\ndimm neopixel\ncurrent track in loop-mode (is \"stronger\" than playlist-loop but doesn't overwrite it!)\nplaylist in loop-mode\ntrack und playlist loop-mode can both be activated at the same time, but unless track-loop isn't deactivated, playlist-loop won't be effective\ntoggle wifi (enable/disable) => disabling wifi while webstream is active will stop a running webstream instantly!\ntoggle bluetooth (enable/disable) => restarts espuino immediately\nneopixel-ring (optional)\nindicates different things. don't forget configuration of number of leds via #define num_leds\nwhile booting: every second led (rotating orange)\nunable to mount sd: leds flashing red (will remain forever unless sd-card is available or shutdown_if_sd_boot_fails is active)\nidle: four leds slow rotating (white if wifi enabled; green if wifi disabled)\nbluetooth: four leds slow rotating coloured blue\nerror: all leds flashing red (1x) if an action was not accepted\nok: all leds flashing green (1x) if an action was accepted\nbusy: violet; four fast rotating leds when generating a playlist. duration depends on the number of files in your playlist.\ntrack-progress: rainbow; number of leds relative to play-progress\nplaylist-progress: blue; appears only shortly in playlist-mode with the beginning every new track; number of leds relative to progress\nwebstream: two slow rotating leds that change their colours rainbow-wise as the stream proceeds\nvolume: green => red-gradient; number of leds relative from current to max volume\nswitching off: red-circle that grows until long-press-time is reached\nbuttons locked: track-progress-leds coloured red\npaused: track-progress-leds coloured orange\nrewind: if single-track-loop is activated a led-rewind is performed when restarting the given track\n(optional) undervoltage: flashes three times red if battery-voltage is too low. this voltage-level can be configured via gui.\n(optional) short press of rotary encoder's button provides battery-voltage visualisation via neopixel. upper und lower voltage cut-offs can be adjusted via gui. so for example if lower voltage is set to 3.2 v and upper voltage to 4.2 v, 50% of the leds indicate a voltage of 3.7 v.\nplease note: some neopixels use a reversed addressing which leads to the 'problem', that all effects are shown counter clockwise. if you want to change that behaviour, just enable neopixel_reverse_rotation.\nbuttons\nimportant: this section describes my default-design: 3 buttons + rotary-encoder. feel free to change button-number and button-actions according your needs in settings.h and your develboard-specific config-file (e.g. settings-lolin32.h). at maximum you can activate five buttons + rotary-encoder. minimum duration for long press (to distinguish vom short press) in ms is defined by intervaltolongpress. all actions available are listed in src/values.h. if using gpio >= 35 make sure to add a external pullup-resistor (10 k).\nprevious (short): previous track / beginning of the first track if pressed while first track is playing\nprevious (long): first track of playlist\nnext (short): next track of playlist\nnext (long): last track of playlist\npause/play (short/long): pause/play\nrotary encoder (turning): vol +/-\nrotary encoder (button long): switch off (only when on)\nrotary encoder (button short): switch on (when switched off)\nrotary encoder (button short): show battery-voltage via neopixel (when switched on and measure_battery_voltage is active)\nprevious (long; keep pressed) + next (short) + release (both): toggle wifi enabled/disabled\nmusic-play\nmusic starts to play right after a valid rfid-tag was applied.\nif play_last_rfid_after_reboot is active, espuino will remember the last rfid applied => music-autoplay.\nif a folder should be played that contains many mp3s, the playlist-generation can take a few seconds.\nfor all playmodes that are not single tracks or webradio a filecache is available to speed up playlist-generation. the cache is generated as you apply the corresponding rfid-tag for the first time. use cached_playlist_enable to enable it - i really recommend to use it.\na file's name including path isn't allowed exceed 255 characters.\nwhile playlist is generated neopixel indicates busy-mode.\nafter last track was played, neopixel indicates idle-mode.\naudiobook-mode\nthis mode is different from the others because the last playposition is saved. playposition is saved when...\nnext track starts.\nfirst/previous/last track requested by button.\npause was pressed.\ntrack is over.\nplaylist is over (playposition is set back to the first track and file-position 0).\nplease note: last playposition is not saved when applying a new rfid-tag. this is intended because otherwise you wouldn't have a possibility to not save it. if you want to save the playposition: press pause first.\nftp (optional)\nftp needs to be activated after boot! don't forget to assign action enable_ftp_server in settings.h or use a modification-card to to activate it! neopixel flashes green (1x) if enabling was successful. it'll be disabled automatically after next reboot. means: you have to enable it every time you need it (if reboot was in between). sounds annoying and maybe it is, but's running this way in order to save heap-memory when ftp isn't needed.\nwhy ftp? well: in order to avoid exposing \u00b5sd-card or disassembling espuino all the time for adding new music, it's possible to transfer music to the \u00b5sd-card using ftp. another possibility is to do via webgui (webtransfer).\ndefault-user and password are set to esp32 / esp32 but can be changed via gui.\nmake sure to set the max. number of parallel connections to one in your ftp-client and the charset to cp437. cp437 is important if you want to use german umlauts (\u00f6\u00e4\u00fc\u00df).\nsecured ftp is not available. so make sure to disable ssl/tls.\nsoftware: my recommendation is filezilla as it's free and available for multiple platforms.\ndon't expect a super fast data-transfer; it's around 185 kb/s (spi-mode) and 310 kb/s (mmc-mode).\nplease note: if music is played in parallel, this rate decrases dramatically! so better stop playback when doing a ftp-transfer.\nenergy saving\nas already described in the modify-section, there are different sleepmodes available. additionaly \u00b5c will be put into deepsleep after 10 minutes of inactivity (configurable my maxinactivitytime) unless espuino doesn't play music, has a ftp-client connected and any input via buttons. every button-interaction resets the counter.\nmqtt (optional)\neverything that can be controlled via rfid-tags and buttons, can also be controlled via mqtt (excepting toggling wifi-status as this doesn't make sense). all manual interactions (buttons, rfid-tags) are also sent to mqtt in parallel, so everything is always in-sync (unless wifi/mqtt-connection is broken). in my home-setup i'm using openhab to \"encapsulate\" mqtt into a nice gui, that's accessible via app + web. i described a sample-config for openhab2. however, meanwhile openhab3 is available and all the stuff described can also be configured via gui. be advised that openhab is pretty complex and you have to spend some time to get familiar with it.\nsupported file/stream-types\nplease refer esp32-audioi2s, as this is the library i used for music-decoding. make sure to update especially this library regularly as it's development is still in progress.\nbackups\nas all assignments between rfid-ids and actions (playmode, file to play...) is saved in esp's nvs, the problem is that it's all gone when the esp is broken. so that's where a backup comes into play. so every time you change or add a new assignment between a rfid-tag and an action via gui, a backup-file is saved on the \u00b5sd-card. the file's name can be changed via backupfile. so better don't delete it! using the webgui you can use the upload-form to import such a file.\nsmarthome (optional)\nas already described, mqtt is supported. in order to use it it's necessary to run a mqtt-broker; mosquitto for instance. after connecting to it, espuino subscribes to all command-topics. state-topics are used to push states to the broker in order to inform others if anything changed (change of volume, new playlist, new track... name it). others, like openhab, subscribe to state-topics end send commands via command-topics. so it's not just limited to openhab. it's just necessary to use a platform, that supports mqtt. for further informations (and pictures) refer the subfolder.\nmqtt-topics and their ranges\nfeel free to use your own smarthome-environments (instead of openhab). the mqtt-topics available are described as follows. please note: if you want to send a command to espuino, you have to use a cmnd-topic whereas espuino pushes its states back via state-topics. so guess you want to change the volume to 8 you have to send this number via topic-variable topicloudnesscmnd. immediately after doing to, espuino sends a conformation of this command using topicloudnessstate. to get hands on mqtt i recommend this one as introducton (covers more than you need for espuino).\ntopic-variable range meaning\ntopicsleepcmnd 0 or off power off espuino immediately\ntopicsleepstate on or off sends espuino's current/last state\ntopicrfidcmnd 12 digits set number of rfid-tag which 'emulates' an rfid-tag (e.g. 123789456089)\ntopicrfidstate 12 digits id of current rfid-tag (if not a modification-card)\ntopictrackstate string sends current track number, total number of tracks and full path of curren track. e.g. \"(2/10) /mp3/kinderlieder/ri ra rutsch.mp3\"\ntopictrackcontrolcmnd 1 -> 7 1=stop; 2=unused!; 3=play/pause; 4=next; 5=prev; 6=first; 7=last\ntopicloudnesscmnd 0 -> 21 set loudness (depends on minvolume / maxvolume)\ntopicloudnessstate 0 -> 21 sends loudness (depends on minvolume / maxvolume\ntopicsleeptimercmnd eop power off after end to playlist\neot power off after end of track\neo5t power off after end of five tracks\n1 -> 2^32 duration in minutes to power off\n0 deactivate timer (if active)\ntopicsleeptimerstate various sends active timer (eop, eot, eo5t, 0, ...)\ntopicstate online, offline online when powering on, offline when powering off\ntopiccurrentipv4ip ipv4-string sends espuino's ip-address (e.g. 192.168.2.78)\ntopiclockcontrolscmnd on, off set if controls (buttons, rotary encoder) should be locked\ntopiclockcontrolsstate on, off sends if controls (buttons, rotary encoder) are locked\ntopicplaymodestate 0 - 10 sends current playmode (single track, audiobook...; see playmodes)\ntopicrepeatmodecmnd 0 - 3 set repeat-mode: 0=no; 1=track; 2=playlist; 3=both\ntopicrepeatmodestate 0 - 3 sends repeat-mode\ntopicledbrightnesscmnd 0 - 255 set brightness of neopixel\ntopicledbrightnessstate 0 - 255 sends brightness of neopixel\ntopicbatteryvoltage float voltage (e.g. 3.81)\ntopicwifirssistate int numeric wifi signal-strength (dbm)", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000354, "year": null}, {"Unnamed: 0": 2402, "autor": 362, "date": null, "content": "Load Cell Occupancy Sensor\nWhat is it?\nThis project is a occupancy sensor that uses a load cell for couches and beds, transmitting data to my Home Assistant server via MQTT over Ethernet.\nWhy?\nOther bed occupancy sensors that I have used in my home automation setup trigger false negatives when rolling around at night. I use bed occupancy to turn on my lights if I get up at night, and I wanted a faster, more accurate solution.\nWhy PoE?\nWireless home automation devices often make sense only when they are battery powered, if a power cable needs to be run to the device it can carry data too. Designing a low power wireless device is far more complicated than designing a wired device and running an Ethernet cable.\nOverview\nLoad cells \u2192 HX711 (ADC) \u2192 ATMega328P (MCU) \u2192 W5100 (Ethernet) \u2192 MQTT Broker \u2192 Home Assistant\nThis sensor takes input from 4 load cells, each supporting one leg of a bed or couch. The load cells are sampled with a ATMega328P (Arduino) using an HX711 load cell ADC. These samples are then transmitted to an MQTT broker via the Wiznet W5100 (same as Arduino Ethernet shield).\nProject Contents\nLoadCell_ArduinoCode - firmware for the ATMega328P\nLoadCell_Case - 3D printable case designed in OpenSCAD\nLoadCell_Holder - 3D printable holder for the load cells designed in OpenSCAD\nLoadCell_HomeAssistant - example Home Assistant configuration\nLoadCell_KiCAD - schematic and PCB\nMedia\nSoftware Used\nKiCad\nArduino IDE\nOpenSCAD\nLibre Office\nHome Assistant\nArduino Libraries used\nSparkfun HX711 Library\nArduino MQTT Client\nForks\nESP8266 Load Cell - wireless edition", "link": "https://github.com/newAM/LoadCellOccupany", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "beds", "selectorShort": "bed", "MarkedSent": "load cell occupancy sensor\nwhat is it?\nthis project is a occupancy sensor that uses a load cell for couches and -----> beds !!! , transmitting data to my home assistant server via mqtt over ethernet.\nwhy?\nother bed occupancy sensors that i have used in my home automation setup trigger false negatives when rolling around at night. i use bed occupancy to turn on my lights if i get up at night, and i wanted a faster, more accurate solution.\nwhy poe?\nwireless home automation devices often make sense only when they are battery powered, if a power cable needs to be run to the device it can carry data too. designing a low power wireless device is far more complicated than designing a wired device and running an ethernet cable.\noverview\nload cells \u2192 hx711 (adc) \u2192 atmega328p (mcu) \u2192 w5100 (ethernet) \u2192 mqtt broker \u2192 home assistant\nthis sensor takes input from 4 load cells, each supporting one leg of a bed or couch. the load cells are sampled with a atmega328p (arduino) using an hx711 load cell adc. these samples are then transmitted to an mqtt broker via the wiznet w5100 (same as arduino ethernet shield).\nproject contents\nloadcell_arduinocode - firmware for the atmega328p\nloadcell_case - 3d printable case designed in openscad\nloadcell_holder - 3d printable holder for the load cells designed in openscad\nloadcell_homeassistant - example home assistant configuration\nloadcell_kicad - schematic and pcb\nmedia\nsoftware used\nkicad\narduino ide\nopenscad\nlibre office\nhome assistant\narduino libraries used\nsparkfun hx711 library\narduino mqtt client\nforks\nesp8266 load cell - wireless edition", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000362, "year": null}, {"Unnamed: 0": 2506, "autor": 466, "date": null, "content": "Arduino Pro Mini 328\nArduino Pro Mini 328 - 5V/16MHz [DEV-11113] Arduino Pro Mini 328 - 3.3V/8MHz [DEV-11114]\nSparkFun's Arduino Pro Mini 328 is a bare bones super small Arduino compatible development board. This hardware is used for both the 3.3V/8MHz and the 5V/16MHz versions.\nBoth of these products use the same PCB, but are populated with unique voltage regulators and resonators.\nRepository Contents\n/Documentation - SVG and PDF datasheets for the Pro Mini\n/Hardware - Eagle design files (Schematic and Board)\n/Production - Test bed files and production panel files\nDocumentation\nHookup Guide - Basic hookup guide for the Arduino Pro Mini 3.3V/8MHz. It can be used as a guide with the 5V. The only difference when following the tutorial is selecting the board definition in the Arduino IDE and the voltage levels.\nProduct Versions\nDEV-11113- 5V/16MHz Pro Mini\nDEV-15254- 5V/16MHz Pro Mini Starter Kit\nDEV-11114- 3.3V/8MHz Pro Mini\nDEV-15257- 3.3V/8MHz Pro Mini Starter Kit\nLicense Information\nThe hardware is released under Creative Commons Share-alike 3.0.\nHardware authors: Original Arduino Mini design by Team Arduino\nPro Mini design by Nathan Seidle @ SparkFun Electonics\nRevision work by Pete Lewis @ SparkFun Electonics\nDistributed as-is; no warranty is given.", "link": "https://github.com/sparkfun/Arduino_Pro_Mini_328", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "bed", "selectorShort": "bed", "MarkedSent": "arduino pro mini 328\narduino pro mini 328 - 5v/16mhz [dev-11113] arduino pro mini 328 - 3.3v/8mhz [dev-11114]\nsparkfun's arduino pro mini 328 is a bare bones super small arduino compatible development board. this hardware is used for both the 3.3v/8mhz and the 5v/16mhz versions.\nboth of these products use the same pcb, but are populated with unique voltage regulators and resonators.\nrepository contents\n/documentation - svg and pdf datasheets for the pro mini\n/hardware - eagle design files (schematic and board)\n/production - test -----> bed !!!  files and production panel files\ndocumentation\nhookup guide - basic hookup guide for the arduino pro mini 3.3v/8mhz. it can be used as a guide with the 5v. the only difference when following the tutorial is selecting the board definition in the arduino ide and the voltage levels.\nproduct versions\ndev-11113- 5v/16mhz pro mini\ndev-15254- 5v/16mhz pro mini starter kit\ndev-11114- 3.3v/8mhz pro mini\ndev-15257- 3.3v/8mhz pro mini starter kit\nlicense information\nthe hardware is released under creative commons share-alike 3.0.\nhardware authors: original arduino mini design by team arduino\npro mini design by nathan seidle @ sparkfun electonics\nrevision work by pete lewis @ sparkfun electonics\ndistributed as-is; no warranty is given.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000466, "year": null}, {"Unnamed: 0": 2646, "autor": 606, "date": null, "content": "SparkFun Weather Shield\nSparkFun Weather Shield (DEV-13956)\nWeather Shield is an Arduino shield that gathers relative humidity, barometric pressure, temperature, light intensity, as well as optional rain, wind direction, and wind speed (using optional external weather gauges).\nRepository Contents\n/Firmware - Example Arduino sketch to demostrate how to read from the various sensors.\n/Fritzing - Fritzing Example wiring images\n/Hardware - All the Eagle PCB design files (.brd, .sch).\n/Production - Test bed files and production panel files\nDocumentation\nInstalling an Arduino Library Guide - Basic information on how to install an Arduino library.\nMPL3115A2 Library - MPL3115A2 library required for Weather Shield examples.\nSi7021 Library - Si7021 humidity sensor library required for Weather Shield examples.\nHookup Guide - Basic hookup guide for the Weather Shield v1.2.\nSparkFun Fritzing repo - Fritzing diagrams for SparkFun products.\nSparkFun 3D Model repo - 3D models of SparkFun products.\nHTU21D Library - The HTU21D humidity sensor was used on DEV-12081 and prior versions of the Weather Shield so if you have an older version you may need this library to run the examples.\nProduct Versions\nDEV-13956- V1.2 w/ Si7021\nDEV-12081 (Retired)- HTU21D\nVersion History\nv1.2 - Latest Version\nv1.1 - Initial Release\nLicense Information\nThis product is open source!\nPlease review the LICENSE.md file for license information.\nIf you have any questions or concerns on licensing, please contact techsupport@sparkfun.com.\nDistributed as-is; no warranty is given.\nYour friends at SparkFun.", "link": "https://github.com/sparkfun/Weather_Shield", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "bed", "selectorShort": "bed", "MarkedSent": "sparkfun weather shield\nsparkfun weather shield (dev-13956)\nweather shield is an arduino shield that gathers relative humidity, barometric pressure, temperature, light intensity, as well as optional rain, wind direction, and wind speed (using optional external weather gauges).\nrepository contents\n/firmware - example arduino sketch to demostrate how to read from the various sensors.\n/fritzing - fritzing example wiring images\n/hardware - all the eagle pcb design files (.brd, .sch).\n/production - test -----> bed !!!  files and production panel files\ndocumentation\ninstalling an arduino library guide - basic information on how to install an arduino library.\nmpl3115a2 library - mpl3115a2 library required for weather shield examples.\nsi7021 library - si7021 humidity sensor library required for weather shield examples.\nhookup guide - basic hookup guide for the weather shield v1.2.\nsparkfun fritzing repo - fritzing diagrams for sparkfun products.\nsparkfun 3d model repo - 3d models of sparkfun products.\nhtu21d library - the htu21d humidity sensor was used on dev-12081 and prior versions of the weather shield so if you have an older version you may need this library to run the examples.\nproduct versions\ndev-13956- v1.2 w/ si7021\ndev-12081 (retired)- htu21d\nversion history\nv1.2 - latest version\nv1.1 - initial release\nlicense information\nthis product is open source!\nplease review the license.md file for license information.\nif you have any questions or concerns on licensing, please contact techsupport@sparkfun.com.\ndistributed as-is; no warranty is given.\nyour friends at sparkfun.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000606, "year": null}, {"Unnamed: 0": 2694, "autor": 654, "date": null, "content": "MQTT catFeeder\ncatFeeder is an Arduino (ESP8266) MQTT controlled cat feeder which I use to feed my cats when I'm away or in the bed at 6.30 AM on a Sunday morning. The project is forked upon https://github.com/jorgerance/catFeeder which usees a telegram bot.\ni also added a pushbutton for manual operation and Home-assistant integration through a script and 2 mqtt sensor.\nAbout the ESP8266:\nWikipedia:\nThe ESP8266 is a low-cost Wi-Fi chip with full TCP/IP stack and MCU (microcontroller unit) capability produced by Shanghai-based Chinese manufacturer, Espressif Systems.\nClick here to access the full article\nMain features:\nControlled via MQTT.\nWifi connection.\nPossibility to check how much food can be still delivered with an HC-SR04 ultrasonic ranging sensor.\nMulti access point (can manage more than one SSID / password). Removed because i dont need it, could be easily reintegrated?\nMaterials Needed:\n1 x NodeMCU V3 dev board (esp8266): ~2.65 USD. / ~5\u20ac\n1 x NodeMCU Base Breadboard (optional): ~1.88 USD. / 3\u20ac\n1 x L298N Dual H bridge driver: ~3.33 USD. / 7\u20ac\n1 x HC-SR04 ultrasonic ranging sensor: ~1.50 USD. / 2\u20ac\n1 x 12V 2A Power Supply*: ~6.58 USD. / i had one around :)\n1 x Cereal dispenser: ~10.00 USD. / ~ 12\u20ac for a dual\n2 x MDF pieces, i used 45x15 and 15x15: ~6.00 USD. / 2-4 \u20ac worth of MDF\n2 x Little metal L bracket\n1 x Plastic enclosure for PSU: ~4.00 USD. / 1\u20ac for a standard elecrtical box\n1 x 4 pieces lot 5x8mm couplings: ~5.50 USD. / 8.99 \u20ac\n1 x NEMA 17 Motor 1.7A: ~9.00 USD. // 12\u20ac\n1 x Misc. cables: ~2.00 USD. // had some laying around\n1 x Can of acrylic spray paint 5\u20ac\n**Total cost: up to what you have available :)\nSchematics:\nThere's actually no need of perfboard / protoboard. However, in order to mount the HC-SR04 on the top of the cereal dispenser you may use a hot glue gun.\nParameters to be updated on the .ino file:\nJust search for REPLACEME inside the ino before uploading.\nNecessary libraries:\n#include <Stepper.h>\n#include <ESP8266WiFi.h>\n#include <ArduinoOTA.h>\n#include <PubSubClient.h>\n#include <NTPClient.h> (using a fork for leveraging getFormattedDate() find it here: https://github.com/taranais/NTPClient/releases)\nHow to control the cat feeder via mqtt/Home Assistant:\njust publish \"feed\" to the MQTT command channel, which if you dont change anything is home/catfeeder/feed\nYou can use the script i provided under the HASS folder.", "link": "https://github.com/lance36/catFeeder", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "bed", "selectorShort": "bed", "MarkedSent": "mqtt catfeeder\ncatfeeder is an arduino (esp8266) mqtt controlled cat feeder which i use to feed my cats when i'm away or in the -----> bed !!!  at 6.30 am on a sunday morning. the project is forked upon https://github.com/jorgerance/catfeeder which usees a telegram bot.\ni also added a pushbutton for manual operation and home-assistant integration through a script and 2 mqtt sensor.\nabout the esp8266:\nwikipedia:\nthe esp8266 is a low-cost wi-fi chip with full tcp/ip stack and mcu (microcontroller unit) capability produced by shanghai-based chinese manufacturer, espressif systems.\nclick here to access the full article\nmain features:\ncontrolled via mqtt.\nwifi connection.\npossibility to check how much food can be still delivered with an hc-sr04 ultrasonic ranging sensor.\nmulti access point (can manage more than one ssid / password). removed because i dont need it, could be easily reintegrated?\nmaterials needed:\n1 x nodemcu v3 dev board (esp8266): ~2.65 usd. / ~5\u20ac\n1 x nodemcu base breadboard (optional): ~1.88 usd. / 3\u20ac\n1 x l298n dual h bridge driver: ~3.33 usd. / 7\u20ac\n1 x hc-sr04 ultrasonic ranging sensor: ~1.50 usd. / 2\u20ac\n1 x 12v 2a power supply*: ~6.58 usd. / i had one around :)\n1 x cereal dispenser: ~10.00 usd. / ~ 12\u20ac for a dual\n2 x mdf pieces, i used 45x15 and 15x15: ~6.00 usd. / 2-4 \u20ac worth of mdf\n2 x little metal l bracket\n1 x plastic enclosure for psu: ~4.00 usd. / 1\u20ac for a standard elecrtical box\n1 x 4 pieces lot 5x8mm couplings: ~5.50 usd. / 8.99 \u20ac\n1 x nema 17 motor 1.7a: ~9.00 usd. // 12\u20ac\n1 x misc. cables: ~2.00 usd. // had some laying around\n1 x can of acrylic spray paint 5\u20ac\n**total cost: up to what you have available :)\nschematics:\nthere's actually no need of perfboard / protoboard. however, in order to mount the hc-sr04 on the top of the cereal dispenser you may use a hot glue gun.\nparameters to be updated on the .ino file:\njust search for replaceme inside the ino before uploading.\nnecessary libraries:\n#include <stepper.h>\n#include <esp8266wifi.h>\n#include <arduinoota.h>\n#include <pubsubclient.h>\n#include <ntpclient.h> (using a fork for leveraging getformatteddate() find it here: https://github.com/taranais/ntpclient/releases)\nhow to control the cat feeder via mqtt/home assistant:\njust publish \"feed\" to the mqtt command channel, which if you dont change anything is home/catfeeder/feed\nyou can use the script i provided under the hass folder.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000654, "year": null}], "name": "bedarduino"}
{"interestingcomments": [{"Unnamed: 0": 2889, "autor": 849, "date": null, "content": "Open SAE J1939\nSAE J1939 is a protocol for shaping the CAN-bus message in a specific way that suits industrial vehicles such as tractors, machinery, trucks and more.\nSAE J1939 is a very easy protocol to use, but there is a lack of information about SAE J1939, due to the cost of the protocol document, available how to shape a CAN-bus message according to SAE J1939 protocol standard. So therefore I\u2019m writing a SAE J1939 protocol available for free to use on any embedded systems such as STM32, Arduino, AVR, PIC etc or PC.\nTo learn to build on this project, you need first to understand SAE J1939. I have written this project in C language because C is an industry standard. The C language dialect I have chosen is C99 and I don't use dynamical memory allocation in this library. So it will work with MISRA C standard.\nWith this library, you can communicate with valves, engines, actuators, machinery, hardware and all other things that are suitable for heavy industrial mobile applications. I have build up a basic structure of the project and I hope that other users will send pull request of their C code for extra functionality to SAE J1939 standard because SAE J1939 is a huge standard.\nLooking for CANopen library? https://github.com/DanielMartensson/Easy-CANopen/\nGetting started\nThe first thing you need to know is to read the document Open SAE J1939.pdf inside the Documentation folder. Learn the structure of the project, else you won't be able to understand SAE J1939. After you have got a basic understanding of the project, you are able to build on it. Keep it simple and follow the SAE J1939 standard!\nAfter you have understand the structure of the project, then select processor choice in Hardware -> Hardware.h file. Here you can select for example STM32, Arduino, PIC, AVR etc. or if you want to run it on PC first, then select PROCESSOR_CHOICE 0 and run some examples. That's the debugging mode for internal CAN feedback.\nHow to use the project\nStep 1: Download this repository\nStep 2: Go to Hardware -> Hardware.h and select your processor, if it's not available, please write code for it and send me a pull request\nStep 3: Copy over the Src folder to your project folder inside your IDE. Rename Src to for example Open SAE J1939. That's a good name.\nStep 4: Use the Examples -> Open SAE J1939 -> Startup.txt example as your initial starting code for a SAE J1939 project.\n#include <stdlib.h>\n#include <stdio.h>\n/* Include Open SAE J1939 */\n#include \"Open_SAE_J1939/Open_SAE_J1939.h\"\n/* Include ISO 11783 */\n#include \"ISO_11783/ISO_11783-7_Application_Layer/Application_Layer.h\"\nint main() {\n/* Create our J1939 structure */\nJ1939 j1939 = {0};\n/* Load your ECU information */\nOpen_SAE_J1939_Startup_ECU(&j1939);\nwhile(1) {\n/* Read incoming messages */\nOpen_SAE_J1939_Listen_For_Messages(&j1939);\n/* Your application code here */\n}\nreturn 0;\n}\nSee the examples in Examples -> SAE J1939 how to change the address, NAME or identifications for your ECU.\nThe structure of the project\nSAE J1939 functionality\nSAE J1939:21 Transport Layer\nAcknowledgement\nRequest\nTransport Protocol Connection Management\nTransport Protocol Data Transfer\nSAE J1939:71 Application Layer\nRequest Component Identification\nRequest ECU Identification\nRequest Software Identification\nSAE J1939:73 Diagnostics Layer\nDM1\nDM2\nDM3\nDM14\nDM15\nDM16\nSAE J1939:81 Network Management Layer\nAddress Claimed\nCommanded Address\nAddress Not Claimed\nDelete Address\nExtra functionality\nISO 11783 Tractors And Machinery For Agriculture And Forestry\nISO 11783-7 Implement Messages Application Layer\nAuxiliary Valve Command\nAuxiliary Valve Estimated Flow\nAuxiliary Valve Measured Position\nGeneral Purpose Valve Command\nGeneral Purpose Valve Estimated Flow\nQuestions and answers\nQ: Can this library be used with C++?\nA: Yes it can be used with C++\nQ: I want to build on this library, what should I do?\nA: First you need to know C99 and bitwise operations. Then you need to understand the SAE J1939:21 Transport Layer structure. Don't forget to update the PDF with your new functionality.\nQ: Can I use this on my Arduino?\nA: Yes, this C code is 100% pure C code and only using C standard library and also the code does not take account of what hardware you are using.\nQ: Do I need to install the library for to use the library?\nA: No, just copy over the .c and .h files to your project and compile. I have used this with QT framework.\nQ: This project is quite old now and not so much updates, is it still worth to use it?\nA: Yes, this library only updates when I or other includes more functionality from SAE J1939. The reason why I wrote this in C99 is because it's an industry standard and will you will always be able to compile this library and use it.\nQ: What is your plan with the library?\nA: To make SAE J1939 available for everybody\nQ: I don't have CAN-bus, but can I use this library anyway with UART, USB, WiFi etc?\nA: Yes. This is only a way to shape a massage in a specific way.\nQ: Can I send data with this library, even if I don't have CAN-bus?\nA: Yes. There are something called DM14 transmit request, DM15 status response and DM16 binary transfer. Use that if you want to transfer data in an industrial way.\nQ: Can I send multi package messages from from multiple ECU:s to one ECU at the same time?\nA: No. If you starting to send multipackages from multiple ECU:s to another ECU, then that ECU cannot understand the message. Transmit only multipackage messages one at the time if the destination address is the same.\nIssues and answers\nI: I cannot compile this library. I'm using Keil Microvision.\nA: Keil Microvision cannot handle binary numbers such as 0b010101. Try STM32CubeIDE instead because Open SAE J1939 is made in STM32CubeIDE\nI: Can you provide us with some hardware examples for example STM32?\nA: Yes! There is a STM32 example how to get connection with CAN-bus including an interrupt listener for messages. Go to Examples -> Hardware folder at look for CAN_STM32.txt. Also there is a USB example as well for QT C++.", "link": "https://github.com/DanielMartensson/Open-SAE-J1939", "origin": "Github", "suborigin": "arduino", "result": true, "Selector": "forestry", "selectorShort": "forestry", "MarkedSent": "open sae j1939\nsae j1939 is a protocol for shaping the can-bus message in a specific way that suits industrial vehicles such as tractors, machinery, trucks and more.\nsae j1939 is a very easy protocol to use, but there is a lack of information about sae j1939, due to the cost of the protocol document, available how to shape a can-bus message according to sae j1939 protocol standard. so therefore i\u2019m writing a sae j1939 protocol available for free to use on any embedded systems such as stm32, arduino, avr, pic etc or pc.\nto learn to build on this project, you need first to understand sae j1939. i have written this project in c language because c is an industry standard. the c language dialect i have chosen is c99 and i don't use dynamical memory allocation in this library. so it will work with misra c standard.\nwith this library, you can communicate with valves, engines, actuators, machinery, hardware and all other things that are suitable for heavy industrial mobile applications. i have build up a basic structure of the project and i hope that other users will send pull request of their c code for extra functionality to sae j1939 standard because sae j1939 is a huge standard.\nlooking for canopen library? https://github.com/danielmartensson/easy-canopen/\ngetting started\nthe first thing you need to know is to read the document open sae j1939.pdf inside the documentation folder. learn the structure of the project, else you won't be able to understand sae j1939. after you have got a basic understanding of the project, you are able to build on it. keep it simple and follow the sae j1939 standard!\nafter you have understand the structure of the project, then select processor choice in hardware -> hardware.h file. here you can select for example stm32, arduino, pic, avr etc. or if you want to run it on pc first, then select processor_choice 0 and run some examples. that's the debugging mode for internal can feedback.\nhow to use the project\nstep 1: download this repository\nstep 2: go to hardware -> hardware.h and select your processor, if it's not available, please write code for it and send me a pull request\nstep 3: copy over the src folder to your project folder inside your ide. rename src to for example open sae j1939. that's a good name.\nstep 4: use the examples -> open sae j1939 -> startup.txt example as your initial starting code for a sae j1939 project.\n#include <stdlib.h>\n#include <stdio.h>\n/* include open sae j1939 */\n#include \"open_sae_j1939/open_sae_j1939.h\"\n/* include iso 11783 */\n#include \"iso_11783/iso_11783-7_application_layer/application_layer.h\"\nint main() {\n/* create our j1939 structure */\nj1939 j1939 = {0};\n/* load your ecu information */\nopen_sae_j1939_startup_ecu(&j1939);\nwhile(1) {\n/* read incoming messages */\nopen_sae_j1939_listen_for_messages(&j1939);\n/* your application code here */\n}\nreturn 0;\n}\nsee the examples in examples -> sae j1939 how to change the address, name or identifications for your ecu.\nthe structure of the project\nsae j1939 functionality\nsae j1939:21 transport layer\nacknowledgement\nrequest\ntransport protocol connection management\ntransport protocol data transfer\nsae j1939:71 application layer\nrequest component identification\nrequest ecu identification\nrequest software identification\nsae j1939:73 diagnostics layer\ndm1\ndm2\ndm3\ndm14\ndm15\ndm16\nsae j1939:81 network management layer\naddress claimed\ncommanded address\naddress not claimed\ndelete address\nextra functionality\niso 11783 tractors and machinery for agriculture and -----> forestry !!! \niso 11783-7 implement messages application layer\nauxiliary valve command\nauxiliary valve estimated flow\nauxiliary valve measured position\ngeneral purpose valve command\ngeneral purpose valve estimated flow\nquestions and answers\nq: can this library be used with c++?\na: yes it can be used with c++\nq: i want to build on this library, what should i do?\na: first you need to know c99 and bitwise operations. then you need to understand the sae j1939:21 transport layer structure. don't forget to update the pdf with your new functionality.\nq: can i use this on my arduino?\na: yes, this c code is 100% pure c code and only using c standard library and also the code does not take account of what hardware you are using.\nq: do i need to install the library for to use the library?\na: no, just copy over the .c and .h files to your project and compile. i have used this with qt framework.\nq: this project is quite old now and not so much updates, is it still worth to use it?\na: yes, this library only updates when i or other includes more functionality from sae j1939. the reason why i wrote this in c99 is because it's an industry standard and will you will always be able to compile this library and use it.\nq: what is your plan with the library?\na: to make sae j1939 available for everybody\nq: i don't have can-bus, but can i use this library anyway with uart, usb, wifi etc?\na: yes. this is only a way to shape a massage in a specific way.\nq: can i send data with this library, even if i don't have can-bus?\na: yes. there are something called dm14 transmit request, dm15 status response and dm16 binary transfer. use that if you want to transfer data in an industrial way.\nq: can i send multi package messages from from multiple ecu:s to one ecu at the same time?\na: no. if you starting to send multipackages from multiple ecu:s to another ecu, then that ecu cannot understand the message. transmit only multipackage messages one at the time if the destination address is the same.\nissues and answers\ni: i cannot compile this library. i'm using keil microvision.\na: keil microvision cannot handle binary numbers such as 0b010101. try stm32cubeide instead because open sae j1939 is made in stm32cubeide\ni: can you provide us with some hardware examples for example stm32?\na: yes! there is a stm32 example how to get connection with can-bus including an interrupt listener for messages. go to examples -> hardware folder at look for can_stm32.txt. also there is a usb example as well for qt c++.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000849, "year": null}], "name": "forestryarduino"}
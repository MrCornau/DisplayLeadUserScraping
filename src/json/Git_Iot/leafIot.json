{"interestingcomments": [{"Unnamed: 0": 200, "autor": 200, "date": null, "content": "Azure IoT C SDKs and Libraries\nImportant branch rename information\nAs of December 1, 2021, we have changed the default branch of this repo from master to main. This may impact both your local clones of this repro made before this change as well as tools you have referencing master. See here for more information.\nIntroduction\nThe Azure IOT Hub Device SDK allows applications written in C99 or later or C++ to communicate easily with Azure IoT Hub, Azure IoT Central and to Azure IoT Device Provisioning. This repo includes the source code for the libraries, setup instructions, and samples demonstrating use scenarios.\nFor constrained devices - where memory is measured in kilobytes and not megabytes - there are even lighter weight SDK options available. See Other Azure IoT SDKs for more.\nTable of Contents\nAzure IoT C SDKs and Libraries\nTable of Contents\nCritical Upcoming Change Notice\nGetting the SDK\nSamples\nSDK API Reference Documentation\nOther Azure IoT SDKs\nDeveloping Azure IoT Applications\nKey Features\nDevice Client SDK\nProvisioning Client SDK\nOS Platforms and Hardware Compatibility\nPorting the Azure IoT Device Client SDK for C to New Devices\nContribution, Feedback and Issues\nSupport\nRead More\nSDK Folder Structure\nDeprecated Folders\nReleases\nNew Features and Critical Bug Fixes\nLong Term Support (LTS)\nLTS Schedule\nRelease Example\nCritical Upcoming Change Notice\nAll Azure IoT SDK users are advised to be aware of upcoming TLS certificate changes for Azure IoT Hub and Device Provisioning Service that will impact the SDK's ability to connect to these services. In October 2022, both services will migrate from the current Baltimore CyberTrust CA Root to the DigiCert Global G2 CA root. There will be a transition period beforehand where your IoT devices must have both the Baltimore and Digicert public certificates which may be hardcoded in their application or flashed onto your WiFi module in order to prevent connectivity issues.\nDevices with only the Baltimore public certificate will lose the ability to connect to Azure IoT Hub and Device Provisioning Service in October 2022.\nTo prepare for this change, make sure your device's TLS stack has both of these public root of trust certificates configured.\nFor a more in depth explanation as to why the IoT services are doing this, please see this article.\nGetting the SDK\nPlease note, for constrained device scenarios like the below mbed and Arduino, there are better, lighter weight SDK options available. See Other Azure IoT SDKs for more.\nThe simplest way to get started with the Azure IoT SDKs on supported platforms is to use the following packages and libraries:\nmbed: Device SDK library on MBED\nArduino: Device SDK library in the Arduino IDE\nWindows: Device SDK on Vcpkg\niOS: Device SDK on CocoaPod\nFor other platforms - including Linux - you need to clone and build the SDK directly. You may also build it directly for the platforms above. Instructions can be found here.\nSamples\nThere are many samples available for the SDK. More information can be found here.\nSDK API Reference Documentation\nThe API reference documentation for the C SDKs can be found here.\nOther Azure IoT SDKs\nTo find Azure IoT SDKs in other languages, please refer to the guidance here.\nAzure IoT SDK for Embedded C is an alternative for constrained devices which enables the BYO (bring your own) network approach: IoT developers have the freedom of choice to bring MQTT client, TLS and Socket of their choice to create a device solution.\nAzure IoT middleware for Azure RTOS builds on top of the embedded SDK and tightly couples with the Azure RTOS family of networking and OS products. This gives you very performant and small applications for real-time, constrained devices.\nAzure IoT middleware for FreeRTOS builds on top of the embedded SDK and takes care of the MQTT stack while integrating with FreeRTOS. This maintains the focus on constrained devices and gives users a distilled Azure IoT feature set while allowing for flexibility with their networking stack.\nDeveloping Azure IoT Applications\nTo learn more about building Azure IoT Applications, you can visit the Azure IoT Dev Center.\nKey Features\nDevice Client SDK\nIoT Hub supports multiple protocols for the device to connect with : MQTT, AMQP, and HTTPS. MQTT and AMQP can optionally run over WebSockets. The Device Client SDK allows the protocol to be chosen at connection creation time.\nIf you're not sure which protocol to use, you should use MQTT or MQTT-WS. MQTT requires considerably fewer resources than AMQP and supports considerably more IoT Hub functionality than HTTPS. Neither AMQP nor HTTPS are guaranteed to have Device Client SDK implementations for new features going forward, such as Azure IoT Plug and Play.\n\u2714\ufe0f feature available \u2716\ufe0f feature planned but not supported \u2796 no support planned\nFeatures mqtt mqtt-ws amqp amqp-ws https Description\nAuthentication \u2714\ufe0f \u2714\ufe0f* \u2714\ufe0f \u2714\ufe0f* \u2714\ufe0f* Connect your device to IoT Hub securely with supported authentication, including private key, SASToken, X-509 Self Signed and Certificate Authority (CA) Signed. *IoT Hub only supports X-509 CA Signed over AMQP and MQTT at the moment.\nSend Device-to-Cloud Message \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* Send device-to-cloud messages (max 256KB) to IoT Hub with the option to add custom properties. IoT Hub only supports batch send over AMQP and HTTPS only at the moment. This SDK supports batch send over HTTP. * Batch send over AMQP and AMQP-WS, and add system properties on D2C messages are in progress.\nReceive Cloud-to-Device Messages \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f Receive cloud-to-device messages and read associated custom and system properties from IoT Hub, with the option to complete/reject/abandon C2D messages. *IoT Hub supports the option to complete/reject/abandon C2D messages over HTTPS and AMQP only at the moment.\nDevice Twins \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2796 IoT Hub persists a device twin for each device that you connect to IoT Hub. The device can perform operations like get twin tags, subscribe to desired properties. *Send reported properties version and desired properties version are in progress.\nDirect Methods \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2796 IoT Hub gives you the ability to invoke direct methods on devices from the cloud. The SDK supports handler for method specific and generic operation.\nUpload File to Blob \u2796 \u2796 \u2796 \u2796 \u2714\ufe0f A device can initiate a file upload and notifies IoT Hub when the upload is complete. File upload requires HTTPS connection, but can be initiated from client using any protocol for other operations.\nConnection Status and Error reporting \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2716\ufe0f Error reporting for IoT Hub supported error code. *This SDK supports error reporting on authentication and Device Not Found.\nRetry policies \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2716\ufe0f Retry policy for unsuccessful device-to-cloud messages have two options: no try, exponential backoff with jitter (default). *Custom retry policy is in progress.\nDevices multiplexing over single connection \u2796 \u2796 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f There are more limitations to multiplexing than captured in this table. See this document for more information.\nConnection Pooling - Specifying number of connections \u2796 \u2796 \u2716\ufe0f \u2716\ufe0f \u2716\ufe0f\nAzure IoT Plug and Play Support \u2714\ufe0f \u2714\ufe0f \u2796 \u2796 \u2796 Ability to build Azure IoT Plug and Play devices.\nThis SDK also contains options you can set and platform specific features. You can find detail list in this document.\nProvisioning Client SDK\nThis repository contains provisioning client SDK for the Device Provisioning Service.\n\u2714\ufe0f feature available \u2716\ufe0f feature planned but not supported \u2796 no support planned\nFeatures mqtt mqtt-ws amqp amqp-ws https Description\nTPM Individual Enrollment \u2796 \u2796 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f This SDK supports connecting your device to the Device Provisioning Service via individual enrollment using Trusted Platform Module. This quickstart reviews how to create a simulated device for individual enrollment with TPM. TPM over MQTT is currently not supported by the Device Provisioning Service.\nX.509 Individual Enrollment \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f This SDK supports connecting your device to the Device Provisioning Service via individual enrollment using X.509 leaf certificate. This quickstart reviews how to create a simulated device for individual enrollment with X.509.\nX.509 Enrollment Group \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f This SDK supports connecting your device to the Device Provisioning Service via enrollment group using X.509 root certificate.\nOS Platforms and Hardware Compatibility\nThe IoT Hub device SDK for C can be used with a broad range of OS platforms and devices.\nThe minimum requirements are for the device platform to support the following:\nSupport Azure IoT TLS over TCP/IP Requirements: https://docs.microsoft.com/azure/iot-hub/iot-hub-tls-support\nSupport SHA-256 (optional): necessary to generate the secure token for authenticating the device with the service. Different authentication methods are available and not all require SHA-256.\nHave a Real Time Clock or implement code to connect to an NTP server: necessary for both establishing the TLS connection and generating the secure token for authentication.\nHaving at least 64KB of RAM: the memory footprint of the SDK depends on the SDK and protocol used as well as the platform targeted. The smallest footprint is achieved targeting microcontrollers.\nPlatform support details can be found in this document. You can find an exhaustive list of the OS platforms the various SDKs have been tested against in the Azure Certified for IoT device catalog. Note that you might still be able to use the SDKs on OS and hardware platforms that are not listed on this page: all the SDKs are open sourced and designed to be portable. If you have suggestions, feedback or issues to report, refer to the Contribution and Support sections below.\nPorting the Azure IoT Device Client SDK for C to New Devices\nThe C SDKs and Libraries:\nAre written in ANSI C (C99) and avoids compiler extensions to maximize code portability and broad platform compatibility.\nExpose a platform abstraction layer to isolate OS dependencies (threading and mutual exclusion mechanisms, communications protocol e.g. HTTP). Refer to our porting guide for more information about our abstraction layer.\nIn the repository you will find instructions and build tools to compile and run the device client SDK for C on Linux, Windows and microcontroller platforms (refer to the links above for more information on compiling the device client for C).\nIf you are considering porting the device client SDK for C to a new platform, check out the porting guide document.\nContribution, Feedback and Issues\nIf you encounter any bugs, have suggestions for new features or if you would like to become an active contributor to this project please follow the instructions provided in the contribution guidelines.\nSupport\nHave a feature request for SDKs? Please post it on Azure Community Feedback to help us prioritize.\nHave a technical question? Ask on Stack Overflow with tag \"azure-iot-hub\".\nNeed Support? Every customer with an active Azure subscription has access to support with guaranteed response time. Consider submitting a ticket and get assistance from Microsoft support team\nFound a bug? Please help us fix it by thoroughly documenting it and filing an issue on our GitHub issues.\nRead More\nAzure IoT Hub documentation\nPrepare your development environment to use the Azure IoT device SDK for C\nSetup IoT Hub\nAzure IoT device SDK for C tutorial\nHow to port the C libraries to other OS platforms\nCross compilation example\nSDK Folder Structure\n/c-utility, /deps, /umqtt, /uamqp -\nThese are git submodules that contain code, such as adapters and protocol implementations, shared with other projects.\n/build, /build_all\nBuild and checkin gate related folders.\n/certs\nContains certificates needed to communicate with Azure IoT Hub.\n/doc\nThis folder contains application development guides and device setup instructions.\n/iothub_client\nContains Azure IoT Hub client components that provide the raw messaging capabilities of the library. Refer to the API documentation and samples for information on how to use it.\nbuild: has one subfolder for each platform (e.g. Windows, Linux, Mbed). Contains makefiles, batch files, and solutions that are used to generate the library binaries.\ndevdoc: contains requirements, designs notes, manuals.\ninc: public include files.\nsrc: client libraries source files.\nsamples: contains simple samples.\ntests: unit and end-to-end tests for source code.\n/provisioning_client\nThis folder contains client library for device provisioning client.\n/samples\nContains samples demonstrating more complex E2E scenarios using SDK.\n/testtools\nContains tools that are used in testing the libraries.\n/tools\nMiscellaneous tools.\nDeprecated Folders\nThe following folders are deprecated.\n/iothub_service_client\nContains libraries that enable interactions with the IoT Hub service to perform operations such as sending messages to devices and managing the device identity registry.\n/provisioning_service_client\nContains libraries that enable interactions with the Device Proviosining service to perform operations such as setting policy around the enrollments.\n/serializer\nContains libraries that provide modeling and JSON serialization capabilities on top of the raw messaging library.\nReleases\nThe C SDK offers releases for new features, critical bug fixes, and Long Term Support (LTS). General bug fixes will not receive a separate release, but are instead contained within the LTS release. Versioning follows semantic versioning, x.y.z. or major.minor.patch. Any time the version is updated, it will be tagged x.y.z.\nNew Features and Critical Bug Fixes\nNew features and critical bug fixes (including security updates) will be released on the main branch. These releases will be tagged using the date formatted yyyy-mm-dd. A feature release will bump the minor version and reset the patch version to 0. A critical bug fix will bump the patch version only.\nLong Term Support (LTS)\nNew LTS releases branch off of main and will be tagged LTS_<mm_yyyy>_Ref01. A new LTS release will inherit the version from the main branch at the time of the release. LTS branches are named lts_mm_yyyy for the month and year the branch was created.\nAn updated LTS release will occur when a critical bug fix (including security updates) is ported from the main branch. These updated releases will be tagged in the same manner except for a bumped Ref##, e.g. LTS_<mm_yyyy>_Ref02. The patch version will also be bumped. No new features and no general bug fixes will be ported to an LTS update.\nLTS Schedule\nBelow is a table showing the mapping of the LTS branches to the packages released.\nPackage GitHub Branch LTS Tag LTS Start Date Maintenance End Date\nvcpkg: 2021-09-09 lts_07_2021 LTS_07_2021_Ref01 2021-08-11 2022-08-11\nvcpkg: (unreleased) lts_01_2021 LTS_01_2021_Ref01 2021-01-21 2022-01-21\nRelease Example\nBelow is a hypothetical example of versioning and tagging for the C SDK. minor versions are distinguished by color.\nThe main branch is at version 1.8.2.\nFebruary 23, 2020: A new feature is released on main. The version bumps to 1.9.0, is tagged 1.9.0, and the release is tagged 2020-02-23.\nJuly 9, 2020: A new LTS release occurs. A new release branch lts_07_2020 is created, the version remains 1.9.0, and the LTS release is tagged LTS_07_2020_Ref01. The main branch bumps to 1.10.0 and is tagged 1.10.0.\nAugust 2, 2020: A new feature is released on main: The main branch has already been bumped for an upcoming release so the version is unchanged. The release is tagged 2020-08-02.\nSeptember 28, 2020: A critical bug fix is released: The version on main bumps to 1.10.1, is tagged 1.10.1, and the release is tagged 2020-09-28. The critical bug fix is ported to the lts branch lts_07_2020 (and any other existing LTS branch). The lts branch version bumps to 1.9.1, is tagged 1.9.1, and the updated LTS release is tagged LTS_07_2020_Ref02. Any submodules that were part of the critical bug fix will be tagged with LTS_07_2020_Ref02.\nDecember 14, 2020: A new feature is released on main. The version bumps to 1.11.0, is tagged 1.11.0, and the release is tagged 2020-12-14.\nThis project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.\nMicrosoft collects performance and usage information which may be used to provide and improve Microsoft products and services and enhance your experience. To learn more, review the privacy statement.", "link": "https://github.com/Azure/azure-iot-sdk-c", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "leaf", "selectorShort": "leaf", "MarkedSent": "azure iot c sdks and libraries\nimportant branch rename information\nas of december 1, 2021, we have changed the default branch of this repo from master to main. this may impact both your local clones of this repro made before this change as well as tools you have referencing master. see here for more information.\nintroduction\nthe azure iot hub device sdk allows applications written in c99 or later or c++ to communicate easily with azure iot hub, azure iot central and to azure iot device provisioning. this repo includes the source code for the libraries, setup instructions, and samples demonstrating use scenarios.\nfor constrained devices - where memory is measured in kilobytes and not megabytes - there are even lighter weight sdk options available. see other azure iot sdks for more.\ntable of contents\nazure iot c sdks and libraries\ntable of contents\ncritical upcoming change notice\ngetting the sdk\nsamples\nsdk api reference documentation\nother azure iot sdks\ndeveloping azure iot applications\nkey features\ndevice client sdk\nprovisioning client sdk\nos platforms and hardware compatibility\nporting the azure iot device client sdk for c to new devices\ncontribution, feedback and issues\nsupport\nread more\nsdk folder structure\ndeprecated folders\nreleases\nnew features and critical bug fixes\nlong term support (lts)\nlts schedule\nrelease example\ncritical upcoming change notice\nall azure iot sdk users are advised to be aware of upcoming tls certificate changes for azure iot hub and device provisioning service that will impact the sdk's ability to connect to these services. in october 2022, both services will migrate from the current baltimore cybertrust ca root to the digicert global g2 ca root. there will be a transition period beforehand where your iot devices must have both the baltimore and digicert public certificates which may be hardcoded in their application or flashed onto your wifi module in order to prevent connectivity issues.\ndevices with only the baltimore public certificate will lose the ability to connect to azure iot hub and device provisioning service in october 2022.\nto prepare for this change, make sure your device's tls stack has both of these public root of trust certificates configured.\nfor a more in depth explanation as to why the iot services are doing this, please see this article.\ngetting the sdk\nplease note, for constrained device scenarios like the below mbed and arduino, there are better, lighter weight sdk options available. see other azure iot sdks for more.\nthe simplest way to get started with the azure iot sdks on supported platforms is to use the following packages and libraries:\nmbed: device sdk library on mbed\narduino: device sdk library in the arduino ide\nwindows: device sdk on vcpkg\nios: device sdk on cocoapod\nfor other platforms - including linux - you need to clone and build the sdk directly. you may also build it directly for the platforms above. instructions can be found here.\nsamples\nthere are many samples available for the sdk. more information can be found here.\nsdk api reference documentation\nthe api reference documentation for the c sdks can be found here.\nother azure iot sdks\nto find azure iot sdks in other languages, please refer to the guidance here.\nazure iot sdk for embedded c is an alternative for constrained devices which enables the byo (bring your own) network approach: iot developers have the freedom of choice to bring mqtt client, tls and socket of their choice to create a device solution.\nazure iot middleware for azure rtos builds on top of the embedded sdk and tightly couples with the azure rtos family of networking and os products. this gives you very performant and small applications for real-time, constrained devices.\nazure iot middleware for freertos builds on top of the embedded sdk and takes care of the mqtt stack while integrating with freertos. this maintains the focus on constrained devices and gives users a distilled azure iot feature set while allowing for flexibility with their networking stack.\ndeveloping azure iot applications\nto learn more about building azure iot applications, you can visit the azure iot dev center.\nkey features\ndevice client sdk\niot hub supports multiple protocols for the device to connect with : mqtt, amqp, and https. mqtt and amqp can optionally run over websockets. the device client sdk allows the protocol to be chosen at connection creation time.\nif you're not sure which protocol to use, you should use mqtt or mqtt-ws. mqtt requires considerably fewer resources than amqp and supports considerably more iot hub functionality than https. neither amqp nor https are guaranteed to have device client sdk implementations for new features going forward, such as azure iot plug and play.\n\u2714\ufe0f feature available \u2716\ufe0f feature planned but not supported \u2796 no support planned\nfeatures mqtt mqtt-ws amqp amqp-ws https description\nauthentication \u2714\ufe0f \u2714\ufe0f* \u2714\ufe0f \u2714\ufe0f* \u2714\ufe0f* connect your device to iot hub securely with supported authentication, including private key, sastoken, x-509 self signed and certificate authority (ca) signed. *iot hub only supports x-509 ca signed over amqp and mqtt at the moment.\nsend device-to-cloud message \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* send device-to-cloud messages (max 256kb) to iot hub with the option to add custom properties. iot hub only supports batch send over amqp and https only at the moment. this sdk supports batch send over http. * batch send over amqp and amqp-ws, and add system properties on d2c messages are in progress.\nreceive cloud-to-device messages \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f receive cloud-to-device messages and read associated custom and system properties from iot hub, with the option to complete/reject/abandon c2d messages. *iot hub supports the option to complete/reject/abandon c2d messages over https and amqp only at the moment.\ndevice twins \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2796 iot hub persists a device twin for each device that you connect to iot hub. the device can perform operations like get twin tags, subscribe to desired properties. *send reported properties version and desired properties version are in progress.\ndirect methods \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2796 iot hub gives you the ability to invoke direct methods on devices from the cloud. the sdk supports handler for method specific and generic operation.\nupload file to blob \u2796 \u2796 \u2796 \u2796 \u2714\ufe0f a device can initiate a file upload and notifies iot hub when the upload is complete. file upload requires https connection, but can be initiated from client using any protocol for other operations.\nconnection status and error reporting \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2716\ufe0f error reporting for iot hub supported error code. *this sdk supports error reporting on authentication and device not found.\nretry policies \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2714\ufe0f* \u2716\ufe0f retry policy for unsuccessful device-to-cloud messages have two options: no try, exponential backoff with jitter (default). *custom retry policy is in progress.\ndevices multiplexing over single connection \u2796 \u2796 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f there are more limitations to multiplexing than captured in this table. see this document for more information.\nconnection pooling - specifying number of connections \u2796 \u2796 \u2716\ufe0f \u2716\ufe0f \u2716\ufe0f\nazure iot plug and play support \u2714\ufe0f \u2714\ufe0f \u2796 \u2796 \u2796 ability to build azure iot plug and play devices.\nthis sdk also contains options you can set and platform specific features. you can find detail list in this document.\nprovisioning client sdk\nthis repository contains provisioning client sdk for the device provisioning service.\n\u2714\ufe0f feature available \u2716\ufe0f feature planned but not supported \u2796 no support planned\nfeatures mqtt mqtt-ws amqp amqp-ws https description\ntpm individual enrollment \u2796 \u2796 \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f this sdk supports connecting your device to the device provisioning service via individual enrollment using trusted platform module. this quickstart reviews how to create a simulated device for individual enrollment with tpm. tpm over mqtt is currently not supported by the device provisioning service.\nx.509 individual enrollment \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f this sdk supports connecting your device to the device provisioning service via individual enrollment using x.509 -----> leaf !!!  certificate. this quickstart reviews how to create a simulated device for individual enrollment with x.509.\nx.509 enrollment group \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f \u2714\ufe0f this sdk supports connecting your device to the device provisioning service via enrollment group using x.509 root certificate.\nos platforms and hardware compatibility\nthe iot hub device sdk for c can be used with a broad range of os platforms and devices.\nthe minimum requirements are for the device platform to support the following:\nsupport azure iot tls over tcp/ip requirements: https://docs.microsoft.com/azure/iot-hub/iot-hub-tls-support\nsupport sha-256 (optional): necessary to generate the secure token for authenticating the device with the service. different authentication methods are available and not all require sha-256.\nhave a real time clock or implement code to connect to an ntp server: necessary for both establishing the tls connection and generating the secure token for authentication.\nhaving at least 64kb of ram: the memory footprint of the sdk depends on the sdk and protocol used as well as the platform targeted. the smallest footprint is achieved targeting microcontrollers.\nplatform support details can be found in this document. you can find an exhaustive list of the os platforms the various sdks have been tested against in the azure certified for iot device catalog. note that you might still be able to use the sdks on os and hardware platforms that are not listed on this page: all the sdks are open sourced and designed to be portable. if you have suggestions, feedback or issues to report, refer to the contribution and support sections below.\nporting the azure iot device client sdk for c to new devices\nthe c sdks and libraries:\nare written in ansi c (c99) and avoids compiler extensions to maximize code portability and broad platform compatibility.\nexpose a platform abstraction layer to isolate os dependencies (threading and mutual exclusion mechanisms, communications protocol e.g. http). refer to our porting guide for more information about our abstraction layer.\nin the repository you will find instructions and build tools to compile and run the device client sdk for c on linux, windows and microcontroller platforms (refer to the links above for more information on compiling the device client for c).\nif you are considering porting the device client sdk for c to a new platform, check out the porting guide document.\ncontribution, feedback and issues\nif you encounter any bugs, have suggestions for new features or if you would like to become an active contributor to this project please follow the instructions provided in the contribution guidelines.\nsupport\nhave a feature request for sdks? please post it on azure community feedback to help us prioritize.\nhave a technical question? ask on stack overflow with tag \"azure-iot-hub\".\nneed support? every customer with an active azure subscription has access to support with guaranteed response time. consider submitting a ticket and get assistance from microsoft support team\nfound a bug? please help us fix it by thoroughly documenting it and filing an issue on our github issues.\nread more\nazure iot hub documentation\nprepare your development environment to use the azure iot device sdk for c\nsetup iot hub\nazure iot device sdk for c tutorial\nhow to port the c libraries to other os platforms\ncross compilation example\nsdk folder structure\n/c-utility, /deps, /umqtt, /uamqp -\nthese are git submodules that contain code, such as adapters and protocol implementations, shared with other projects.\n/build, /build_all\nbuild and checkin gate related folders.\n/certs\ncontains certificates needed to communicate with azure iot hub.\n/doc\nthis folder contains application development guides and device setup instructions.\n/iothub_client\ncontains azure iot hub client components that provide the raw messaging capabilities of the library. refer to the api documentation and samples for information on how to use it.\nbuild: has one subfolder for each platform (e.g. windows, linux, mbed). contains makefiles, batch files, and solutions that are used to generate the library binaries.\ndevdoc: contains requirements, designs notes, manuals.\ninc: public include files.\nsrc: client libraries source files.\nsamples: contains simple samples.\ntests: unit and end-to-end tests for source code.\n/provisioning_client\nthis folder contains client library for device provisioning client.\n/samples\ncontains samples demonstrating more complex e2e scenarios using sdk.\n/testtools\ncontains tools that are used in testing the libraries.\n/tools\nmiscellaneous tools.\ndeprecated folders\nthe following folders are deprecated.\n/iothub_service_client\ncontains libraries that enable interactions with the iot hub service to perform operations such as sending messages to devices and managing the device identity registry.\n/provisioning_service_client\ncontains libraries that enable interactions with the device proviosining service to perform operations such as setting policy around the enrollments.\n/serializer\ncontains libraries that provide modeling and json serialization capabilities on top of the raw messaging library.\nreleases\nthe c sdk offers releases for new features, critical bug fixes, and long term support (lts). general bug fixes will not receive a separate release, but are instead contained within the lts release. versioning follows semantic versioning, x.y.z. or major.minor.patch. any time the version is updated, it will be tagged x.y.z.\nnew features and critical bug fixes\nnew features and critical bug fixes (including security updates) will be released on the main branch. these releases will be tagged using the date formatted yyyy-mm-dd. a feature release will bump the minor version and reset the patch version to 0. a critical bug fix will bump the patch version only.\nlong term support (lts)\nnew lts releases branch off of main and will be tagged lts_<mm_yyyy>_ref01. a new lts release will inherit the version from the main branch at the time of the release. lts branches are named lts_mm_yyyy for the month and year the branch was created.\nan updated lts release will occur when a critical bug fix (including security updates) is ported from the main branch. these updated releases will be tagged in the same manner except for a bumped ref##, e.g. lts_<mm_yyyy>_ref02. the patch version will also be bumped. no new features and no general bug fixes will be ported to an lts update.\nlts schedule\nbelow is a table showing the mapping of the lts branches to the packages released.\npackage github branch lts tag lts start date maintenance end date\nvcpkg: 2021-09-09 lts_07_2021 lts_07_2021_ref01 2021-08-11 2022-08-11\nvcpkg: (unreleased) lts_01_2021 lts_01_2021_ref01 2021-01-21 2022-01-21\nrelease example\nbelow is a hypothetical example of versioning and tagging for the c sdk. minor versions are distinguished by color.\nthe main branch is at version 1.8.2.\nfebruary 23, 2020: a new feature is released on main. the version bumps to 1.9.0, is tagged 1.9.0, and the release is tagged 2020-02-23.\njuly 9, 2020: a new lts release occurs. a new release branch lts_07_2020 is created, the version remains 1.9.0, and the lts release is tagged lts_07_2020_ref01. the main branch bumps to 1.10.0 and is tagged 1.10.0.\naugust 2, 2020: a new feature is released on main: the main branch has already been bumped for an upcoming release so the version is unchanged. the release is tagged 2020-08-02.\nseptember 28, 2020: a critical bug fix is released: the version on main bumps to 1.10.1, is tagged 1.10.1, and the release is tagged 2020-09-28. the critical bug fix is ported to the lts branch lts_07_2020 (and any other existing lts branch). the lts branch version bumps to 1.9.1, is tagged 1.9.1, and the updated lts release is tagged lts_07_2020_ref02. any submodules that were part of the critical bug fix will be tagged with lts_07_2020_ref02.\ndecember 14, 2020: a new feature is released on main. the version bumps to 1.11.0, is tagged 1.11.0, and the release is tagged 2020-12-14.\nthis project has adopted the microsoft open source code of conduct. for more information see the code of conduct faq or contact opencode@microsoft.com with any additional questions or comments.\nmicrosoft collects performance and usage information which may be used to provide and improve microsoft products and services and enhance your experience. to learn more, review the privacy statement.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000200, "year": null}, {"Unnamed: 0": 805, "autor": 805, "date": null, "content": "readthedocs: https://utensor-cgen.readthedocs.io/en/latest/\nInstallation (Python 2 & 3)\nFor Users\nwith setup.py\n$ python setup.py install\nwith pip\n$ pip install utensor_cgen\nFor Developers\nwith pipenv\n# install `utensor_cgen` (develop mode)\n$ PIPENV_VENV_IN_PROJECT=1 pipenv install -d\n# spawn a subshell and activate virtualenv\n$ pipenv shell\n# get help message of `utensor-cli`\n$ utensor-cli -h\nTroubleshooting with pipenv\nIf you have troubles with installation using pipenv, try\n$ PIPENV_VENV_IN_PROJECT=1 pipenv install -d --skip-lock\nthere is known issue of pip and pipenv, plz refer to this issue for detail\nshort answer: downgrade to pip==18.0 may help :)\nTensorflow requires setuptools<=39.1.0 (the latest is 40.4.3 by the time this README is writen)\nplz downgrade to setuptools==39.1.0\nmy recommendation is to use virtualenv\nOverall Architecture\nBasic Usage\nModel File Inspection\n$ utensor-cli show <model.pb>\nShow all nodes and detailed information of given pb file or a :class:`.uTensorGraph` pickle file\nRun utensor-cli show --help for detailed information.\nConvert Model File to C/C++ Code\nIMPORTANT: pb file is deprecated in favor of Tensorflow 2.x, please refer to End-to-End Training with Keras for detail\n$ utensor-cli convert <model.pb> \\\n--output-nodes=<node name>[,<node name>,...] \\\n[--config=config.toml]\nConvert given pb file into cpp/hpp files.\nNote that --output-nodes is required options. It's the names of nodes you want to output, seperated by comma for multiple values.\nIn graph theory terminology, they are leaf nodes of your graph.\nUse --config to pass a configuration file to the cli, you can use generate-config command to generate one (see below).\nexample\n$ utensor-cli convert simple_model.pb --output-nodes=pred,logits\nRun utensor-cli convert --help for detailed information.\nConfiguration\nutensor-cli use toml as configuration format.\nYou can generate configuration file of given target as following:\n$ utensor-cli generate-config --target <target name> [-o filename.toml]\nThis command will generate a toml file listing all configurable values with its defaults.\nYou can modify the value and pass the file to cli with --config flag.\nexample\n# generate config file\n$ utensor-cli generate-config --target utensor -o myconfig.toml\n# after editting myconfig.toml\n$ utensor-cli convert mymodel.pb --config=myconfig.toml --output-nodes=output,...\nUse :mod:`utensor_cgen` as Library\nSubgraph Isomorphic Matcher\nWith :class:`.uTensorGraphMatcher`, performing isomorphic subgraph matching along with replacing or manipulating the matched subgraph(s) takes just a few line of code:\nfrom utensor_cgen.matcher import uTensorGraphMatcher\n# `pattrn_ugraph` is the pattern to match with\npattrn_ugraph = ...\nmatcher = uTensorGraphMatcher(pattrn_ugraph)\n# a larget graph to perform subgraph match\nsubject_ugraph = ...\n# matches is a list of `uTensorGraphMatch` objects\nmatches = matcher.match_all(subject_ugraph)\nif matches:\n# do stuff with the matches\nUse Case: Node Fusion\nNote: we'll use operation/node/layer interchangeably in the documentation\nIt's commonly seen pattern in convolution neural network (CNN), conv -> relu -> pooling. That is, a 2D convolution followed by a relu layer and then a pooling down sampling layer.\nWith our :class:`.uTensorGraphMatcher`, you can locate such pattern in your CNN model and fuse/replace matched nodes into one optimized :class:`.QuantizedFusedConv2DMaxpool` node.\nLeft: original graph\nMiddle: matched convolution layer\nRight: replace the matched layer with specialized QuantizedFusedConv2DMaxpool node\nUse Case: Dropout Layer Removal\nThough dropout is an effective technique to improve training performance of your model, it's not necessary during inference phrase.\nIn the mainstream frameworks such as Tensorflow or PyTorch, an dropout layer is typically implemented with other elementary operations/nodes. As a result, finding and removing those nodes for inference optimization (both in model size and prediciton time) is not trivial and error prone.\nWith our :class:`.uTensorGraphMatcher`, you can find and remove the dropout nodes as illustrated in the following picture.\nLeft: original graph with dropout Layers\nMiddle: matched dropout layers\nRight: graph with dropout layers removed\nWe use mainly Tensorflow for declaring the pattern graph for matcher now.\nHigh-level graph builder is on its way, see Future Works for detail.\nOffline Tensor Memory Allocation\nConsidering following simple multi layers perceptron (simple_mnist.pb):\nOnce enabled the optimization transformer, tensor_alloc, an offline tensor memory allocation planner, utensor-cli will generate uTensor runtime codes that use following optimized allocation plan:\ny-axis: tensor names ordered by topological sorting\nx-axis: these are the memory span occupied by each tensor, that is, the memory address offset and\nthe size of the tensor\nTutorials\nEnd-to-End Training with Keras\nExtending uTensor Backend by Adding Custom Operators\nWrighting Plugins: Component Registration\nHow to Serve Your Model on uTenosr\nKeras (Recommended)\nPlease refer to End-to-End Training with Keras for detail\nTensorFlow\nFreeze your tensorflow.Graph\nplease refer to this issue track for detail\nespecially this comment by Robin2091\nFollow instructions in :ref:`install` section to install :mod:`utensor_cgen`\nthen utensor-cli should be available in your console\nInspect your pb file to find the output node\n# verbose mode\n$ utensor-cli show graph.pb\n# or oneline mode\n$ utensor-cli show graph.pb --oneline\nconvert the protobuf file to C/C++ source code with utensor-cli\nsupose the output node is pred in graph.pb\n$ utensor-cli convert --output-nodes=pred graph.pb\nCompile your application code with generated C/C++ and weights files\nYou should find your model C/C++ and weights files in directories models and constants respectively\nTesting\nfollow the steps in :ref:`install_dev` section\nrun tests as following\n# run with `make`\n$ make tests\n# run with `pipenv`\n$ pipenv run pytest -m 'not slow_test and not deprecated' tests\nFuture Works\nHigh-level graph builder api for building :class:`.uTensorGraph`.\nCurrently utensor_cgen uses TensorFlow api for building IR graph, uTensorGraph.\nWith high-level graph builder, users can build their uTensorGraph easily and do not need to take care of the integrity of the graph. The builder will take care of it automatically.\nAutomaic-Update TFLite fbs file\nschema files", "link": "https://github.com/uTensor/utensor_cgen", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "leaf", "selectorShort": "leaf", "MarkedSent": "readthedocs: https://utensor-cgen.readthedocs.io/en/latest/\ninstallation (python 2 & 3)\nfor users\nwith setup.py\n$ python setup.py install\nwith pip\n$ pip install utensor_cgen\nfor developers\nwith pipenv\n# install `utensor_cgen` (develop mode)\n$ pipenv_venv_in_project=1 pipenv install -d\n# spawn a subshell and activate virtualenv\n$ pipenv shell\n# get help message of `utensor-cli`\n$ utensor-cli -h\ntroubleshooting with pipenv\nif you have troubles with installation using pipenv, try\n$ pipenv_venv_in_project=1 pipenv install -d --skip-lock\nthere is known issue of pip and pipenv, plz refer to this issue for detail\nshort answer: downgrade to pip==18.0 may help :)\ntensorflow requires setuptools<=39.1.0 (the latest is 40.4.3 by the time this readme is writen)\nplz downgrade to setuptools==39.1.0\nmy recommendation is to use virtualenv\noverall architecture\nbasic usage\nmodel file inspection\n$ utensor-cli show <model.pb>\nshow all nodes and detailed information of given pb file or a :class:`.utensorgraph` pickle file\nrun utensor-cli show --help for detailed information.\nconvert model file to c/c++ code\nimportant: pb file is deprecated in favor of tensorflow 2.x, please refer to end-to-end training with keras for detail\n$ utensor-cli convert <model.pb> \\\n--output-nodes=<node name>[,<node name>,...] \\\n[--config=config.toml]\nconvert given pb file into cpp/hpp files.\nnote that --output-nodes is required options. it's the names of nodes you want to output, seperated by comma for multiple values.\nin graph theory terminology, they are -----> leaf !!!  nodes of your graph.\nuse --config to pass a configuration file to the cli, you can use generate-config command to generate one (see below).\nexample\n$ utensor-cli convert simple_model.pb --output-nodes=pred,logits\nrun utensor-cli convert --help for detailed information.\nconfiguration\nutensor-cli use toml as configuration format.\nyou can generate configuration file of given target as following:\n$ utensor-cli generate-config --target <target name> [-o filename.toml]\nthis command will generate a toml file listing all configurable values with its defaults.\nyou can modify the value and pass the file to cli with --config flag.\nexample\n# generate config file\n$ utensor-cli generate-config --target utensor -o myconfig.toml\n# after editting myconfig.toml\n$ utensor-cli convert mymodel.pb --config=myconfig.toml --output-nodes=output,...\nuse :mod:`utensor_cgen` as library\nsubgraph isomorphic matcher\nwith :class:`.utensorgraphmatcher`, performing isomorphic subgraph matching along with replacing or manipulating the matched subgraph(s) takes just a few line of code:\nfrom utensor_cgen.matcher import utensorgraphmatcher\n# `pattrn_ugraph` is the pattern to match with\npattrn_ugraph = ...\nmatcher = utensorgraphmatcher(pattrn_ugraph)\n# a larget graph to perform subgraph match\nsubject_ugraph = ...\n# matches is a list of `utensorgraphmatch` objects\nmatches = matcher.match_all(subject_ugraph)\nif matches:\n# do stuff with the matches\nuse case: node fusion\nnote: we'll use operation/node/layer interchangeably in the documentation\nit's commonly seen pattern in convolution neural network (cnn), conv -> relu -> pooling. that is, a 2d convolution followed by a relu layer and then a pooling down sampling layer.\nwith our :class:`.utensorgraphmatcher`, you can locate such pattern in your cnn model and fuse/replace matched nodes into one optimized :class:`.quantizedfusedconv2dmaxpool` node.\nleft: original graph\nmiddle: matched convolution layer\nright: replace the matched layer with specialized quantizedfusedconv2dmaxpool node\nuse case: dropout layer removal\nthough dropout is an effective technique to improve training performance of your model, it's not necessary during inference phrase.\nin the mainstream frameworks such as tensorflow or pytorch, an dropout layer is typically implemented with other elementary operations/nodes. as a result, finding and removing those nodes for inference optimization (both in model size and prediciton time) is not trivial and error prone.\nwith our :class:`.utensorgraphmatcher`, you can find and remove the dropout nodes as illustrated in the following picture.\nleft: original graph with dropout layers\nmiddle: matched dropout layers\nright: graph with dropout layers removed\nwe use mainly tensorflow for declaring the pattern graph for matcher now.\nhigh-level graph builder is on its way, see future works for detail.\noffline tensor memory allocation\nconsidering following simple multi layers perceptron (simple_mnist.pb):\nonce enabled the optimization transformer, tensor_alloc, an offline tensor memory allocation planner, utensor-cli will generate utensor runtime codes that use following optimized allocation plan:\ny-axis: tensor names ordered by topological sorting\nx-axis: these are the memory span occupied by each tensor, that is, the memory address offset and\nthe size of the tensor\ntutorials\nend-to-end training with keras\nextending utensor backend by adding custom operators\nwrighting plugins: component registration\nhow to serve your model on utenosr\nkeras (recommended)\nplease refer to end-to-end training with keras for detail\ntensorflow\nfreeze your tensorflow.graph\nplease refer to this issue track for detail\nespecially this comment by robin2091\nfollow instructions in :ref:`install` section to install :mod:`utensor_cgen`\nthen utensor-cli should be available in your console\ninspect your pb file to find the output node\n# verbose mode\n$ utensor-cli show graph.pb\n# or oneline mode\n$ utensor-cli show graph.pb --oneline\nconvert the protobuf file to c/c++ source code with utensor-cli\nsupose the output node is pred in graph.pb\n$ utensor-cli convert --output-nodes=pred graph.pb\ncompile your application code with generated c/c++ and weights files\nyou should find your model c/c++ and weights files in directories models and constants respectively\ntesting\nfollow the steps in :ref:`install_dev` section\nrun tests as following\n# run with `make`\n$ make tests\n# run with `pipenv`\n$ pipenv run pytest -m 'not slow_test and not deprecated' tests\nfuture works\nhigh-level graph builder api for building :class:`.utensorgraph`.\ncurrently utensor_cgen uses tensorflow api for building ir graph, utensorgraph.\nwith high-level graph builder, users can build their utensorgraph easily and do not need to take care of the integrity of the graph. the builder will take care of it automatically.\nautomaic-update tflite fbs file\nschema files", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000805, "year": null}, {"Unnamed: 0": 825, "autor": 825, "date": null, "content": "Quickly get started with AWS IoT Core for LoRaWAN with sample solutions (binary decoding, device and gateway monitoring, downlink, dashboarding, provisioning automation)\nNew to AWS IoT Core for LoRaWAN? Consider step-by-step tutorial at https://iotwireless.workshop.aws\nAWS IoT Core for LoRaWAN enables you to set up a private LoRaWAN network by connecting your devices and gateways with no LoRaWAN Network Server setup required. This repository contains resources to quickly get started developing solutions using AWS IoT Core for LoRaWAN. It includes samples for typical design patterns (binary decoder, downlink messaging, Thing shadow update) and fully functional applications (dashboards, condition monitoring and alarming).\nPlease consider our developer guide to learn how to connect your wireless devices and gateways to AWS IoT Core for LoRaWAN. Please also consider automation guidelines and observability implementation guidelines.\nDecoding binary payloads\nLoRaWAN devices typically send uplink payloads as binary encoded messages. Below you will find various options for an implementation of binary payload decoding.\nDecoding binary payloads from LoRaWAN devices with Python and Node.js\nIn this sample you will learn how to decode a binary message from your LoRaWAN device using Python or Node.js and integrate the decoded payload with more than 17 AWS services using AWS IoT Rules. Guidelines for an integration of existing decoder code in Node.js and Python and building your own decoders are included. See a list of >12 included examples decoders here, new contributions are welcome.\nDecoding binary payloads from LoRaWAN devices using Pilot Things Sensor Library\nThis repository can help you to accelerate development of your LoRaWAN-based IoT solutions by providing a deployable reference architecture which will decode binary data using the Pilot Things Sensor Library. The Pilot Things Sensor Library is a SaaS offering that can be purchased from the AWS marketplace\nDecoding Cayenne Low Power Payload (LPP)\nCayenne LPP format allows the device to send multiple sensor data at one time. Different kinds of sensor data are sent in the individual frames and each sensor data is prefixed with two bytes: data channel (a unique sensor identifier) and one of predefined data types (e.g. analog input, humidity or GPS location).\nSamples for typical design patterns\nSending downlink payload to a LoRaWAN device\nIn this sample you will learn how to implement different options for sending downlink payload to your LoRaWAN devices. It includes examples for AWS SDK, AWS CLI and AWS IoT Core message broker.\nUpdating IoT Thing shadow with decoded device payload\nAWS IoT Thing Shadows can make a device\u2019s state available to apps and other services whether the device is connected to AWS IoT or not. In this sample you will learn how to update the shadow of an AWS IoT Thing with the telemetry from a LoRaWAN device.\nLoRaWAN device connection status monitoring and notifications\nExample solution for monitoring connectivity status of LoRaWAN devices will notify you if your LoRaWAN device is not sending uplink for longer then pre-configured amount of time.\nLoRaWAN gateway connection status monitoring and notifications\nExample solution for monitoring connectivity status for LoRaWAN gateways. After deploying this solution in your AWS account, you will receive an e-mail notificiation each time your LoRaWAN gateway connects or disconnects. Additionaly, a message will be published to AWS IoT Core message broker MQTT topic (e.g. awsiotcorelorawan/events/presence/disconnect/<WirelessGatewayId>) each time the gateway connects and disconnects. Disconnection detection will consider a configurable grace period (default setting is 5 minutes), i.e. only disconnection which is longer then grace period will result in a notification/presence message.\nDeployable sample applications\nVisualizing telemetry and transmission metadata from LoRaWAN devices with Amazon Timestream and Grafana plugin\nIn this sample you will learn how to store telemetry from your LoRaWAN Devices as well as transmission metadata (e.g. RSSI and SNR per gateway) into Amazon Timestream. Afterwards you will learn how to visualize time series data in Grafana using a Grafana plugin for Amazon Timestream.\nMonitoring and alarming of soil moisture by using AWS IoT Core for LoRaWAN and AWS IoT Events\nDetecting events based on telemetry data from connected devices is a common use case in IoT across many industries. This sample explains how to integrate AWS IoT Events with LoRaWAN for IoT Core. You can learn how to translate telemetry values from a LoRaWAN device into events and notify users about these events using E-Mail and SMS.\nUseful guidelines\nAutomation guidelines explain how to use AWS CLI to automate tasks (e.g. configuration of a new gateway).\nObservability guidelines explaion how to retrieve statistics about the state of your LoRaWAN gateways and devices\nIncluded binary decoders\nLoRaWAN devices often encode transmitted data in a binary format, as it increases transmission efficiency and improves battery lifetime. However, as the data arrive in the cloud, many use cases require a structured format. Transforming the binary data into JSON, for example, enables filtering and enrichment using AWS IoT SQL as well as integration with further AWS services using AWS IoT Rule Actions.\nThe sample Decoding binary payloads from LoRaWAN devices repository contains examples of binary decoders. Please note that all decoders are provided without any guarantee to fit for any specific purpose and are only intended for use in a laboratory or prototyping environment. The list below is not to be understood as a recommendation of specific manufacturers or specific device models. AWS IoT Core for LoRaWAN supports any LoRaWAN device that complies with LoRaWAN specifications 1.0.x and 1.1. Please consult AWS Partner Device Catalog for an overview of qualified devices. Said that, please find an overview of examples below:\nGeneric\nDragino LSN50\nAir quality / CO2 / environment measurement\nElsys ERS CO2\nDoor and window opening\nElsys EMS Door\nDragino LDS01\nGNSS tracking\nDragino LGT92\nGlobalsat LT-100\nBrowan Tabs Object Locator\nPresence and smart home\nTektelic Smart Room Sensor\nSound level measurement\nElsys ERS Sound\nTemperature, humidity and moisture\nBrowan Tabs Temperature & Humidity Sensor\nDragino LHT65 (temperature and humidity)\nDragino LSE01 (temperature and moisture)\nDragino LLMS01 (leaf moisture sensor)\nDragino LAQ4 (Air Quality Sensor CO2 + TVOC)\nElsys ERS Lite\nLaird Senstrius RS1xx\nWater Metering\nAxioma W1\nCayenne Low Power Payload (LPP)\nNetwork tester\nAdeunis FTD2\nDigital Contact Sensor\nAdeunis Dry Contacts\nWeather station\nMeteoHelix Iot Pro\nContributions to example binary decoders are welcome.\nGetting help\nAPI Reference\nDeveloper guide\nFAQs\nSupport forums\nPartner catalog\nTest results\nBranch Result\nmain", "link": "https://github.com/aws-samples/aws-iot-core-lorawan", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "leaf", "selectorShort": "leaf", "MarkedSent": "quickly get started with aws iot core for lorawan with sample solutions (binary decoding, device and gateway monitoring, downlink, dashboarding, provisioning automation)\nnew to aws iot core for lorawan? consider step-by-step tutorial at https://iotwireless.workshop.aws\naws iot core for lorawan enables you to set up a private lorawan network by connecting your devices and gateways with no lorawan network server setup required. this repository contains resources to quickly get started developing solutions using aws iot core for lorawan. it includes samples for typical design patterns (binary decoder, downlink messaging, thing shadow update) and fully functional applications (dashboards, condition monitoring and alarming).\nplease consider our developer guide to learn how to connect your wireless devices and gateways to aws iot core for lorawan. please also consider automation guidelines and observability implementation guidelines.\ndecoding binary payloads\nlorawan devices typically send uplink payloads as binary encoded messages. below you will find various options for an implementation of binary payload decoding.\ndecoding binary payloads from lorawan devices with python and node.js\nin this sample you will learn how to decode a binary message from your lorawan device using python or node.js and integrate the decoded payload with more than 17 aws services using aws iot rules. guidelines for an integration of existing decoder code in node.js and python and building your own decoders are included. see a list of >12 included examples decoders here, new contributions are welcome.\ndecoding binary payloads from lorawan devices using pilot things sensor library\nthis repository can help you to accelerate development of your lorawan-based iot solutions by providing a deployable reference architecture which will decode binary data using the pilot things sensor library. the pilot things sensor library is a saas offering that can be purchased from the aws marketplace\ndecoding cayenne low power payload (lpp)\ncayenne lpp format allows the device to send multiple sensor data at one time. different kinds of sensor data are sent in the individual frames and each sensor data is prefixed with two bytes: data channel (a unique sensor identifier) and one of predefined data types (e.g. analog input, humidity or gps location).\nsamples for typical design patterns\nsending downlink payload to a lorawan device\nin this sample you will learn how to implement different options for sending downlink payload to your lorawan devices. it includes examples for aws sdk, aws cli and aws iot core message broker.\nupdating iot thing shadow with decoded device payload\naws iot thing shadows can make a device\u2019s state available to apps and other services whether the device is connected to aws iot or not. in this sample you will learn how to update the shadow of an aws iot thing with the telemetry from a lorawan device.\nlorawan device connection status monitoring and notifications\nexample solution for monitoring connectivity status of lorawan devices will notify you if your lorawan device is not sending uplink for longer then pre-configured amount of time.\nlorawan gateway connection status monitoring and notifications\nexample solution for monitoring connectivity status for lorawan gateways. after deploying this solution in your aws account, you will receive an e-mail notificiation each time your lorawan gateway connects or disconnects. additionaly, a message will be published to aws iot core message broker mqtt topic (e.g. awsiotcorelorawan/events/presence/disconnect/<wirelessgatewayid>) each time the gateway connects and disconnects. disconnection detection will consider a configurable grace period (default setting is 5 minutes), i.e. only disconnection which is longer then grace period will result in a notification/presence message.\ndeployable sample applications\nvisualizing telemetry and transmission metadata from lorawan devices with amazon timestream and grafana plugin\nin this sample you will learn how to store telemetry from your lorawan devices as well as transmission metadata (e.g. rssi and snr per gateway) into amazon timestream. afterwards you will learn how to visualize time series data in grafana using a grafana plugin for amazon timestream.\nmonitoring and alarming of soil moisture by using aws iot core for lorawan and aws iot events\ndetecting events based on telemetry data from connected devices is a common use case in iot across many industries. this sample explains how to integrate aws iot events with lorawan for iot core. you can learn how to translate telemetry values from a lorawan device into events and notify users about these events using e-mail and sms.\nuseful guidelines\nautomation guidelines explain how to use aws cli to automate tasks (e.g. configuration of a new gateway).\nobservability guidelines explaion how to retrieve statistics about the state of your lorawan gateways and devices\nincluded binary decoders\nlorawan devices often encode transmitted data in a binary format, as it increases transmission efficiency and improves battery lifetime. however, as the data arrive in the cloud, many use cases require a structured format. transforming the binary data into json, for example, enables filtering and enrichment using aws iot sql as well as integration with further aws services using aws iot rule actions.\nthe sample decoding binary payloads from lorawan devices repository contains examples of binary decoders. please note that all decoders are provided without any guarantee to fit for any specific purpose and are only intended for use in a laboratory or prototyping environment. the list below is not to be understood as a recommendation of specific manufacturers or specific device models. aws iot core for lorawan supports any lorawan device that complies with lorawan specifications 1.0.x and 1.1. please consult aws partner device catalog for an overview of qualified devices. said that, please find an overview of examples below:\ngeneric\ndragino lsn50\nair quality / co2 / environment measurement\nelsys ers co2\ndoor and window opening\nelsys ems door\ndragino lds01\ngnss tracking\ndragino lgt92\nglobalsat lt-100\nbrowan tabs object locator\npresence and smart home\ntektelic smart room sensor\nsound level measurement\nelsys ers sound\ntemperature, humidity and moisture\nbrowan tabs temperature & humidity sensor\ndragino lht65 (temperature and humidity)\ndragino lse01 (temperature and moisture)\ndragino llms01 (-----> leaf !!!  moisture sensor)\ndragino laq4 (air quality sensor co2 + tvoc)\nelsys ers lite\nlaird senstrius rs1xx\nwater metering\naxioma w1\ncayenne low power payload (lpp)\nnetwork tester\nadeunis ftd2\ndigital contact sensor\nadeunis dry contacts\nweather station\nmeteohelix iot pro\ncontributions to example binary decoders are welcome.\ngetting help\napi reference\ndeveloper guide\nfaqs\nsupport forums\npartner catalog\ntest results\nbranch result\nmain", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000825, "year": null}], "name": "leafIot"}
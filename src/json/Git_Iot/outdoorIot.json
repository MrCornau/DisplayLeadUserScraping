{"interestingcomments": [{"Unnamed: 0": 420, "autor": 420, "date": null, "content": "Attention! This project is no longer maintained and obsolete. The successor of this project is called 'Wirehome.Core' (https://github.com/chkr1011/Wirehome.Core).\nHA4IoT\nHA4IoT (Home Automation for Internet of Things) is an Open Source Home Automation application running on Windows 10 IoT Core. It allows integration of different hardware actuators and sensors. It also provides a HTML/JavaScript based WebApp to control the system. But also other external services like Alexa, Twitter, Telegram etc. are supported.\nRaspberry Pi\nThe core application of this project is running under Windows 10 IoT Core which is available for free and runs on a Raspberry Pi 2/3 for example. But any other compatible board is supported.\nAmazon Alexa support\nThis project contains a Custom Skill for Amazon Alexa (Echo and Echo Dot) which allows controlling actuators via speech commands and ask for sensor status like open windows etc.\nDemos\nTurn lamp on and off: https://www.youtube.com/watch?v=9089vAgu2pQ\nTurn device on and off: https://youtu.be/RaIP7T-nLUs\nCCTools support\nThis project has build in support for many devices from CCTools (www.CCTools.eu) like I2C based relay boards and I2C port expanders. Support boards from CCTools are:\nHSRel5\nHSRel8(+8)\nI2C-Port16-HS\nPCF-Ports-HS\nBut also other compatible I2C boards based on PCF8574, PCA9555 or MAX7311 are supported.\n433 MHz support\nControlling old 433 MHz devices is supported via using a I2C or WiFi -> 433 MHz sender bridge. The bridge is based on Arduino/ESP8266. Also recording 433 MHz signals like from a TV remote is supported.\nItead Studio Sonoff supported\nThis project has build in support for several Sonoff devices from Itead Studio (www.itead.cc). But it is necessary to replace the firmware with a different one. More information can be found here: https://github.com/arendst/Sonoff-Tasmota\nLUA scripting support\nWrite your own scripts using the scripting language LUA to write powerful automations or interacting with your hardware.\nExtensible\nIt is possible to add Adapters for different hardware. I2C bus and MQTT broker are already available in the project.\nCloud based access\nThe HA4IoT WebApp is able to communicate with the controller (Raspberry Pi i.e.) using the Azure cloud. This feature requires an Azure subscription and is optionally.\nBuild in actuators and sensors\nLots of actuators and sensors are already implemented in this project and can be reused. It is also possible to add custom actuators and sensors.\nAwards\nThis project was one of the winners of the \"Windows 10 Home Automation\" contest at Hackster.io. The project documentation is also available at hackster.io (https://www.hackster.io/cyborg-titanium-14/ck-homeautomation).\nThis brilliant project explores uncharted home-automation territory; it even includes a cat litterbox controller, which detects the cat and channels the air into an outdoor flue! Be sure to check out the whole hack; it's an incredible embedded system with extensive wiring built right into the house.\nhackster.io (https://www.hackster.io/blog/win-10-winners)\nContributors\nIf you are interested in supporting this project in any way feel free to contact me. We are a growing community which needs your support.\nKey features\nVirtual actuators like push buttons, motion motion detectors, lamps, sockets, roller shutters which can be interconnected using a fluent API\nResponsive WebApp for iOS, Android, OSX and Windows\nHighly configurable automations with complex conditions\nPredefined conditions depending on sunrise, sunset, time, state of other actuators, position of roller shutters, motion detected\nPredefined common automations like automated lights, roller shutters etc.\nSoftware architecture using several layers which allows for transparent configuration of inputs and outputs across the used hardware\nOptional integration of Microsoft Azure EventHubs to allow for analysis of actuator states or power consumption statistics\nOptional CSV log containing all state changes of every actuator which allows for analysis of actuator states or power consumption\nUDP broadcasted debug traces\nPowerful RESTful API\nComplete with fritzing sketches and documentation to build devices like 433Mhz sender, sensors etc. on your own\nBuilt-in automations\nOpening roller shutters after sunrise\nClosing roller shutters after sunset\nClosing roller shutters if outside temperature reaches a custom value (intended for rooms below the roof)\nPrevent automatic opening of roller shutters if they maybe frozen (checking of outside temperature)\nPrevent automatic opening of roller shutters if sunrise is too early (before your alarm clock)\nAutomatic light based on motion detectors\nAutoamtic light based on time\nAutoamtic lights can be configured to be only active at night\nDisable automatic light if another light is already active\nDisable every actuator temporary\nThe project provides a powerful condition framework which allows creating of complex autoamtions using C#\nPersonal Agent\nRegister a free bot for the messenger \"Telegram\" and let the bot control the home. Just tell him what he should do. The bot also supports giving status information like Weather information (Temperature, Humidity etc.), Window states (Open, Closed), Sensor values (Temperature, Humidity) etc. The bot will also send errors and warnings from the log to administrative users (which are defined in the configuration file). Every user who want's to interact with the bot must be added to a whitelist to ensure a high level of privacy.\nApp\nEvery actuator can be controlled using the web app which is hosted at the Raspberry Pi 2 using the build in webserver. The language for the examples is German but translation of each UI element is supported. The app shows every rooms/areas and provides several overviews like the overview of all temperature sensor. The app is based on Bootstrap and AngularJS and runs on Smartphones, Tables, PCs etc.\nManagement App\nThe management app is an HTML/JavaScript application based on AngularJS and Bootstrap which is used the configure all areas, components, automations etc. It is deployed to the controller (Raspberry Pi 2 i.e.) and can be also used to create backups from the configuration.", "link": "https://github.com/chkr1011/HA4IoT", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "outdoor", "selectorShort": "outdoor", "MarkedSent": "attention! this project is no longer maintained and obsolete. the successor of this project is called 'wirehome.core' (https://github.com/chkr1011/wirehome.core).\nha4iot\nha4iot (home automation for internet of things) is an open source home automation application running on windows 10 iot core. it allows integration of different hardware actuators and sensors. it also provides a html/javascript based webapp to control the system. but also other external services like alexa, twitter, telegram etc. are supported.\nraspberry pi\nthe core application of this project is running under windows 10 iot core which is available for free and runs on a raspberry pi 2/3 for example. but any other compatible board is supported.\namazon alexa support\nthis project contains a custom skill for amazon alexa (echo and echo dot) which allows controlling actuators via speech commands and ask for sensor status like open windows etc.\ndemos\nturn lamp on and off: https://www.youtube.com/watch?v=9089vagu2pq\nturn device on and off: https://youtu.be/raip7t-nlus\ncctools support\nthis project has build in support for many devices from cctools (www.cctools.eu) like i2c based relay boards and i2c port expanders. support boards from cctools are:\nhsrel5\nhsrel8(+8)\ni2c-port16-hs\npcf-ports-hs\nbut also other compatible i2c boards based on pcf8574, pca9555 or max7311 are supported.\n433 mhz support\ncontrolling old 433 mhz devices is supported via using a i2c or wifi -> 433 mhz sender bridge. the bridge is based on arduino/esp8266. also recording 433 mhz signals like from a tv remote is supported.\nitead studio sonoff supported\nthis project has build in support for several sonoff devices from itead studio (www.itead.cc). but it is necessary to replace the firmware with a different one. more information can be found here: https://github.com/arendst/sonoff-tasmota\nlua scripting support\nwrite your own scripts using the scripting language lua to write powerful automations or interacting with your hardware.\nextensible\nit is possible to add adapters for different hardware. i2c bus and mqtt broker are already available in the project.\ncloud based access\nthe ha4iot webapp is able to communicate with the controller (raspberry pi i.e.) using the azure cloud. this feature requires an azure subscription and is optionally.\nbuild in actuators and sensors\nlots of actuators and sensors are already implemented in this project and can be reused. it is also possible to add custom actuators and sensors.\nawards\nthis project was one of the winners of the \"windows 10 home automation\" contest at hackster.io. the project documentation is also available at hackster.io (https://www.hackster.io/cyborg-titanium-14/ck-homeautomation).\nthis brilliant project explores uncharted home-automation territory; it even includes a cat litterbox controller, which detects the cat and channels the air into an -----> outdoor !!!  flue! be sure to check out the whole hack; it's an incredible embedded system with extensive wiring built right into the house.\nhackster.io (https://www.hackster.io/blog/win-10-winners)\ncontributors\nif you are interested in supporting this project in any way feel free to contact me. we are a growing community which needs your support.\nkey features\nvirtual actuators like push buttons, motion motion detectors, lamps, sockets, roller shutters which can be interconnected using a fluent api\nresponsive webapp for ios, android, osx and windows\nhighly configurable automations with complex conditions\npredefined conditions depending on sunrise, sunset, time, state of other actuators, position of roller shutters, motion detected\npredefined common automations like automated lights, roller shutters etc.\nsoftware architecture using several layers which allows for transparent configuration of inputs and outputs across the used hardware\noptional integration of microsoft azure eventhubs to allow for analysis of actuator states or power consumption statistics\noptional csv log containing all state changes of every actuator which allows for analysis of actuator states or power consumption\nudp broadcasted debug traces\npowerful restful api\ncomplete with fritzing sketches and documentation to build devices like 433mhz sender, sensors etc. on your own\nbuilt-in automations\nopening roller shutters after sunrise\nclosing roller shutters after sunset\nclosing roller shutters if outside temperature reaches a custom value (intended for rooms below the roof)\nprevent automatic opening of roller shutters if they maybe frozen (checking of outside temperature)\nprevent automatic opening of roller shutters if sunrise is too early (before your alarm clock)\nautomatic light based on motion detectors\nautoamtic light based on time\nautoamtic lights can be configured to be only active at night\ndisable automatic light if another light is already active\ndisable every actuator temporary\nthe project provides a powerful condition framework which allows creating of complex autoamtions using c#\npersonal agent\nregister a free bot for the messenger \"telegram\" and let the bot control the home. just tell him what he should do. the bot also supports giving status information like weather information (temperature, humidity etc.), window states (open, closed), sensor values (temperature, humidity) etc. the bot will also send errors and warnings from the log to administrative users (which are defined in the configuration file). every user who want's to interact with the bot must be added to a whitelist to ensure a high level of privacy.\napp\nevery actuator can be controlled using the web app which is hosted at the raspberry pi 2 using the build in webserver. the language for the examples is german but translation of each ui element is supported. the app shows every rooms/areas and provides several overviews like the overview of all temperature sensor. the app is based on bootstrap and angularjs and runs on smartphones, tables, pcs etc.\nmanagement app\nthe management app is an html/javascript application based on angularjs and bootstrap which is used the configure all areas, components, automations etc. it is deployed to the controller (raspberry pi 2 i.e.) and can be also used to create backups from the configuration.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000420, "year": null}, {"Unnamed: 0": 639, "autor": 639, "date": null, "content": "ESP-NOW (Beta)\nThis project provides examples to simplify the use of ESP-NOW.\nESP-NOW is a kind of connectionless Wi-Fi communication protocol that is defined by Espressif. Different from tradional Wi-Fi protocols, the first five upper layers in OSI are simplified to one layer in ESP-NOW, the data does not need to go through the physical layer, data link layer, network layer, transport layer in turn, which reduces the delay caused by packet loss under congested network, leads to quickly response time.\nIntroduce\nESP-NOW occupies less CPU and flash resource, it can work with Wi-Fi and Blutooth LE, supports the series of ESP8266\u3001ESP32\u3001ESP32-S and ESP32-C. The data transmission mode of ESP-NOW is flexible including unicast and broadcast, support one-to-many and many-to-many device connection and control. And ESP-NOW can be used as an independent auxiliary module to help network configuraresponcetion, debugging and firmware upgrades.\nThere are two roles defined in ESP-NOW according to the data flow, initiator and responder. The same device can have two roles at the same time. Generally, switches, sensors LCD screens etc. play the role of initaitor in an IoT system, when lights, sockets and other smart applications play the role of responder.\nTODO List\nGateway\nLow-power\nData Encryption\nFrequency-Hopping\nESP8266 supporting\nQuick Start\nHardware Preparation\nChips of ESP32\u3001ESP32-C3\u3001ESP32-S2 are recommended, ESP8266 and ESP32-S3 will be supported soon.\nexamples/dev_kits includes examples based on specific development boards. You need to buy the related boards before running the examples.\nSet up Development Environment\nSetting the environment and getting ESP-IDF (master) follow the Step .\nGet the ESP-NOW project\nDownload ESP-NOW using the following:\ngit clone --recursive https://github.com/espressif/esp-now.git\nnote: the --recursive option. This is required to pull in the dependencies into ESP-NOW. In case you have already cloned the repository without this option, execute this to pull in the submodules: git submodule update --init --recursive\nBuild and Flash firmware\nIt is recommended to first erase the flash if you are using this for the first time and then flash the firmware. Here are the steps:\n$ cd /path/to/esp-now/examples/get-started/\n$ export ESPPORT=/dev/tty.SLAB_USBtoUART #\n$ idf.py set-target esp32s2\n$ idf.py erase_flash\n$ idf.py flash monitor\nFunction\nControl\nThere are some obvious advantages in ESP-NOW:\nQuick Response: After power-on, the devices can transmit data and control other paired devices directly without any wireless connection, and the response speed is in milliseconds.\nLow-power: ESP-NOW simplifies the five layer protocols into one layer, which leads to easier communication process and lower power consumption, a control button can be used for two years just with two AA batteries.\nGood Compatibility: When the device connects to router or works as a hotpot, it can also relize a fast and stable communication by ESP-NOW. And the device can keep stable connection through ESP-NOW even if the router is faulty or the network is unstable.\nLong-distance Communication: ESP-NOW supports long-distance communication, it can be applied to outdoor scenes and can keep stable connection even the devices are seprated by walls even floors.\nMultilayer Control: We can realize the multi-hop control of devices by ESP-NOW. Hundreds of devices can be controlled through unicast, broadcast and group control.\nMultiple Control Methods: ESP-NOW supports the touch switch, LCD screen, different sensors and voice control.\nProvision\nESP-NOW is a provisioning method besides the Wi-Fi provisioning and Bluetooth provisioning. First, configure the network for the first device via bluetooth, and other devices don't need the information of SSID/password, the first device connected to the network can send these information to others directly. Users can choose whether to allow remaining devices to access the network on the APP side.\nUpgrade\nESP-NOW can be used for the mass data transmission like firmware upgrade.\nResume Upgrade from Break-point: when use ESP-NOW to upgrade the firmware, the firmware will be subpackaged in a fixed size and be wrote to the flash on by one., the device will recorde packages upgraded. If the upgrade process is interrupted, the device will only request the remain firemware packages to realize resume upgrade from break point.\nMultiple Devices Upgrade: ESP-NOW can support multiple devices upgrade at same time, 50 devices can be upgraded in 3 minutes.\nVersion Reset: the firmware can reset to previous version if an upgrade error occurs.\nDebug\nESP-NOW can be used to receive the running log for debugging. It can be used in scene where the devices can't be contact directly because of the high-voltage electricity, high temperature. With the supporting of many-to many connections, the initiator can receive logs from multiple responders to diagnose device faults quickly.\nDevice Log\nLog Analysis: analysis the running time and restart times from log.\nLog Storage: store the acquired data in the SD cards or export to the web.\nLog Modify: the log level of each function modele can be free adjusted.\nCommand Debugging\nPeripheral Debugging: control commands can be sent to test tje peripherals like GPIO, UART, LED etc.\nWi-Fi Debugging: the country code, Wi-Fi mode, Wi-Fi power .etc can be adjusted , and the perfomance of Wi-Fi can be debug.\nStatus Debugging: restart command, reset command, momory and task running status.\nCustom Command\nProduction Test\nAging Test: random restart, long-term monitoring of device\nInterference Test: distribute a large number of Wi-Fi data packets to interfere with the network.\nWireless Test: monitor the RF performance, ping packet test, distance and RF performance test.\nModule Test: flash read time test, time accuracy test.\nVersion Verification: verify whether the factory version of the device is the specified version.\nResources\nESP-NOW API guide\nESP-NOW in Arduino", "link": "https://github.com/espressif/esp-now", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "outdoor", "selectorShort": "outdoor", "MarkedSent": "esp-now (beta)\nthis project provides examples to simplify the use of esp-now.\nesp-now is a kind of connectionless wi-fi communication protocol that is defined by espressif. different from tradional wi-fi protocols, the first five upper layers in osi are simplified to one layer in esp-now, the data does not need to go through the physical layer, data link layer, network layer, transport layer in turn, which reduces the delay caused by packet loss under congested network, leads to quickly response time.\nintroduce\nesp-now occupies less cpu and flash resource, it can work with wi-fi and blutooth le, supports the series of esp8266\u3001esp32\u3001esp32-s and esp32-c. the data transmission mode of esp-now is flexible including unicast and broadcast, support one-to-many and many-to-many device connection and control. and esp-now can be used as an independent auxiliary module to help network configuraresponcetion, debugging and firmware upgrades.\nthere are two roles defined in esp-now according to the data flow, initiator and responder. the same device can have two roles at the same time. generally, switches, sensors lcd screens etc. play the role of initaitor in an iot system, when lights, sockets and other smart applications play the role of responder.\ntodo list\ngateway\nlow-power\ndata encryption\nfrequency-hopping\nesp8266 supporting\nquick start\nhardware preparation\nchips of esp32\u3001esp32-c3\u3001esp32-s2 are recommended, esp8266 and esp32-s3 will be supported soon.\nexamples/dev_kits includes examples based on specific development boards. you need to buy the related boards before running the examples.\nset up development environment\nsetting the environment and getting esp-idf (master) follow the step .\nget the esp-now project\ndownload esp-now using the following:\ngit clone --recursive https://github.com/espressif/esp-now.git\nnote: the --recursive option. this is required to pull in the dependencies into esp-now. in case you have already cloned the repository without this option, execute this to pull in the submodules: git submodule update --init --recursive\nbuild and flash firmware\nit is recommended to first erase the flash if you are using this for the first time and then flash the firmware. here are the steps:\n$ cd /path/to/esp-now/examples/get-started/\n$ export espport=/dev/tty.slab_usbtouart #\n$ idf.py set-target esp32s2\n$ idf.py erase_flash\n$ idf.py flash monitor\nfunction\ncontrol\nthere are some obvious advantages in esp-now:\nquick response: after power-on, the devices can transmit data and control other paired devices directly without any wireless connection, and the response speed is in milliseconds.\nlow-power: esp-now simplifies the five layer protocols into one layer, which leads to easier communication process and lower power consumption, a control button can be used for two years just with two aa batteries.\ngood compatibility: when the device connects to router or works as a hotpot, it can also relize a fast and stable communication by esp-now. and the device can keep stable connection through esp-now even if the router is faulty or the network is unstable.\nlong-distance communication: esp-now supports long-distance communication, it can be applied to -----> outdoor !!!  scenes and can keep stable connection even the devices are seprated by walls even floors.\nmultilayer control: we can realize the multi-hop control of devices by esp-now. hundreds of devices can be controlled through unicast, broadcast and group control.\nmultiple control methods: esp-now supports the touch switch, lcd screen, different sensors and voice control.\nprovision\nesp-now is a provisioning method besides the wi-fi provisioning and bluetooth provisioning. first, configure the network for the first device via bluetooth, and other devices don't need the information of ssid/password, the first device connected to the network can send these information to others directly. users can choose whether to allow remaining devices to access the network on the app side.\nupgrade\nesp-now can be used for the mass data transmission like firmware upgrade.\nresume upgrade from break-point: when use esp-now to upgrade the firmware, the firmware will be subpackaged in a fixed size and be wrote to the flash on by one., the device will recorde packages upgraded. if the upgrade process is interrupted, the device will only request the remain firemware packages to realize resume upgrade from break point.\nmultiple devices upgrade: esp-now can support multiple devices upgrade at same time, 50 devices can be upgraded in 3 minutes.\nversion reset: the firmware can reset to previous version if an upgrade error occurs.\ndebug\nesp-now can be used to receive the running log for debugging. it can be used in scene where the devices can't be contact directly because of the high-voltage electricity, high temperature. with the supporting of many-to many connections, the initiator can receive logs from multiple responders to diagnose device faults quickly.\ndevice log\nlog analysis: analysis the running time and restart times from log.\nlog storage: store the acquired data in the sd cards or export to the web.\nlog modify: the log level of each function modele can be free adjusted.\ncommand debugging\nperipheral debugging: control commands can be sent to test tje peripherals like gpio, uart, led etc.\nwi-fi debugging: the country code, wi-fi mode, wi-fi power .etc can be adjusted , and the perfomance of wi-fi can be debug.\nstatus debugging: restart command, reset command, momory and task running status.\ncustom command\nproduction test\naging test: random restart, long-term monitoring of device\ninterference test: distribute a large number of wi-fi data packets to interfere with the network.\nwireless test: monitor the rf performance, ping packet test, distance and rf performance test.\nmodule test: flash read time test, time accuracy test.\nversion verification: verify whether the factory version of the device is the specified version.\nresources\nesp-now api guide\nesp-now in arduino", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000639, "year": null}, {"Unnamed: 0": 643, "autor": 643, "date": null, "content": "OpenAirProject AirQuality / Dust Meter\nFeatures\nThis meter measures dust (pm1, pm2.5, pm10 particles) and, optionally, other environmental conditions like temperature, pressure and humidity. Measurements occurs in configured intervals and the result is an average of multiple recorded samples. It handles 'warming period' necessary by the sensor to force proper air flow.\nCurrent air quality is indicated with different color of RGB led (blue color means that first measurement has not completed yet).\nData is sent via local wifi to one of configured services (currently - ThingSpeak, AWS IoT is coming soon). After booting up for the first time, sensor becomes an access point and enables user to configure wifi access via browser.\nHardware\nRequired parts:\nESP32 DevKit Board (other boards should also work after minor modifications). Plantower PMS5003 (or PMS3003 or PMS7003) Any push button\nOptional parts:\nBMP280 sensor for temperature/airpressure readings RGB Led (common kathode) + 3 resistors (330ohms+)\nWiring\nHere. I draw it myself.\nAssembling is rather trivial.\nPMSx003 sensor requires 5V power, although it communicates with standard 3V3, so no TTL converter is required. Connect RGB led via resistors to ESP32 and to GND. Connect BMP280 directly to ESP32. Connect button to one of pins to pull up when pressed.\nESP32 chip features GPIO matrix which means (theoretically) that programmatically we can change a function of any I/O pin. That being said, on ESP32 DevKit board some pins are already designated to perform specific function and may not work properly (or cause side effects) when assigned to other interfaces.\nFirmware is pre-configured to use following GPIO which were tested with ESP32 DevKit board.\nThese assignments can be changed via 'make menuconfig'.\nPMSx003 TX => 34\nPMSx003 SET => 10\nBMx280 SDA=> 25\nBMx280 SCL=> 26\nLED R=> 12\nLED G=> 27\nLED B=> 14\nBUTTON=> 35\nPower consumption\nSensor requires 5V+ and consumes ~150mA up to ~170mA. During booting power consumption can be slightly higher (~250mA), but it is still low enough to be powered directly from any decent USB phone charger or from PC.\nDespite low voltage, if you are going to use sensor outdoor or in any unfriendly environment (e.g. high humidity), please take it under consideration during build, isolate all connections properly and use appropriate case/enclosure (more on that soon).\nUploading firmware\nTo run your sensor you first need to flash ESP32 chip with OAP firmware.\nTo do so, you don't need to clone this project nor compile it - you can use pre-compiled firmware and a dedicated tool to handle the upload.\nThe procedure below was tested on Mac and Linux (Windows users, by now you should know the drill).\nGet proper USB cable to connect the sensor to your PC. All USB cables look similar, but some of them (which are usually thinner than others), cannot transfer data and are used only for powering/charging devices and are not suitable for our task.\nWhile Linux may detect sensor (or rather - usb driver chip installed on the esp32 board), other systems will most likely require installing a custom USB driver that matches the chip. Its type depends on the ESP32 board, but in majority of cases it should be a Silabs chip for which a driver can be found at http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx).\nOnce driver is installed and sensor is connected with usb cable to PC, do\nls -la /dev/tty*\nto find out what name of the serial port was assigned to our sensor (the easiest way is to list this folder with sensor disconnected and connected and compare results). Note it down. On my Mac it was \"/dev/tty.SLAB_USBtoUART\", on Linux - \"/dev/ttyUSB0\" or /dev/ttyUSB1\" but it may be different depending on the system configuration.\nNow download the firmware (three *.bin files) for the latest stable release that you can find here https://github.com/openairproject/sensor-esp32/releases.\nNow it is time to install \"esptool\", which is a firmware uploader from the manufacturer of ESP32 chip (Espressif company). Detailed instructions can be found here: https://github.com/espressif/esptool/blob/master/README.md, but if you already have Python and pip installed, just do\npip install esptool\nBy default it should be installed to \"/usr/local/bin/\".\nIt is time to perform the flashing:\nesptool.py --chip esp32 --port /dev/ttyUSB0 --baud 921600 --before default_reset --after hard_reset write_flash -u --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader.bin 0x30000 sensor-esp32.bin 0x8000 partitions.bin\nUse --port from the step 3, and three bin files downloaded in step 4.\nIn most cases, esptool will be able to switch your sensor into 'flashing' mode automatically and reset it afterwords to make it ready to go - it takes a few seconds. Some boards however require manual operation to activate this mode (esptool connection will timeout). To do so, disconnect the sensor from USB, press and hold small button labeled \"EN\" on esp32 board (next to micro usb port), connect the sensor, run the command above and then release the button.\nFirst run\nAfter booting the sensor for the first time, sensor will switch into Access Point mode and create a wifi network\nssid: OpenAirProject-XXXXXX\npass: cleanair\nAfter connecting to this network, open following url\nhttp://192.168.1.1\nand configure sensor settings using web control panel (most notably - your home wifi ssid/pass). After rebooting sensor will connect to your wifi .Web control panel will still be available, but at IP that was specified or assigned to sensor by your router.\nIf there's a need to force sensor into Access Point mode again (e.g. when it can't connect to specified wifi), reboot the device with a control button pressed down.\nBuilding firmware\nThis part is for advanced users, in most cases you should be fine with installing pre-build firmware.\nOAP firmware is written in native espressif-sdk v2.1 http://esp-idf.readthedocs.io/en/v2.1/get-started/index.html\nAfter installing and setting up SDK, connect your ESP32 board to your PC. See notes regarding USB cable and driver in a chapter above.\nTo configure and build sources\nmake -j5\nYou can always bring up configuration menu via\nmake menuconfig\nDuring the first run, a menuconfig should appear where you need to configure some parameters of your setup, most notably - UART port.\nIn components submenu there's a few configuration settings related to OAP hardware setup (e.g. gpio pin assignments), and \"OAP Main\" menu where you can change various functional parameters.\n** ATTENTION. main task stack should be increased to 10K if you're gonna use AWSIoT (via menuconfig) **\nAll settings are saved in sdkconfig file.\nto flash the module and read from the serial output\nmake flash monitor\nThat's it.\nHappy DIY time!", "link": "https://github.com/openairproject/sensor-esp32", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "outdoor", "selectorShort": "outdoor", "MarkedSent": "openairproject airquality / dust meter\nfeatures\nthis meter measures dust (pm1, pm2.5, pm10 particles) and, optionally, other environmental conditions like temperature, pressure and humidity. measurements occurs in configured intervals and the result is an average of multiple recorded samples. it handles 'warming period' necessary by the sensor to force proper air flow.\ncurrent air quality is indicated with different color of rgb led (blue color means that first measurement has not completed yet).\ndata is sent via local wifi to one of configured services (currently - thingspeak, aws iot is coming soon). after booting up for the first time, sensor becomes an access point and enables user to configure wifi access via browser.\nhardware\nrequired parts:\nesp32 devkit board (other boards should also work after minor modifications). plantower pms5003 (or pms3003 or pms7003) any push button\noptional parts:\nbmp280 sensor for temperature/airpressure readings rgb led (common kathode) + 3 resistors (330ohms+)\nwiring\nhere. i draw it myself.\nassembling is rather trivial.\npmsx003 sensor requires 5v power, although it communicates with standard 3v3, so no ttl converter is required. connect rgb led via resistors to esp32 and to gnd. connect bmp280 directly to esp32. connect button to one of pins to pull up when pressed.\nesp32 chip features gpio matrix which means (theoretically) that programmatically we can change a function of any i/o pin. that being said, on esp32 devkit board some pins are already designated to perform specific function and may not work properly (or cause side effects) when assigned to other interfaces.\nfirmware is pre-configured to use following gpio which were tested with esp32 devkit board.\nthese assignments can be changed via 'make menuconfig'.\npmsx003 tx => 34\npmsx003 set => 10\nbmx280 sda=> 25\nbmx280 scl=> 26\nled r=> 12\nled g=> 27\nled b=> 14\nbutton=> 35\npower consumption\nsensor requires 5v+ and consumes ~150ma up to ~170ma. during booting power consumption can be slightly higher (~250ma), but it is still low enough to be powered directly from any decent usb phone charger or from pc.\ndespite low voltage, if you are going to use sensor -----> outdoor !!!  or in any unfriendly environment (e.g. high humidity), please take it under consideration during build, isolate all connections properly and use appropriate case/enclosure (more on that soon).\nuploading firmware\nto run your sensor you first need to flash esp32 chip with oap firmware.\nto do so, you don't need to clone this project nor compile it - you can use pre-compiled firmware and a dedicated tool to handle the upload.\nthe procedure below was tested on mac and linux (windows users, by now you should know the drill).\nget proper usb cable to connect the sensor to your pc. all usb cables look similar, but some of them (which are usually thinner than others), cannot transfer data and are used only for powering/charging devices and are not suitable for our task.\nwhile linux may detect sensor (or rather - usb driver chip installed on the esp32 board), other systems will most likely require installing a custom usb driver that matches the chip. its type depends on the esp32 board, but in majority of cases it should be a silabs chip for which a driver can be found at http://www.silabs.com/products/mcu/pages/usbtouartbridgevcpdrivers.aspx).\nonce driver is installed and sensor is connected with usb cable to pc, do\nls -la /dev/tty*\nto find out what name of the serial port was assigned to our sensor (the easiest way is to list this folder with sensor disconnected and connected and compare results). note it down. on my mac it was \"/dev/tty.slab_usbtouart\", on linux - \"/dev/ttyusb0\" or /dev/ttyusb1\" but it may be different depending on the system configuration.\nnow download the firmware (three *.bin files) for the latest stable release that you can find here https://github.com/openairproject/sensor-esp32/releases.\nnow it is time to install \"esptool\", which is a firmware uploader from the manufacturer of esp32 chip (espressif company). detailed instructions can be found here: https://github.com/espressif/esptool/blob/master/readme.md, but if you already have python and pip installed, just do\npip install esptool\nby default it should be installed to \"/usr/local/bin/\".\nit is time to perform the flashing:\nesptool.py --chip esp32 --port /dev/ttyusb0 --baud 921600 --before default_reset --after hard_reset write_flash -u --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader.bin 0x30000 sensor-esp32.bin 0x8000 partitions.bin\nuse --port from the step 3, and three bin files downloaded in step 4.\nin most cases, esptool will be able to switch your sensor into 'flashing' mode automatically and reset it afterwords to make it ready to go - it takes a few seconds. some boards however require manual operation to activate this mode (esptool connection will timeout). to do so, disconnect the sensor from usb, press and hold small button labeled \"en\" on esp32 board (next to micro usb port), connect the sensor, run the command above and then release the button.\nfirst run\nafter booting the sensor for the first time, sensor will switch into access point mode and create a wifi network\nssid: openairproject-xxxxxx\npass: cleanair\nafter connecting to this network, open following url\nhttp://192.168.1.1\nand configure sensor settings using web control panel (most notably - your home wifi ssid/pass). after rebooting sensor will connect to your wifi .web control panel will still be available, but at ip that was specified or assigned to sensor by your router.\nif there's a need to force sensor into access point mode again (e.g. when it can't connect to specified wifi), reboot the device with a control button pressed down.\nbuilding firmware\nthis part is for advanced users, in most cases you should be fine with installing pre-build firmware.\noap firmware is written in native espressif-sdk v2.1 http://esp-idf.readthedocs.io/en/v2.1/get-started/index.html\nafter installing and setting up sdk, connect your esp32 board to your pc. see notes regarding usb cable and driver in a chapter above.\nto configure and build sources\nmake -j5\nyou can always bring up configuration menu via\nmake menuconfig\nduring the first run, a menuconfig should appear where you need to configure some parameters of your setup, most notably - uart port.\nin components submenu there's a few configuration settings related to oap hardware setup (e.g. gpio pin assignments), and \"oap main\" menu where you can change various functional parameters.\n** attention. main task stack should be increased to 10k if you're gonna use awsiot (via menuconfig) **\nall settings are saved in sdkconfig file.\nto flash the module and read from the serial output\nmake flash monitor\nthat's it.\nhappy diy time!", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000643, "year": null}, {"Unnamed: 0": 654, "autor": 654, "date": null, "content": "Home Assistant Configuration\nConfiguration for my home-assistant setup running on Home Assistant OS on a Raspberry Pi 3 Model B.\nHardware\nRaspberry Pi 3 Model B\nTelldus Tellstick ZNet Lite v2\nNetatmo Weather Station\nGoogle Nest Mini / Hub\nPhillips Hue Hub\nXiaomi Roborock Vacuum\nDevices:\nTelldus Thermometer/hygrometer\nNexa MYCR-3 Plug\nNexa WMR-1000 Receiver\nLuxorparts Outdoor Plug\nFibaro Wall Plug\nFibaro Motion Sensor\nFibaro Smoke Sensor 2\nFibaro Flood Sensor\nFibaro Door/Window Sensor 2\nPhillips Hue Lights\nRaspberry Pi Camera V2\nMedia:\nSamsung Smart TV\nOnkyo Receiver\nGoogle ChromeCast\nSpotify\nWeather:\nMet.no\nFrontend\nThe frontend is using the new Lovelace UI, with a customized configuration and several custom cards.\nHome Assistant Community Store (HACS) is used to install and update most of the custom cards/plugins.\nTheme\nMidnight theme from the HA Community (by marcelhoffs).\nMy Lovelace Cards\nI've created and currently maintain a few plugins (cards) for Home Assistant's Lovelace UI:\nxiaomi-vacuum-card\nmultiple-entity-row\ngithub-entity-row\nbattery-entity-row\nHassOS Maintenance\nssh root@192.168.0.XX\nSSH to host\nhttps://gist.github.com/enegaard/a57af286205914bd912270c89650fb1b\nhttps://developers.home-assistant.io/docs/operating-system/debugging/#ssh-access-to-the-host\nssh root@homeassistant -p 22222\nHassbian Maintenance (deprecated)\ncd /home/homeassistant/.homeassistant/\nsudo systemctl start home-assistant@homeassistant.service\nsudo systemctl stop home-assistant@homeassistant.service\nsudo systemctl restart home-assistant@homeassistant.service\nVirtual Environment\nsudo -u homeassistant -H -s\nsource /srv/homeassistant/bin/activate\nUpgrading\nsudo apt-get update\nsudo apt-get upgrade\nStop the home-assistant service before running the following:\nsudo -u homeassistant -H -s\nsource /srv/homeassistant/bin/activate\npip3 install --upgrade homeassistant\nCertificate\nFor initial setup see home-assistants Let's Encrypt guide.\nsudo apt-get install certbot\nsudo certbot certonly --standalone --preferred-challenges http-01 --email <email> -d <hostname>\nchmod 755 /etc/letsencrypt/live/your.site/\nchmod 755 /etc/letsencrypt/archive/your.site/\nsudo certbot renew\nNmap Tracker\nsudo apt-get install net-tools nmap\nsudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap\nScreenshots", "link": "https://github.com/benct/home-assistant-config", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "outdoor", "selectorShort": "outdoor", "MarkedSent": "home assistant configuration\nconfiguration for my home-assistant setup running on home assistant os on a raspberry pi 3 model b.\nhardware\nraspberry pi 3 model b\ntelldus tellstick znet lite v2\nnetatmo weather station\ngoogle nest mini / hub\nphillips hue hub\nxiaomi roborock vacuum\ndevices:\ntelldus thermometer/hygrometer\nnexa mycr-3 plug\nnexa wmr-1000 receiver\nluxorparts -----> outdoor !!!  plug\nfibaro wall plug\nfibaro motion sensor\nfibaro smoke sensor 2\nfibaro flood sensor\nfibaro door/window sensor 2\nphillips hue lights\nraspberry pi camera v2\nmedia:\nsamsung smart tv\nonkyo receiver\ngoogle chromecast\nspotify\nweather:\nmet.no\nfrontend\nthe frontend is using the new lovelace ui, with a customized configuration and several custom cards.\nhome assistant community store (hacs) is used to install and update most of the custom cards/plugins.\ntheme\nmidnight theme from the ha community (by marcelhoffs).\nmy lovelace cards\ni've created and currently maintain a few plugins (cards) for home assistant's lovelace ui:\nxiaomi-vacuum-card\nmultiple-entity-row\ngithub-entity-row\nbattery-entity-row\nhassos maintenance\nssh root@192.168.0.xx\nssh to host\nhttps://gist.github.com/enegaard/a57af286205914bd912270c89650fb1b\nhttps://developers.home-assistant.io/docs/operating-system/debugging/#ssh-access-to-the-host\nssh root@homeassistant -p 22222\nhassbian maintenance (deprecated)\ncd /home/homeassistant/.homeassistant/\nsudo systemctl start home-assistant@homeassistant.service\nsudo systemctl stop home-assistant@homeassistant.service\nsudo systemctl restart home-assistant@homeassistant.service\nvirtual environment\nsudo -u homeassistant -h -s\nsource /srv/homeassistant/bin/activate\nupgrading\nsudo apt-get update\nsudo apt-get upgrade\nstop the home-assistant service before running the following:\nsudo -u homeassistant -h -s\nsource /srv/homeassistant/bin/activate\npip3 install --upgrade homeassistant\ncertificate\nfor initial setup see home-assistants let's encrypt guide.\nsudo apt-get install certbot\nsudo certbot certonly --standalone --preferred-challenges http-01 --email <email> -d <hostname>\nchmod 755 /etc/letsencrypt/live/your.site/\nchmod 755 /etc/letsencrypt/archive/your.site/\nsudo certbot renew\nnmap tracker\nsudo apt-get install net-tools nmap\nsudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip /usr/bin/nmap\nscreenshots", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000654, "year": null}, {"Unnamed: 0": 845, "autor": 845, "date": null, "content": "Distributed Motion Surveillance Security System (DMS3)\nNEW! for Release 1.3.0 - DMS3Dashboard\nEver wonder if your surveillance cameras are operational, in need of updates, or even a reboot? The new DMS3Dashboard component can be enabled to run on a DMS3Server component and provide regularly-updated information for all DMS3Client components with device metrics including:\nHostname\nHardware platform and operating system\nKernel version\nCurrent DMS3 component uptime\nCount of DMS3Clients reporting to the DMS3Server\nCount of surveillance events generated by that component (if applicable)\nDate/time (ISO 8601) the component last reported to the DMS3Server\nAdditionally, DMS3Dashboard provides a quick visual health check of all DMS3Client components, using color-sensitive component icons, where:\nGreen: a DMS3Client has reported to the server within an expected period of time (as configured)\nYellow: a DMS3Client is late in reporting, exceeding its configured reporting interval\nRed: a DMS3Client has not reported to the server, and requires attention\nIn the image above, five DMS3 device components are displayed in the DMS3Dashboard: one DMS3Server (listed first), and four DMS3Client device components. One DMS3Client--picam-alpha--is late in reporting to the server, and so its icon has turned yellow to warn the user of its potentially failing status\nThe new DMS3Dashboard component is written using Go's HTML templating package, making it very easy to integrate new or existing HTML template themes into the component. The template used by DMS3Dashboard is based largely on the following resources:\nCreative Tim's Paper Dashboard Theme\nFonts provided by Icomoon\nNote that the DMS3Dashboard version of the Paper Dashboard design is heavily modified (primarily reduced in size and resources, and JS removed), and the original Themify fonts replaced with Icomoon fonts, among other design changes. To demo the unadulternated Paper Dashboard template in action, see Creative Tim's excellent live preview here.\n1. What Is DMS3?\nIf you appreciate isometric drawings, please check out our isometric-icons project, located here.\nDistributed Motion Surveillance Security System (DMS3) is a Go-based application that integrates third-party open-source motion detection applications (e.g., the Motion motion detection software package, or OpenCV, the Open Source Computer Vision Library) into a distributed surveillance system that:\nSenses when someone is \"at home\" and when someone is \"not home\" and automatically enables or disables the surveillance system\nDistributes video stream processing, reporting, and user notification to capable \"smart\" device clients (e.g., a Raspberry Pi) which:\nMinimizes network congestion, particularly during high-bandwidth surveillance events of interest\nBetter utilizes smart device client endpoint CPU processing power: keeping stream processing \"on-board\" and localized\nWorks cooperatively with legacy \"less smart\" device clients such as IP cameras (wired or WiFi), webcams, and other USB camera devices\n2. DMS3 Features\nHere's a list of some of the more outstanding features of DMS3:\nMotion Detection Application Support\nWhile DMS3 is primarily responsible for sensing user proxies and determining when to enable or disable the surveillance system, it alone does not manage the processing of video stream data. That complex, real-time task is left to motion detection libraries/applications which can be integrated into DMS3.\nSupport for the Motion motion detector software package\nMovement detection support of video devices. See this list for video device compatibility. Note that DMS3 was developed and tested using smart device clients running Motion with native camera support (e.g., a Raspberry Pi with an on-board camera module)\nSupport for the OpenCV Library [planned]\nOpenCV support is highly anticipated, but still experimental, though the current codebase cleanly abstracts away any specific motion detection application dependencies so it should be a very straightforward integration\nDMS3Client & DMS3Server Features\nNEW! support for the new DMS3Dashboard component, allowing for the easy, visual monitoring of all DMS3Client devices managed by a DMS3Server component\nMobile first, responsive, web-based design\nUses Go's HTML templating package to simplify HTML integration\nEasily integrate 3rd-party configurable HTML website templates\nAutomated starting/stopping of any number of motion detection applications installed on smart device clients (e.g., the Motion motion detector software package) based on the presence/absence of user proxy devices\nAlways On feature starts/stops the motion detection application based on time-of-day (e.g., can enable video surveillance during nighttime or specific holiday hours)\nOptionally play audio file(s) on surveillance system enable/disable\nConfigurable event logging\nINFO, ERROR, FATAL, and DEBUG log levels\nPersist logs to file or stdout\nMultiple user proxy device support (can sense device presence/absence from a list of devices)\nMAC (Layer 2) address sensing\nIPv4 protocol support\nIPv6 protocol support [planned]\nBluetooth user proxy sensing (using RSSI, L2CAP, or similar) [planned]\nDevice clients can be custom-configured to process and respond to surveillance event data independently and uniquely (e.g., an outdoor IR camera device only sends email during nighttime hours)\nSupport for \"Smart\" and \"Less Smart\" Device Clients\nDMS3 is designed to utilize intelligent IoT sensing devices, called Smart Device Clients (SDCs), while still supporting less intelligent, single-purpose devices, called Less Smart Device Clients (LSDCs).\nDMS3 Smart Device Clients (SDCs) are hardware devices capable of processing local video streams for motion detection on-board, with dedicated hardware. Most computers and smaller single board computers (IoT SBCs) would be classed as smart device clients, including:\nRaspberry PIs (DMS3 was tested with the RaspPi Model 2, Model 3, and Pi Zero W) with a configured on-board camera\nAny IoT single board computer (SBC) capable of running a Unix-like operating system\nPersonal computers with a camera and wired or wireless (WiFi) connectivity\nDMS3 Less Smart Device Clients (LSDCs) are hardware devices--typically purpose-built--unable to locally process motion detection in video streams. These devices generate raw real-time video data, which is then consumed and processed by an external device(s), oftentimes across the network. Some examples of LSDCs include:\nIP cameras (e.g., the Nest Cam), either wired or wireless (WiFi)\nWebcams, typically using USB connections and run from a desktop computer\nDMS3Mail Features\nDeveloped for use exclusively with Motion, DMS3Mail is an automated, real-time email notification service triggered by Motion-generated detection events\nFully configurable email message subject, body, etc.\nOptionally attach an event image or video to an email message\nSMTP-support for compatibility with most webmail services (e.g., Gmail)\nConfigurable event logging\nINFO, ERROR, FATAL, and DEBUG log levels\nPersist logs to file or stdout\n3. DMS3 Use Cases\n\"Leaving Home, Coming Home\"\nAt its core, DMS3 sensing relies on the concept of a user proxy. In this context, a user proxy is any device representing a user that can be sensed on a home network. A smartphone is an excellent user proxy, assuming that a user's smartphone is active on a home network when the user is \"at home,\" and leaves the network when the user \"leaves home.\"\nThis concept can extend to multiple user proxies, making it possible for DMS3 to keep a surveillance system disabled until everyone in a family has left home: once the last registered user proxy is no longer sensed on the home network, DMS3 automatically enables the surveillance system.\nThe reverse is true as well: DMS3 will keep a surveillance system enabled only until the first user proxy is seen on the home network (e.g., someone pulling into the driveway), at which time DMS3 will automatically disable the surveillance system.\n\"Nighttime Surveillance\"\nIn addition to sensing user proxies, DMS3 can be configured to keep a surveillance system enabled over specific periods of time. Called Always On, this DMS3 feature works as an override for user proxies: regardless of whether DMS3 senses a user proxy on the network, as long as the time-of-day policy is met, DMS3 will enable the surveillance system.\nThis feature is particularly useful for nighttime surveillance, when users may be asleep and/or smartphones may be turned off. For example, DMS3 can be configured to turn a surveillance system on at 2330, and stay on until 0500 the next morning. During this time, DMS3 will remain operational and report surveillance events as they occur.\n4. DMS3 Components\nDMS3 is organized into the following application components:\nDMS3Server: integrated server-side system services that determine whether to enable/disable the surveillance system, and regularly update participating DMS3 device clients of that surveillance state\nDMS3Client: client-side endpoint services that start/stop the locally-installed motion detection application (e.g., Motion). Any number of DMS3Client clients can exist as part of the DMS3 surveillance system\nDMS3Libs: a set of related shared libraries used for managing DMS3 client-server services including low-level system and networking commands, system logging, and unit testing\nDMS3Dashboard: an optionally-enabled component that permits for the visual inspection of DMS3 component metrics through a web browser\nOptional for smart device clients configured to use the Motion motion detection application:\nDMS3Mail: a separate configurable DMS3 component for generating and sending an email with videos/images whenever a client running Motion generates a significant motion-related hook events (such as on_picture_save and on_movie_end)\n5.0 DMS3 Architecture\nDMS3 is patterned after a client server model, where DMS3Server is centrally responsible for the logic of enabling/disabling the video surveillance system, while each participating smart device client is responsible for starting/stopping the locally-installed motion detection application. For less smart device clients, the processing of video stream data is passed over the wire to the server for processing and eventual system response and/or user notification.\nIn the example presented at the start of this document, one IP camera device, one IoT SBC device (a Raspberry Pi), and one webcam device are managed through DMS3Server (using the TCP protocol). DMS3Server determines when to enable/disable the surveillance system, and notifies each participating device client. Since the Raspberry Pi can be configured to run a local instance of a motion detection application (it's a smart device client), actual video stream processing, imaging, and eventual reporting is done locally.\nThe webcam device and the IP camera device--both less smart device clients, and incapable of on-board stream processing--must pass raw stream data along to a device proxy running DMS3Client, which then applies motion detection processing on the incoming video streams.\n6.0 How DMS3 Works\nDMS3Server Operation\nDMS3Server is responsible for signaling the logic of enabling/disabling the video surveillance system to all device client endpoints. That is, DMS3Server sends either a Start or a Stop message to all DMS3 device clients listening on the network.\nDMS3Server does this by periodically scanning the network for the existence of a registered user proxie(s). This device can be anything that exposes its MAC address on the network (e.g., a mobile phone on a home LAN). If that device is found on the network, it's assumed that \"someone is home\" and so, DMS3Server sends out a Stop message to all participating device clients, and their respective motion detection application is stopped (if currently running).\nIf that user proxy MAC \"leaves\" and is no longer found on the network, it's assumed that \"nobody is home\", and DMS3Server sends out a Start message to all participating device clients, and the motion detection application on that client is started (if currently stopped). Similar logic is used in the reverse case: when a user proxy is once again \"back home,\" the motion detection application of each device client is signalled to Stop.\nAlternatively, the Always On feature uses time-of-day to enable/disable the surveillance system. DMS3Server will look at the time range specified, and if the current time falls between the time range, the motion detection application of all client devices will be started. Once the current time falls outside of the specified time range, the motion detection application for each device client is then stopped.\nNote that DMS3Server only signals to participating device clients the current state of the video surveillance system. Each device client is ultimately responsible for starting/stopping its local instance of the installed motion detection application\nDMS3Client Operation\nRunning on Smart Device Clients (SDCs)\nDMS3Client runs on each configured smart device client endpoint, and is responsible for starting/stopping its locally installed motion detection application. DMS3Client does this by periodically listening to DMS3Server at the pre-configured IP address and port (network socket address). When DMS3Client receives a change in motion detection application state, it either starts or stops its locally-installed motion detection application.\nRunning with Less Smart Device Clients (LSDCs)\nIn instances where the device client is \"less smart\" and unable to process motion detection in local video streams, an LSDC instead passes motion detection processing to a DMS3Client proxy. Multiple LSDCs can be served by a single DMS3Client proxy. This proxy is then responsible for the operations of a typical DMS3Client.\nDMS3Client / DMS3Server Work Flow\nOperationally, DMS3Server and all DMS3Client device clients work in concert to establish a synchronized video surveillance state across all endpoints:\nDMS3Server: usually configured as a daemon running on a central server, and walks a logic tree whenever a client connects (or re-connects) to the server. DMS3Server is responsible for answering the question \"should the surveillance system be enabled or disabled right now?\"\nDMS3Client: usually configured as a daemon that runs on each of the participating smart device clients, DMS3Client regularly polls (at a configurable interval) DMS3Server, and receives from DMS3Server the current motion detection application state (called MotionDetectorState), that is, whether the locally installed motion detection application should be started or stopped\nThe activity diagram below shows the work flow of these two components:\nDMS3Mail Operation\nWhen using Motion, DMS3Mail is a feature written for DMS3 that allows for the creation and sending an email whenever a valid capture event is triggered in Motion. DMS3Mail is very tightly integrated into Motion, where image and video capture events are identified, analyzed, and processed. DMS3Mail is triggered by the on_picture_save and the on_movie_end commands in Motion.\nNote: the optional DMS3Mail feature is called by neither DMS3Client nor DMS3Server. Instead, DMS3Mail is called by the Motion motion detection application via the command-line.\nThe syntax for these Motion commands are:\n<on_picture_save|on_movie_end> <absolute path to go_dms3mail> -pixels=%D -filename=%f -camera=%t\nThese commands are managed through the Motion configuration file called motion.conf.\nOnce configured, DMS3Mail will respond to these two Motion event hooks, and an email will be generated and sent out with an optional image file or video clip capturing the surveillance event of interest.\nNote: additional information about DMS3Mail can be found in the DMS3 installation file (INSTALL.md).\n7. DMS3 Requirements\nA Unix-like operating system installed on the server and smart device client (SDC) endpoints\nWhile DMS3 was written and tested under Linux (Ubuntu 17.04), there should be no reason why this won't work under other Linux distributions\nA motion detection application, such as Motion, correctly installed and configured with appropriate video devices configured on all smart device clients\nSpecific Unix-like commands and tools used by DMS3 components include (all should already exist on most Unix-like operating systems):\narp: address resolution protocol\ngrep: globally search a regular expression and print\npgrep: globally search a regular expression and print\nping: ICMP network packet echo/response tool\naplay: ALSA audio player (optional)\n8. DMS3 Installation\nDMS3 provides two separate installation documents:\nQuick Installation: uses the available dms3build build tools and installer to provided automated installation of DMS3 components across participating hardware devices\nManual Installation: uses project sources to first compile for specific hardware device platforms, and then manually install DMS3 components\nNote: to learn more about the technical details of the DMS3 project, refer to the Manual Installation documentation, as this document provides much greater technical depth in describing the DMS3 installation process\n9. License\nThe MIT License (MIT)\nCopyright (c) Business Learning Incorporated\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", "link": "https://github.com/richbl/go-distributed-motion-s3", "origin": "Github", "suborigin": "Iot", "result": true, "Selector": "outdoor", "selectorShort": "outdoor", "MarkedSent": "distributed motion surveillance security system (dms3)\nnew! for release 1.3.0 - dms3dashboard\never wonder if your surveillance cameras are operational, in need of updates, or even a reboot? the new dms3dashboard component can be enabled to run on a dms3server component and provide regularly-updated information for all dms3client components with device metrics including:\nhostname\nhardware platform and operating system\nkernel version\ncurrent dms3 component uptime\ncount of dms3clients reporting to the dms3server\ncount of surveillance events generated by that component (if applicable)\ndate/time (iso 8601) the component last reported to the dms3server\nadditionally, dms3dashboard provides a quick visual health check of all dms3client components, using color-sensitive component icons, where:\ngreen: a dms3client has reported to the server within an expected period of time (as configured)\nyellow: a dms3client is late in reporting, exceeding its configured reporting interval\nred: a dms3client has not reported to the server, and requires attention\nin the image above, five dms3 device components are displayed in the dms3dashboard: one dms3server (listed first), and four dms3client device components. one dms3client--picam-alpha--is late in reporting to the server, and so its icon has turned yellow to warn the user of its potentially failing status\nthe new dms3dashboard component is written using go's html templating package, making it very easy to integrate new or existing html template themes into the component. the template used by dms3dashboard is based largely on the following resources:\ncreative tim's paper dashboard theme\nfonts provided by icomoon\nnote that the dms3dashboard version of the paper dashboard design is heavily modified (primarily reduced in size and resources, and js removed), and the original themify fonts replaced with icomoon fonts, among other design changes. to demo the unadulternated paper dashboard template in action, see creative tim's excellent live preview here.\n1. what is dms3?\nif you appreciate isometric drawings, please check out our isometric-icons project, located here.\ndistributed motion surveillance security system (dms3) is a go-based application that integrates third-party open-source motion detection applications (e.g., the motion motion detection software package, or opencv, the open source computer vision library) into a distributed surveillance system that:\nsenses when someone is \"at home\" and when someone is \"not home\" and automatically enables or disables the surveillance system\ndistributes video stream processing, reporting, and user notification to capable \"smart\" device clients (e.g., a raspberry pi) which:\nminimizes network congestion, particularly during high-bandwidth surveillance events of interest\nbetter utilizes smart device client endpoint cpu processing power: keeping stream processing \"on-board\" and localized\nworks cooperatively with legacy \"less smart\" device clients such as ip cameras (wired or wifi), webcams, and other usb camera devices\n2. dms3 features\nhere's a list of some of the more outstanding features of dms3:\nmotion detection application support\nwhile dms3 is primarily responsible for sensing user proxies and determining when to enable or disable the surveillance system, it alone does not manage the processing of video stream data. that complex, real-time task is left to motion detection libraries/applications which can be integrated into dms3.\nsupport for the motion motion detector software package\nmovement detection support of video devices. see this list for video device compatibility. note that dms3 was developed and tested using smart device clients running motion with native camera support (e.g., a raspberry pi with an on-board camera module)\nsupport for the opencv library [planned]\nopencv support is highly anticipated, but still experimental, though the current codebase cleanly abstracts away any specific motion detection application dependencies so it should be a very straightforward integration\ndms3client & dms3server features\nnew! support for the new dms3dashboard component, allowing for the easy, visual monitoring of all dms3client devices managed by a dms3server component\nmobile first, responsive, web-based design\nuses go's html templating package to simplify html integration\neasily integrate 3rd-party configurable html website templates\nautomated starting/stopping of any number of motion detection applications installed on smart device clients (e.g., the motion motion detector software package) based on the presence/absence of user proxy devices\nalways on feature starts/stops the motion detection application based on time-of-day (e.g., can enable video surveillance during nighttime or specific holiday hours)\noptionally play audio file(s) on surveillance system enable/disable\nconfigurable event logging\ninfo, error, fatal, and debug log levels\npersist logs to file or stdout\nmultiple user proxy device support (can sense device presence/absence from a list of devices)\nmac (layer 2) address sensing\nipv4 protocol support\nipv6 protocol support [planned]\nbluetooth user proxy sensing (using rssi, l2cap, or similar) [planned]\ndevice clients can be custom-configured to process and respond to surveillance event data independently and uniquely (e.g., an -----> outdoor !!!  ir camera device only sends email during nighttime hours)\nsupport for \"smart\" and \"less smart\" device clients\ndms3 is designed to utilize intelligent iot sensing devices, called smart device clients (sdcs), while still supporting less intelligent, single-purpose devices, called less smart device clients (lsdcs).\ndms3 smart device clients (sdcs) are hardware devices capable of processing local video streams for motion detection on-board, with dedicated hardware. most computers and smaller single board computers (iot sbcs) would be classed as smart device clients, including:\nraspberry pis (dms3 was tested with the rasppi model 2, model 3, and pi zero w) with a configured on-board camera\nany iot single board computer (sbc) capable of running a unix-like operating system\npersonal computers with a camera and wired or wireless (wifi) connectivity\ndms3 less smart device clients (lsdcs) are hardware devices--typically purpose-built--unable to locally process motion detection in video streams. these devices generate raw real-time video data, which is then consumed and processed by an external device(s), oftentimes across the network. some examples of lsdcs include:\nip cameras (e.g., the nest cam), either wired or wireless (wifi)\nwebcams, typically using usb connections and run from a desktop computer\ndms3mail features\ndeveloped for use exclusively with motion, dms3mail is an automated, real-time email notification service triggered by motion-generated detection events\nfully configurable email message subject, body, etc.\noptionally attach an event image or video to an email message\nsmtp-support for compatibility with most webmail services (e.g., gmail)\nconfigurable event logging\ninfo, error, fatal, and debug log levels\npersist logs to file or stdout\n3. dms3 use cases\n\"leaving home, coming home\"\nat its core, dms3 sensing relies on the concept of a user proxy. in this context, a user proxy is any device representing a user that can be sensed on a home network. a smartphone is an excellent user proxy, assuming that a user's smartphone is active on a home network when the user is \"at home,\" and leaves the network when the user \"leaves home.\"\nthis concept can extend to multiple user proxies, making it possible for dms3 to keep a surveillance system disabled until everyone in a family has left home: once the last registered user proxy is no longer sensed on the home network, dms3 automatically enables the surveillance system.\nthe reverse is true as well: dms3 will keep a surveillance system enabled only until the first user proxy is seen on the home network (e.g., someone pulling into the driveway), at which time dms3 will automatically disable the surveillance system.\n\"nighttime surveillance\"\nin addition to sensing user proxies, dms3 can be configured to keep a surveillance system enabled over specific periods of time. called always on, this dms3 feature works as an override for user proxies: regardless of whether dms3 senses a user proxy on the network, as long as the time-of-day policy is met, dms3 will enable the surveillance system.\nthis feature is particularly useful for nighttime surveillance, when users may be asleep and/or smartphones may be turned off. for example, dms3 can be configured to turn a surveillance system on at 2330, and stay on until 0500 the next morning. during this time, dms3 will remain operational and report surveillance events as they occur.\n4. dms3 components\ndms3 is organized into the following application components:\ndms3server: integrated server-side system services that determine whether to enable/disable the surveillance system, and regularly update participating dms3 device clients of that surveillance state\ndms3client: client-side endpoint services that start/stop the locally-installed motion detection application (e.g., motion). any number of dms3client clients can exist as part of the dms3 surveillance system\ndms3libs: a set of related shared libraries used for managing dms3 client-server services including low-level system and networking commands, system logging, and unit testing\ndms3dashboard: an optionally-enabled component that permits for the visual inspection of dms3 component metrics through a web browser\noptional for smart device clients configured to use the motion motion detection application:\ndms3mail: a separate configurable dms3 component for generating and sending an email with videos/images whenever a client running motion generates a significant motion-related hook events (such as on_picture_save and on_movie_end)\n5.0 dms3 architecture\ndms3 is patterned after a client server model, where dms3server is centrally responsible for the logic of enabling/disabling the video surveillance system, while each participating smart device client is responsible for starting/stopping the locally-installed motion detection application. for less smart device clients, the processing of video stream data is passed over the wire to the server for processing and eventual system response and/or user notification.\nin the example presented at the start of this document, one ip camera device, one iot sbc device (a raspberry pi), and one webcam device are managed through dms3server (using the tcp protocol). dms3server determines when to enable/disable the surveillance system, and notifies each participating device client. since the raspberry pi can be configured to run a local instance of a motion detection application (it's a smart device client), actual video stream processing, imaging, and eventual reporting is done locally.\nthe webcam device and the ip camera device--both less smart device clients, and incapable of on-board stream processing--must pass raw stream data along to a device proxy running dms3client, which then applies motion detection processing on the incoming video streams.\n6.0 how dms3 works\ndms3server operation\ndms3server is responsible for signaling the logic of enabling/disabling the video surveillance system to all device client endpoints. that is, dms3server sends either a start or a stop message to all dms3 device clients listening on the network.\ndms3server does this by periodically scanning the network for the existence of a registered user proxie(s). this device can be anything that exposes its mac address on the network (e.g., a mobile phone on a home lan). if that device is found on the network, it's assumed that \"someone is home\" and so, dms3server sends out a stop message to all participating device clients, and their respective motion detection application is stopped (if currently running).\nif that user proxy mac \"leaves\" and is no longer found on the network, it's assumed that \"nobody is home\", and dms3server sends out a start message to all participating device clients, and the motion detection application on that client is started (if currently stopped). similar logic is used in the reverse case: when a user proxy is once again \"back home,\" the motion detection application of each device client is signalled to stop.\nalternatively, the always on feature uses time-of-day to enable/disable the surveillance system. dms3server will look at the time range specified, and if the current time falls between the time range, the motion detection application of all client devices will be started. once the current time falls outside of the specified time range, the motion detection application for each device client is then stopped.\nnote that dms3server only signals to participating device clients the current state of the video surveillance system. each device client is ultimately responsible for starting/stopping its local instance of the installed motion detection application\ndms3client operation\nrunning on smart device clients (sdcs)\ndms3client runs on each configured smart device client endpoint, and is responsible for starting/stopping its locally installed motion detection application. dms3client does this by periodically listening to dms3server at the pre-configured ip address and port (network socket address). when dms3client receives a change in motion detection application state, it either starts or stops its locally-installed motion detection application.\nrunning with less smart device clients (lsdcs)\nin instances where the device client is \"less smart\" and unable to process motion detection in local video streams, an lsdc instead passes motion detection processing to a dms3client proxy. multiple lsdcs can be served by a single dms3client proxy. this proxy is then responsible for the operations of a typical dms3client.\ndms3client / dms3server work flow\noperationally, dms3server and all dms3client device clients work in concert to establish a synchronized video surveillance state across all endpoints:\ndms3server: usually configured as a daemon running on a central server, and walks a logic tree whenever a client connects (or re-connects) to the server. dms3server is responsible for answering the question \"should the surveillance system be enabled or disabled right now?\"\ndms3client: usually configured as a daemon that runs on each of the participating smart device clients, dms3client regularly polls (at a configurable interval) dms3server, and receives from dms3server the current motion detection application state (called motiondetectorstate), that is, whether the locally installed motion detection application should be started or stopped\nthe activity diagram below shows the work flow of these two components:\ndms3mail operation\nwhen using motion, dms3mail is a feature written for dms3 that allows for the creation and sending an email whenever a valid capture event is triggered in motion. dms3mail is very tightly integrated into motion, where image and video capture events are identified, analyzed, and processed. dms3mail is triggered by the on_picture_save and the on_movie_end commands in motion.\nnote: the optional dms3mail feature is called by neither dms3client nor dms3server. instead, dms3mail is called by the motion motion detection application via the command-line.\nthe syntax for these motion commands are:\n<on_picture_save|on_movie_end> <absolute path to go_dms3mail> -pixels=%d -filename=%f -camera=%t\nthese commands are managed through the motion configuration file called motion.conf.\nonce configured, dms3mail will respond to these two motion event hooks, and an email will be generated and sent out with an optional image file or video clip capturing the surveillance event of interest.\nnote: additional information about dms3mail can be found in the dms3 installation file (install.md).\n7. dms3 requirements\na unix-like operating system installed on the server and smart device client (sdc) endpoints\nwhile dms3 was written and tested under linux (ubuntu 17.04), there should be no reason why this won't work under other linux distributions\na motion detection application, such as motion, correctly installed and configured with appropriate video devices configured on all smart device clients\nspecific unix-like commands and tools used by dms3 components include (all should already exist on most unix-like operating systems):\narp: address resolution protocol\ngrep: globally search a regular expression and print\npgrep: globally search a regular expression and print\nping: icmp network packet echo/response tool\naplay: alsa audio player (optional)\n8. dms3 installation\ndms3 provides two separate installation documents:\nquick installation: uses the available dms3build build tools and installer to provided automated installation of dms3 components across participating hardware devices\nmanual installation: uses project sources to first compile for specific hardware device platforms, and then manually install dms3 components\nnote: to learn more about the technical details of the dms3 project, refer to the manual installation documentation, as this document provides much greater technical depth in describing the dms3 installation process\n9. license\nthe mit license (mit)\ncopyright (c) business learning incorporated\npermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"software\"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:\nthe above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.\nthe software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.", "sortedWord": "None", "removed": "Nan", "score": null, "comments": null, "media": "Nan", "medialink": "Nan", "identifyer": 7000845, "year": null}], "name": "outdoorIot"}